"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@floating-ui";
exports.ids = ["vendor-chunks/@floating-ui"];
exports.modules = {

/***/ "(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@floating-ui/core/dist/floating-ui.core.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* binding */ detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   rectToClientRect: () => (/* reexport safe */ _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\nconst _excluded = [\"crossAxis\", \"alignment\", \"allowedPlacements\", \"autoAlignment\"],\n  _excluded2 = [\"mainAxis\", \"crossAxis\", \"fallbackPlacements\", \"fallbackStrategy\", \"fallbackAxisSideDirection\", \"flipAlignment\"],\n  _excluded3 = [\"strategy\"],\n  _excluded4 = [\"mainAxis\", \"crossAxis\", \"limiter\"],\n  _excluded5 = [\"apply\"];\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);\n  const alignmentAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);\n  const alignLength = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(alignmentAxis);\n  const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch ((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = _objectSpread(_objectSpread({}, middlewareData), {}, {\n      [name]: _objectSpread(_objectSpread({}, middlewareData[name]), data)\n    });\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n  const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? _objectSpread(_objectSpread({}, rects.floating), {}, {\n    x,\n    y\n  }) : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);\n    const length = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: _objectSpread({\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset\n      }, shouldAddOffset && {\n        alignmentOffset\n      }),\n      reset: shouldAddOffset\n    };\n  }\n});\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment), ...allowedPlacements.filter(placement => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) !== alignment)] : allowedPlacements.filter(placement => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment || (autoAlignment ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAlignmentPlacement)(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const _evaluate = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state),\n        {\n          crossAxis = false,\n          alignment,\n          allowedPlacements = _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements,\n          autoAlignment = true\n        } = _evaluate,\n        detectOverflowOptions = _objectWithoutProperties(_evaluate, _excluded);\n      const placements$1 = alignment !== undefined || allowedPlacements === _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const _evaluate2 = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state),\n        {\n          mainAxis: checkMainAxis = true,\n          crossAxis: checkCrossAxis = true,\n          fallbackPlacements: specifiedFallbackPlacements,\n          fallbackStrategy = 'bestFit',\n          fallbackAxisSideDirection = 'none',\n          flipAlignment = true\n        } = _evaluate2,\n        detectOverflowOptions = _objectWithoutProperties(_evaluate2, _excluded2);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n      const isBasePlacement = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositePlacement)(initialPlacement)] : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getExpandedPlacements)(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxisPlacements)(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const _evaluate3 = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state),\n        {\n          strategy = 'referenceHidden'\n        } = _evaluate3,\n        detectOverflowOptions = _objectWithoutProperties(_evaluate3, _excluded3);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, _objectSpread(_objectSpread({}, detectOverflowOptions), {}, {\n              elementContext: 'reference'\n            }));\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, _objectSpread(_objectSpread({}, detectOverflowOptions), {}, {\n              altBoundary: true\n            }));\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\nfunction getBoundingRect(rects) {\n  const minX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map(rect => rect.left));\n  const minY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map(rect => rect.top));\n  const maxX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map(rect => rect.right));\n  const maxY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(nativeClientRects));\n      const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if ((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === 'left';\n          const maxRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...clientRects.map(rect => rect.right));\n          const minLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n  const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);\n  const isVertical = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : _objectSpread({\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null\n  }, rawValue);\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: _objectSpread(_objectSpread({}, diffCoords), {}, {\n          placement\n        })\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const _evaluate4 = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state),\n        {\n          mainAxis: checkMainAxis = true,\n          crossAxis: checkCrossAxis = false,\n          limiter = {\n            fn: _ref => {\n              let {\n                x,\n                y\n              } = _ref;\n              return {\n                x,\n                y\n              };\n            }\n          }\n        } = _evaluate4,\n        detectOverflowOptions = _objectWithoutProperties(_evaluate4, _excluded4);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));\n      const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn(_objectSpread(_objectSpread({}, state), {}, {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      }));\n      return _objectSpread(_objectSpread({}, limitedCoords), {}, {\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      });\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);\n      const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : _objectSpread({\n        mainAxis: 0,\n        crossAxis: 0\n      }, rawOffset);\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const _evaluate5 = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state),\n        {\n          apply = () => {}\n        } = _evaluate5,\n        detectOverflowOptions = _objectWithoutProperties(_evaluate5, _excluded5);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n      const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);\n      const isYAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const overflowAvailableHeight = height - overflow[heightSide];\n      const overflowAvailableWidth = width - overflow[widthSide];\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isYAxis) {\n        const maximumClippingWidth = width - overflow.left - overflow.right;\n        availableWidth = alignment || noShift ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        const maximumClippingHeight = height - overflow.top - overflow.bottom;\n        availableHeight = alignment || noShift ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, 0);\n        const xMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.right, 0);\n        const yMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, 0);\n        const yMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, overflow.bottom));\n        }\n      }\n      await apply(_objectSpread(_objectSpread({}, state), {}, {\n        availableWidth,\n        availableHeight\n      }));\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2NvcmUvZGlzdC9mbG9hdGluZy11aS5jb3JlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNVO0FBQ2hSO0FBRXRELFNBQVNtQiwwQkFBMEJBLENBQUNDLElBQUksRUFBRUMsU0FBUyxFQUFFQyxHQUFHLEVBQUU7RUFDeEQsSUFBSTtJQUNGQyxTQUFTO0lBQ1RDO0VBQ0YsQ0FBQyxHQUFHSixJQUFJO0VBQ1IsTUFBTUssUUFBUSxHQUFHekIsK0RBQVcsQ0FBQ3FCLFNBQVMsQ0FBQztFQUN2QyxNQUFNSyxhQUFhLEdBQUd6QixvRUFBZ0IsQ0FBQ29CLFNBQVMsQ0FBQztFQUNqRCxNQUFNTSxXQUFXLEdBQUd6QixpRUFBYSxDQUFDd0IsYUFBYSxDQUFDO0VBQ2hELE1BQU1FLElBQUksR0FBR3pCLDJEQUFPLENBQUNrQixTQUFTLENBQUM7RUFDL0IsTUFBTVEsVUFBVSxHQUFHSixRQUFRLEtBQUssR0FBRztFQUNuQyxNQUFNSyxPQUFPLEdBQUdQLFNBQVMsQ0FBQ1EsQ0FBQyxHQUFHUixTQUFTLENBQUNTLEtBQUssR0FBRyxDQUFDLEdBQUdSLFFBQVEsQ0FBQ1EsS0FBSyxHQUFHLENBQUM7RUFDdEUsTUFBTUMsT0FBTyxHQUFHVixTQUFTLENBQUNXLENBQUMsR0FBR1gsU0FBUyxDQUFDWSxNQUFNLEdBQUcsQ0FBQyxHQUFHWCxRQUFRLENBQUNXLE1BQU0sR0FBRyxDQUFDO0VBQ3hFLE1BQU1DLFdBQVcsR0FBR2IsU0FBUyxDQUFDSSxXQUFXLENBQUMsR0FBRyxDQUFDLEdBQUdILFFBQVEsQ0FBQ0csV0FBVyxDQUFDLEdBQUcsQ0FBQztFQUMxRSxJQUFJVSxNQUFNO0VBQ1YsUUFBUVQsSUFBSTtJQUNWLEtBQUssS0FBSztNQUNSUyxNQUFNLEdBQUc7UUFDUE4sQ0FBQyxFQUFFRCxPQUFPO1FBQ1ZJLENBQUMsRUFBRVgsU0FBUyxDQUFDVyxDQUFDLEdBQUdWLFFBQVEs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Q3ZDLEtBQUssQ0FBQyxDQUFDO1FBQzVHLENBQUMsTUFBTTtVQUNMdUosZUFBZSxHQUFHOU0sTUFBTSxHQUFHLENBQUMsSUFBSW9OLElBQUksS0FBSyxDQUFDLElBQUlDLElBQUksS0FBSyxDQUFDLEdBQUdELElBQUksR0FBR0MsSUFBSSxHQUFHdk8sdURBQUcsQ0FBQ2dILFFBQVEsQ0FBQzFDLEdBQUcsRUFBRTBDLFFBQVEsQ0FBQ3pDLE1BQU0sQ0FBQyxDQUFDO1FBQzlHO01BQ0Y7TUFDQSxNQUFNa0osS0FBSyxDQUFBNUssYUFBQSxDQUFBQSxhQUFBLEtBQ05FLEtBQUs7UUFDUmtMLGNBQWM7UUFDZEQ7TUFBZSxFQUNoQixDQUFDO01BQ0YsTUFBTVEsY0FBYyxHQUFHLE1BQU0vTSxRQUFRLENBQUNvRCxhQUFhLENBQUNqQyxRQUFRLENBQUNyQyxRQUFRLENBQUM7TUFDdEUsSUFBSVEsS0FBSyxLQUFLeU4sY0FBYyxDQUFDek4sS0FBSyxJQUFJRyxNQUFNLEtBQUtzTixjQUFjLENBQUN0TixNQUFNLEVBQUU7UUFDdEUsT0FBTztVQUNMd0IsS0FBSyxFQUFFO1lBQ0xaLEtBQUssRUFBRTtVQUNUO1FBQ0YsQ0FBQztNQUNIO01BQ0EsT0FBTyxDQUFDLENBQUM7SUFDWDtFQUNGLENBQUM7QUFDSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcS1nZW5pZS8uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvY29yZS9kaXN0L2Zsb2F0aW5nLXVpLmNvcmUubWpzPzU2YmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0U2lkZUF4aXMsIGdldEFsaWdubWVudEF4aXMsIGdldEF4aXNMZW5ndGgsIGdldFNpZGUsIGdldEFsaWdubWVudCwgZXZhbHVhdGUsIGdldFBhZGRpbmdPYmplY3QsIHJlY3RUb0NsaWVudFJlY3QsIG1pbiwgY2xhbXAsIHBsYWNlbWVudHMsIGdldEFsaWdubWVudFNpZGVzLCBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQsIGdldEV4cGFuZGVkUGxhY2VtZW50cywgZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cywgc2lkZXMsIG1heCwgZ2V0T3Bwb3NpdGVBeGlzIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzJztcbmV4cG9ydCB7IHJlY3RUb0NsaWVudFJlY3QgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMnO1xuXG5mdW5jdGlvbiBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChfcmVmLCBwbGFjZW1lbnQsIHJ0bCkge1xuICBsZXQge1xuICAgIHJlZmVyZW5jZSxcbiAgICBmbG9hdGluZ1xuICB9ID0gX3JlZjtcbiAgY29uc3Qgc2lkZUF4aXMgPSBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbm1lbnRBeGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbkxlbmd0aCA9IGdldEF4aXNMZW5ndGgoYWxpZ25tZW50QXhpcyk7XG4gIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gIGNvbnN0IGlzVmVydGljYWwgPSBzaWRlQXhpcyA9PT0gJ3knO1xuICBjb25zdCBjb21tb25YID0gcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGggLyAyIC0gZmxvYXRpbmcud2lkdGggLyAyO1xuICBjb25zdCBjb21tb25ZID0gcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGZsb2F0aW5nLmhlaWdodCAvIDI7XG4gIGNvbnN0IGNvbW1vbkFsaWduID0gcmVmZXJlbmNlW2FsaWduTGVuZ3RoXSAvIDIgLSBmbG9hdGluZ1thbGlnbkxlbmd0aF0gLyAyO1xuICBsZXQgY29vcmRzO1xuICBzd2l0Y2ggKHNpZGUpIHtcbiAgICBjYXNlICd0b3AnOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSAtIGZsb2F0aW5nLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBmbG9hdGluZy53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54LFxuICAgICAgICB5OiByZWZlcmVuY2UueVxuICAgICAgfTtcbiAgfVxuICBzd2l0Y2ggKGdldEFsaWdubWVudChwbGFjZW1lbnQpKSB7XG4gICAgY2FzZSAnc3RhcnQnOlxuICAgICAgY29vcmRzW2FsaWdubWVudEF4aXNdIC09IGNvbW1vbkFsaWduICogKHJ0bCAmJiBpc1ZlcnRpY2FsID8gLTEgOiAxKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2VuZCc6XG4gICAgICBjb29yZHNbYWxpZ25tZW50QXhpc10gKz0gY29tbW9uQWxpZ24gKiAocnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDEpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGNvb3Jkcztcbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgdGhhdCB3aWxsIHBsYWNlIHRoZSBmbG9hdGluZyBlbGVtZW50XG4gKiBuZXh0IHRvIGEgZ2l2ZW4gcmVmZXJlbmNlIGVsZW1lbnQuXG4gKlxuICogVGhpcyBleHBvcnQgZG9lcyBub3QgaGF2ZSBhbnkgYHBsYXRmb3JtYCBpbnRlcmZhY2UgbG9naWMuIFlvdSB3aWxsIG5lZWQgdG9cbiAqIHdyaXRlIG9uZSBmb3IgdGhlIHBsYXRmb3JtIHlvdSBhcmUgdXNpbmcgRmxvYXRpbmcgVUkgd2l0aC5cbiAqL1xuY29uc3QgY29tcHV0ZVBvc2l0aW9uID0gYXN5bmMgKHJlZmVyZW5jZSwgZmxvYXRpbmcsIGNvbmZpZykgPT4ge1xuICBjb25zdCB7XG4gICAgcGxhY2VtZW50ID0gJ2JvdHRvbScsXG4gICAgc3RyYXRlZ3kgPSAnYWJzb2x1dGUnLFxuICAgIG1pZGRsZXdhcmUgPSBbXSxcbiAgICBwbGF0Zm9ybVxuICB9ID0gY29uZmlnO1xuICBjb25zdCB2YWxpZE1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlLmZpbHRlcihCb29sZWFuKTtcbiAgY29uc3QgcnRsID0gYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChmbG9hdGluZykpO1xuICBsZXQgcmVjdHMgPSBhd2FpdCBwbGF0Zm9ybS5nZXRFbGVtZW50UmVjdHMoe1xuICAgIHJlZmVyZW5jZSxcbiAgICBmbG9hdGluZyxcbiAgICBzdHJhdGVneVxuICB9KTtcbiAgbGV0IHtcbiAgICB4LFxuICAgIHlcbiAgfSA9IGNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50KHJlY3RzLCBwbGFjZW1lbnQsIHJ0bCk7XG4gIGxldCBzdGF0ZWZ1bFBsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgbGV0IG1pZGRsZXdhcmVEYXRhID0ge307XG4gIGxldCByZXNldENvdW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWxpZE1pZGRsZXdhcmUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgZm5cbiAgICB9ID0gdmFsaWRNaWRkbGV3YXJlW2ldO1xuICAgIGNvbnN0IHtcbiAgICAgIHg6IG5leHRYLFxuICAgICAgeTogbmV4dFksXG4gICAgICBkYXRhLFxuICAgICAgcmVzZXRcbiAgICB9ID0gYXdhaXQgZm4oe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBpbml0aWFsUGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBwbGFjZW1lbnQ6IHN0YXRlZnVsUGxhY2VtZW50LFxuICAgICAgc3RyYXRlZ3ksXG4gICAgICBtaWRkbGV3YXJlRGF0YSxcbiAgICAgIHJlY3RzLFxuICAgICAgcGxhdGZvcm0sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgIGZsb2F0aW5nXG4gICAgICB9XG4gICAgfSk7XG4gICAgeCA9IG5leHRYICE9IG51bGwgPyBuZXh0WCA6IHg7XG4gICAgeSA9IG5leHRZICE9IG51bGwgPyBuZXh0WSA6IHk7XG4gICAgbWlkZGxld2FyZURhdGEgPSB7XG4gICAgICAuLi5taWRkbGV3YXJlRGF0YSxcbiAgICAgIFtuYW1lXToge1xuICAgICAgICAuLi5taWRkbGV3YXJlRGF0YVtuYW1lXSxcbiAgICAgICAgLi4uZGF0YVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHJlc2V0ICYmIHJlc2V0Q291bnQgPD0gNTApIHtcbiAgICAgIHJlc2V0Q291bnQrKztcbiAgICAgIGlmICh0eXBlb2YgcmVzZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChyZXNldC5wbGFjZW1lbnQpIHtcbiAgICAgICAgICBzdGF0ZWZ1bFBsYWNlbWVudCA9IHJlc2V0LnBsYWNlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzZXQucmVjdHMpIHtcbiAgICAgICAgICByZWN0cyA9IHJlc2V0LnJlY3RzID09PSB0cnVlID8gYXdhaXQgcGxhdGZvcm0uZ2V0RWxlbWVudFJlY3RzKHtcbiAgICAgICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgICAgIGZsb2F0aW5nLFxuICAgICAgICAgICAgc3RyYXRlZ3lcbiAgICAgICAgICB9KSA6IHJlc2V0LnJlY3RzO1xuICAgICAgICB9XG4gICAgICAgICh7XG4gICAgICAgICAgeCxcbiAgICAgICAgICB5XG4gICAgICAgIH0gPSBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChyZWN0cywgc3RhdGVmdWxQbGFjZW1lbnQsIHJ0bCkpO1xuICAgICAgfVxuICAgICAgaSA9IC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeSxcbiAgICBwbGFjZW1lbnQ6IHN0YXRlZnVsUGxhY2VtZW50LFxuICAgIHN0cmF0ZWd5LFxuICAgIG1pZGRsZXdhcmVEYXRhXG4gIH07XG59O1xuXG4vKipcbiAqIFJlc29sdmVzIHdpdGggYW4gb2JqZWN0IG9mIG92ZXJmbG93IHNpZGUgb2Zmc2V0cyB0aGF0IGRldGVybWluZSBob3cgbXVjaCB0aGVcbiAqIGVsZW1lbnQgaXMgb3ZlcmZsb3dpbmcgYSBnaXZlbiBjbGlwcGluZyBib3VuZGFyeSBvbiBlYWNoIHNpZGUuXG4gKiAtIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGJvdW5kYXJ5IGJ5IHRoYXQgbnVtYmVyIG9mIHBpeGVsc1xuICogLSBuZWdhdGl2ZSA9IGhvdyBtYW55IHBpeGVscyBsZWZ0IGJlZm9yZSBpdCB3aWxsIG92ZXJmbG93XG4gKiAtIDAgPSBsaWVzIGZsdXNoIHdpdGggdGhlIGJvdW5kYXJ5XG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZGV0ZWN0T3ZlcmZsb3dcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIG9wdGlvbnMpIHtcbiAgdmFyIF9hd2FpdCRwbGF0Zm9ybSRpc0VsZTtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgeCxcbiAgICB5LFxuICAgIHBsYXRmb3JtLFxuICAgIHJlY3RzLFxuICAgIGVsZW1lbnRzLFxuICAgIHN0cmF0ZWd5XG4gIH0gPSBzdGF0ZTtcbiAgY29uc3Qge1xuICAgIGJvdW5kYXJ5ID0gJ2NsaXBwaW5nQW5jZXN0b3JzJyxcbiAgICByb290Qm91bmRhcnkgPSAndmlld3BvcnQnLFxuICAgIGVsZW1lbnRDb250ZXh0ID0gJ2Zsb2F0aW5nJyxcbiAgICBhbHRCb3VuZGFyeSA9IGZhbHNlLFxuICAgIHBhZGRpbmcgPSAwXG4gIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpO1xuICBjb25zdCBhbHRDb250ZXh0ID0gZWxlbWVudENvbnRleHQgPT09ICdmbG9hdGluZycgPyAncmVmZXJlbmNlJyA6ICdmbG9hdGluZyc7XG4gIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gIGNvbnN0IGNsaXBwaW5nQ2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QoYXdhaXQgcGxhdGZvcm0uZ2V0Q2xpcHBpbmdSZWN0KHtcbiAgICBlbGVtZW50OiAoKF9hd2FpdCRwbGF0Zm9ybSRpc0VsZSA9IGF3YWl0IChwbGF0Zm9ybS5pc0VsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzRWxlbWVudChlbGVtZW50KSkpICE9IG51bGwgPyBfYXdhaXQkcGxhdGZvcm0kaXNFbGUgOiB0cnVlKSA/IGVsZW1lbnQgOiBlbGVtZW50LmNvbnRleHRFbGVtZW50IHx8IChhd2FpdCAocGxhdGZvcm0uZ2V0RG9jdW1lbnRFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudHMuZmxvYXRpbmcpKSksXG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIHN0cmF0ZWd5XG4gIH0pKTtcbiAgY29uc3QgcmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSAnZmxvYXRpbmcnID8ge1xuICAgIC4uLnJlY3RzLmZsb2F0aW5nLFxuICAgIHgsXG4gICAgeVxuICB9IDogcmVjdHMucmVmZXJlbmNlO1xuICBjb25zdCBvZmZzZXRQYXJlbnQgPSBhd2FpdCAocGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgY29uc3Qgb2Zmc2V0U2NhbGUgPSAoYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KG9mZnNldFBhcmVudCkpKSA/IChhd2FpdCAocGxhdGZvcm0uZ2V0U2NhbGUgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldFNjYWxlKG9mZnNldFBhcmVudCkpKSB8fCB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH0gOiB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH07XG4gIGNvbnN0IGVsZW1lbnRDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChwbGF0Zm9ybS5jb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCA/IGF3YWl0IHBsYXRmb3JtLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KHtcbiAgICBlbGVtZW50cyxcbiAgICByZWN0LFxuICAgIG9mZnNldFBhcmVudCxcbiAgICBzdHJhdGVneVxuICB9KSA6IHJlY3QpO1xuICByZXR1cm4ge1xuICAgIHRvcDogKGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCkgLyBvZmZzZXRTY2FsZS55LFxuICAgIGJvdHRvbTogKGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSkgLyBvZmZzZXRTY2FsZS55LFxuICAgIGxlZnQ6IChjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQpIC8gb2Zmc2V0U2NhbGUueCxcbiAgICByaWdodDogKGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodCkgLyBvZmZzZXRTY2FsZS54XG4gIH07XG59XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93ID0gb3B0aW9ucyA9PiAoe1xuICBuYW1lOiAnYXJyb3cnLFxuICBvcHRpb25zLFxuICBhc3luYyBmbihzdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcGxhY2VtZW50LFxuICAgICAgcmVjdHMsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgbWlkZGxld2FyZURhdGFcbiAgICB9ID0gc3RhdGU7XG4gICAgLy8gU2luY2UgYGVsZW1lbnRgIGlzIHJlcXVpcmVkLCB3ZSBkb24ndCBQYXJ0aWFsPD4gdGhlIHR5cGUuXG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudCxcbiAgICAgIHBhZGRpbmcgPSAwXG4gICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKSB8fCB7fTtcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpO1xuICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgICBjb25zdCBheGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEF4aXNMZW5ndGgoYXhpcyk7XG4gICAgY29uc3QgYXJyb3dEaW1lbnNpb25zID0gYXdhaXQgcGxhdGZvcm0uZ2V0RGltZW5zaW9ucyhlbGVtZW50KTtcbiAgICBjb25zdCBpc1lBeGlzID0gYXhpcyA9PT0gJ3knO1xuICAgIGNvbnN0IG1pblByb3AgPSBpc1lBeGlzID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgY29uc3QgbWF4UHJvcCA9IGlzWUF4aXMgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgY29uc3QgY2xpZW50UHJvcCA9IGlzWUF4aXMgPyAnY2xpZW50SGVpZ2h0JyA6ICdjbGllbnRXaWR0aCc7XG4gICAgY29uc3QgZW5kRGlmZiA9IHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdICsgcmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gY29vcmRzW2F4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXTtcbiAgICBjb25zdCBzdGFydERpZmYgPSBjb29yZHNbYXhpc10gLSByZWN0cy5yZWZlcmVuY2VbYXhpc107XG4gICAgY29uc3QgYXJyb3dPZmZzZXRQYXJlbnQgPSBhd2FpdCAocGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkpO1xuICAgIGxldCBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBhcnJvd09mZnNldFBhcmVudFtjbGllbnRQcm9wXSA6IDA7XG5cbiAgICAvLyBET00gcGxhdGZvcm0gY2FuIHJldHVybiBgd2luZG93YCBhcyB0aGUgYG9mZnNldFBhcmVudGAuXG4gICAgaWYgKCFjbGllbnRTaXplIHx8ICEoYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KGFycm93T2Zmc2V0UGFyZW50KSkpKSB7XG4gICAgICBjbGllbnRTaXplID0gZWxlbWVudHMuZmxvYXRpbmdbY2xpZW50UHJvcF0gfHwgcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXTtcbiAgICB9XG4gICAgY29uc3QgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7XG5cbiAgICAvLyBJZiB0aGUgcGFkZGluZyBpcyBsYXJnZSBlbm91Z2ggdGhhdCBpdCBjYXVzZXMgdGhlIGFycm93IHRvIG5vIGxvbmdlciBiZVxuICAgIC8vIGNlbnRlcmVkLCBtb2RpZnkgdGhlIHBhZGRpbmcgc28gdGhhdCBpdCBpcyBjZW50ZXJlZC5cbiAgICBjb25zdCBsYXJnZXN0UG9zc2libGVQYWRkaW5nID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAvIDIgLSAxO1xuICAgIGNvbnN0IG1pblBhZGRpbmcgPSBtaW4ocGFkZGluZ09iamVjdFttaW5Qcm9wXSwgbGFyZ2VzdFBvc3NpYmxlUGFkZGluZyk7XG4gICAgY29uc3QgbWF4UGFkZGluZyA9IG1pbihwYWRkaW5nT2JqZWN0W21heFByb3BdLCBsYXJnZXN0UG9zc2libGVQYWRkaW5nKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgZmxvYXRpbmcgZWxlbWVudCBpZiB0aGUgY2VudGVyXG4gICAgLy8gcG9pbnQgaXMgb3V0c2lkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCdzIGJvdW5kcy5cbiAgICBjb25zdCBtaW4kMSA9IG1pblBhZGRpbmc7XG4gICAgY29uc3QgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC0gbWF4UGFkZGluZztcbiAgICBjb25zdCBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICAgIGNvbnN0IG9mZnNldCA9IGNsYW1wKG1pbiQxLCBjZW50ZXIsIG1heCk7XG5cbiAgICAvLyBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsIGVub3VnaCB0aGF0IHRoZSBhcnJvdydzIHBhZGRpbmcgY2F1c2VzIGl0IHRvXG4gICAgLy8gdG8gcG9pbnQgdG8gbm90aGluZyBmb3IgYW4gYWxpZ25lZCBwbGFjZW1lbnQsIGFkanVzdCB0aGUgb2Zmc2V0IG9mIHRoZVxuICAgIC8vIGZsb2F0aW5nIGVsZW1lbnQgaXRzZWxmLiBUbyBlbnN1cmUgYHNoaWZ0KClgIGNvbnRpbnVlcyB0byB0YWtlIGFjdGlvbixcbiAgICAvLyBhIHNpbmdsZSByZXNldCBpcyBwZXJmb3JtZWQgd2hlbiB0aGlzIGlzIHRydWUuXG4gICAgY29uc3Qgc2hvdWxkQWRkT2Zmc2V0ID0gIW1pZGRsZXdhcmVEYXRhLmFycm93ICYmIGdldEFsaWdubWVudChwbGFjZW1lbnQpICE9IG51bGwgJiYgY2VudGVyICE9PSBvZmZzZXQgJiYgcmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gLyAyIC0gKGNlbnRlciA8IG1pbiQxID8gbWluUGFkZGluZyA6IG1heFBhZGRpbmcpIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLyAyIDwgMDtcbiAgICBjb25zdCBhbGlnbm1lbnRPZmZzZXQgPSBzaG91bGRBZGRPZmZzZXQgPyBjZW50ZXIgPCBtaW4kMSA/IGNlbnRlciAtIG1pbiQxIDogY2VudGVyIC0gbWF4IDogMDtcbiAgICByZXR1cm4ge1xuICAgICAgW2F4aXNdOiBjb29yZHNbYXhpc10gKyBhbGlnbm1lbnRPZmZzZXQsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIFtheGlzXTogb2Zmc2V0LFxuICAgICAgICBjZW50ZXJPZmZzZXQ6IGNlbnRlciAtIG9mZnNldCAtIGFsaWdubWVudE9mZnNldCxcbiAgICAgICAgLi4uKHNob3VsZEFkZE9mZnNldCAmJiB7XG4gICAgICAgICAgYWxpZ25tZW50T2Zmc2V0XG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgcmVzZXQ6IHNob3VsZEFkZE9mZnNldFxuICAgIH07XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBnZXRQbGFjZW1lbnRMaXN0KGFsaWdubWVudCwgYXV0b0FsaWdubWVudCwgYWxsb3dlZFBsYWNlbWVudHMpIHtcbiAgY29uc3QgYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudCA9IGFsaWdubWVudCA/IFsuLi5hbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldEFsaWdubWVudChwbGFjZW1lbnQpID09PSBhbGlnbm1lbnQpLCAuLi5hbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldEFsaWdubWVudChwbGFjZW1lbnQpICE9PSBhbGlnbm1lbnQpXSA6IGFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0U2lkZShwbGFjZW1lbnQpID09PSBwbGFjZW1lbnQpO1xuICByZXR1cm4gYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudC5maWx0ZXIocGxhY2VtZW50ID0+IHtcbiAgICBpZiAoYWxpZ25tZW50KSB7XG4gICAgICByZXR1cm4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgPT09IGFsaWdubWVudCB8fCAoYXV0b0FsaWdubWVudCA/IGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCkgIT09IHBsYWNlbWVudCA6IGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgY2hvb3NpbmcgdGhlIHBsYWNlbWVudFxuICogdGhhdCBoYXMgdGhlIG1vc3Qgc3BhY2UgYXZhaWxhYmxlIGF1dG9tYXRpY2FsbHksIHdpdGhvdXQgbmVlZGluZyB0byBzcGVjaWZ5IGFcbiAqIHByZWZlcnJlZCBwbGFjZW1lbnQuIEFsdGVybmF0aXZlIHRvIGBmbGlwYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvUGxhY2VtZW50XG4gKi9cbmNvbnN0IGF1dG9QbGFjZW1lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2F1dG9QbGFjZW1lbnQnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkYXV0b1AsIF9taWRkbGV3YXJlRGF0YSRhdXRvUDIsIF9wbGFjZW1lbnRzVGhhdEZpdE9uRTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjcm9zc0F4aXMgPSBmYWxzZSxcbiAgICAgICAgYWxpZ25tZW50LFxuICAgICAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMsXG4gICAgICAgIGF1dG9BbGlnbm1lbnQgPSB0cnVlLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBwbGFjZW1lbnRzJDEgPSBhbGlnbm1lbnQgIT09IHVuZGVmaW5lZCB8fCBhbGxvd2VkUGxhY2VtZW50cyA9PT0gcGxhY2VtZW50cyA/IGdldFBsYWNlbWVudExpc3QoYWxpZ25tZW50IHx8IG51bGwsIGF1dG9BbGlnbm1lbnQsIGFsbG93ZWRQbGFjZW1lbnRzKSA6IGFsbG93ZWRQbGFjZW1lbnRzO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9ICgoX21pZGRsZXdhcmVEYXRhJGF1dG9QID0gbWlkZGxld2FyZURhdGEuYXV0b1BsYWNlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRhdXRvUC5pbmRleCkgfHwgMDtcbiAgICAgIGNvbnN0IGN1cnJlbnRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzJDFbY3VycmVudEluZGV4XTtcbiAgICAgIGlmIChjdXJyZW50UGxhY2VtZW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgY29uc3QgYWxpZ25tZW50U2lkZXMgPSBnZXRBbGlnbm1lbnRTaWRlcyhjdXJyZW50UGxhY2VtZW50LCByZWN0cywgYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpKTtcblxuICAgICAgLy8gTWFrZSBgY29tcHV0ZUNvb3Jkc2Agc3RhcnQgZnJvbSB0aGUgcmlnaHQgcGxhY2UuXG4gICAgICBpZiAocGxhY2VtZW50ICE9PSBjdXJyZW50UGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50cyQxWzBdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudE92ZXJmbG93cyA9IFtvdmVyZmxvd1tnZXRTaWRlKGN1cnJlbnRQbGFjZW1lbnQpXSwgb3ZlcmZsb3dbYWxpZ25tZW50U2lkZXNbMF1dLCBvdmVyZmxvd1thbGlnbm1lbnRTaWRlc1sxXV1dO1xuICAgICAgY29uc3QgYWxsT3ZlcmZsb3dzID0gWy4uLigoKF9taWRkbGV3YXJlRGF0YSRhdXRvUDIgPSBtaWRkbGV3YXJlRGF0YS5hdXRvUGxhY2VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGF1dG9QMi5vdmVyZmxvd3MpIHx8IFtdKSwge1xuICAgICAgICBwbGFjZW1lbnQ6IGN1cnJlbnRQbGFjZW1lbnQsXG4gICAgICAgIG92ZXJmbG93czogY3VycmVudE92ZXJmbG93c1xuICAgICAgfV07XG4gICAgICBjb25zdCBuZXh0UGxhY2VtZW50ID0gcGxhY2VtZW50cyQxW2N1cnJlbnRJbmRleCArIDFdO1xuXG4gICAgICAvLyBUaGVyZSBhcmUgbW9yZSBwbGFjZW1lbnRzIHRvIGNoZWNrLlxuICAgICAgaWYgKG5leHRQbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpbmRleDogY3VycmVudEluZGV4ICsgMSxcbiAgICAgICAgICAgIG92ZXJmbG93czogYWxsT3ZlcmZsb3dzXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBuZXh0UGxhY2VtZW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcGxhY2VtZW50c1NvcnRlZEJ5TW9zdFNwYWNlID0gYWxsT3ZlcmZsb3dzLm1hcChkID0+IHtcbiAgICAgICAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KGQucGxhY2VtZW50KTtcbiAgICAgICAgcmV0dXJuIFtkLnBsYWNlbWVudCwgYWxpZ25tZW50ICYmIGNyb3NzQXhpcyA/XG4gICAgICAgIC8vIENoZWNrIGFsb25nIHRoZSBtYWluQXhpcyBhbmQgbWFpbiBjcm9zc0F4aXMgc2lkZS5cbiAgICAgICAgZC5vdmVyZmxvd3Muc2xpY2UoMCwgMikucmVkdWNlKChhY2MsIHYpID0+IGFjYyArIHYsIDApIDpcbiAgICAgICAgLy8gQ2hlY2sgb25seSB0aGUgbWFpbkF4aXMuXG4gICAgICAgIGQub3ZlcmZsb3dzWzBdLCBkLm92ZXJmbG93c107XG4gICAgICB9KS5zb3J0KChhLCBiKSA9PiBhWzFdIC0gYlsxXSk7XG4gICAgICBjb25zdCBwbGFjZW1lbnRzVGhhdEZpdE9uRWFjaFNpZGUgPSBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2UuZmlsdGVyKGQgPT4gZFsyXS5zbGljZSgwLFxuICAgICAgLy8gQWxpZ25lZCBwbGFjZW1lbnRzIHNob3VsZCBub3QgY2hlY2sgdGhlaXIgb3Bwb3NpdGUgY3Jvc3NBeGlzXG4gICAgICAvLyBzaWRlLlxuICAgICAgZ2V0QWxpZ25tZW50KGRbMF0pID8gMiA6IDMpLmV2ZXJ5KHYgPT4gdiA8PSAwKSk7XG4gICAgICBjb25zdCByZXNldFBsYWNlbWVudCA9ICgoX3BsYWNlbWVudHNUaGF0Rml0T25FID0gcGxhY2VtZW50c1RoYXRGaXRPbkVhY2hTaWRlWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3BsYWNlbWVudHNUaGF0Rml0T25FWzBdKSB8fCBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2VbMF1bMF07XG4gICAgICBpZiAocmVzZXRQbGFjZW1lbnQgIT09IHBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGluZGV4OiBjdXJyZW50SW5kZXggKyAxLFxuICAgICAgICAgICAgb3ZlcmZsb3dzOiBhbGxPdmVyZmxvd3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IHJlc2V0UGxhY2VtZW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGZsaXBwaW5nIHRoZSBgcGxhY2VtZW50YFxuICogaW4gb3JkZXIgdG8ga2VlcCBpdCBpbiB2aWV3IHdoZW4gdGhlIHByZWZlcnJlZCBwbGFjZW1lbnQocykgd2lsbCBvdmVyZmxvdyB0aGVcbiAqIGNsaXBwaW5nIGJvdW5kYXJ5LiBBbHRlcm5hdGl2ZSB0byBgYXV0b1BsYWNlbWVudGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZmxpcFxuICovXG5jb25zdCBmbGlwID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdmbGlwJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJGFycm93LCBfbWlkZGxld2FyZURhdGEkZmxpcDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBtaWRkbGV3YXJlRGF0YSxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIGluaXRpYWxQbGFjZW1lbnQsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSB0cnVlLFxuICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICAgICAgZmFsbGJhY2tTdHJhdGVneSA9ICdiZXN0Rml0JyxcbiAgICAgICAgZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiA9ICdub25lJyxcbiAgICAgICAgZmxpcEFsaWdubWVudCA9IHRydWUsXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcblxuICAgICAgLy8gSWYgYSByZXNldCBieSB0aGUgYXJyb3cgd2FzIGNhdXNlZCBkdWUgdG8gYW4gYWxpZ25tZW50IG9mZnNldCBiZWluZ1xuICAgICAgLy8gYWRkZWQsIHdlIHNob3VsZCBza2lwIGFueSBsb2dpYyBub3cgc2luY2UgYGZsaXAoKWAgaGFzIGFscmVhZHkgZG9uZSBpdHNcbiAgICAgIC8vIHdvcmsuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzI1NDkjaXNzdWVjb21tZW50LTE3MTk2MDE2NDNcbiAgICAgIGlmICgoX21pZGRsZXdhcmVEYXRhJGFycm93ID0gbWlkZGxld2FyZURhdGEuYXJyb3cpICE9IG51bGwgJiYgX21pZGRsZXdhcmVEYXRhJGFycm93LmFsaWdubWVudE9mZnNldCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgaXNCYXNlUGxhY2VtZW50ID0gZ2V0U2lkZShpbml0aWFsUGxhY2VtZW50KSA9PT0gaW5pdGlhbFBsYWNlbWVudDtcbiAgICAgIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwQWxpZ25tZW50ID8gW2dldE9wcG9zaXRlUGxhY2VtZW50KGluaXRpYWxQbGFjZW1lbnQpXSA6IGdldEV4cGFuZGVkUGxhY2VtZW50cyhpbml0aWFsUGxhY2VtZW50KSk7XG4gICAgICBpZiAoIXNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyAmJiBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uICE9PSAnbm9uZScpIHtcbiAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzLnB1c2goLi4uZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyhpbml0aWFsUGxhY2VtZW50LCBmbGlwQWxpZ25tZW50LCBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uLCBydGwpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBsYWNlbWVudHMgPSBbaW5pdGlhbFBsYWNlbWVudCwgLi4uZmFsbGJhY2tQbGFjZW1lbnRzXTtcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBvdmVyZmxvd3MgPSBbXTtcbiAgICAgIGxldCBvdmVyZmxvd3NEYXRhID0gKChfbWlkZGxld2FyZURhdGEkZmxpcCA9IG1pZGRsZXdhcmVEYXRhLmZsaXApID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkZmxpcC5vdmVyZmxvd3MpIHx8IFtdO1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgb3ZlcmZsb3dzLnB1c2gob3ZlcmZsb3dbc2lkZV0pO1xuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIGNvbnN0IHNpZGVzID0gZ2V0QWxpZ25tZW50U2lkZXMocGxhY2VtZW50LCByZWN0cywgcnRsKTtcbiAgICAgICAgb3ZlcmZsb3dzLnB1c2gob3ZlcmZsb3dbc2lkZXNbMF1dLCBvdmVyZmxvd1tzaWRlc1sxXV0pO1xuICAgICAgfVxuICAgICAgb3ZlcmZsb3dzRGF0YSA9IFsuLi5vdmVyZmxvd3NEYXRhLCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgb3ZlcmZsb3dzXG4gICAgICB9XTtcblxuICAgICAgLy8gT25lIG9yIG1vcmUgc2lkZXMgaXMgb3ZlcmZsb3dpbmcuXG4gICAgICBpZiAoIW92ZXJmbG93cy5ldmVyeShzaWRlID0+IHNpZGUgPD0gMCkpIHtcbiAgICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRmbGlwMiwgX292ZXJmbG93c0RhdGEkZmlsdGVyO1xuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSAoKChfbWlkZGxld2FyZURhdGEkZmxpcDIgPSBtaWRkbGV3YXJlRGF0YS5mbGlwKSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGZsaXAyLmluZGV4KSB8fCAwKSArIDE7XG4gICAgICAgIGNvbnN0IG5leHRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzW25leHRJbmRleF07XG4gICAgICAgIGlmIChuZXh0UGxhY2VtZW50KSB7XG4gICAgICAgICAgLy8gVHJ5IG5leHQgcGxhY2VtZW50IGFuZCByZS1ydW4gdGhlIGxpZmVjeWNsZS5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgICAgICAgICBvdmVyZmxvd3M6IG92ZXJmbG93c0RhdGFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgICBwbGFjZW1lbnQ6IG5leHRQbGFjZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyc3QsIGZpbmQgdGhlIGNhbmRpZGF0ZXMgdGhhdCBmaXQgb24gdGhlIG1haW5BeGlzIHNpZGUgb2Ygb3ZlcmZsb3csXG4gICAgICAgIC8vIHRoZW4gZmluZCB0aGUgcGxhY2VtZW50IHRoYXQgZml0cyB0aGUgYmVzdCBvbiB0aGUgbWFpbiBjcm9zc0F4aXMgc2lkZS5cbiAgICAgICAgbGV0IHJlc2V0UGxhY2VtZW50ID0gKF9vdmVyZmxvd3NEYXRhJGZpbHRlciA9IG92ZXJmbG93c0RhdGEuZmlsdGVyKGQgPT4gZC5vdmVyZmxvd3NbMF0gPD0gMCkuc29ydCgoYSwgYikgPT4gYS5vdmVyZmxvd3NbMV0gLSBiLm92ZXJmbG93c1sxXSlbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIucGxhY2VtZW50O1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSBmYWxsYmFjay5cbiAgICAgICAgaWYgKCFyZXNldFBsYWNlbWVudCkge1xuICAgICAgICAgIHN3aXRjaCAoZmFsbGJhY2tTdHJhdGVneSkge1xuICAgICAgICAgICAgY2FzZSAnYmVzdEZpdCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgX292ZXJmbG93c0RhdGEkbWFwJHNvO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlbWVudCA9IChfb3ZlcmZsb3dzRGF0YSRtYXAkc28gPSBvdmVyZmxvd3NEYXRhLm1hcChkID0+IFtkLnBsYWNlbWVudCwgZC5vdmVyZmxvd3MuZmlsdGVyKG92ZXJmbG93ID0+IG92ZXJmbG93ID4gMCkucmVkdWNlKChhY2MsIG92ZXJmbG93KSA9PiBhY2MgKyBvdmVyZmxvdywgMCldKS5zb3J0KChhLCBiKSA9PiBhWzFdIC0gYlsxXSlbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfb3ZlcmZsb3dzRGF0YSRtYXAkc29bMF07XG4gICAgICAgICAgICAgICAgaWYgKHBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgcmVzZXRQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdpbml0aWFsUGxhY2VtZW50JzpcbiAgICAgICAgICAgICAgcmVzZXRQbGFjZW1lbnQgPSBpbml0aWFsUGxhY2VtZW50O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsYWNlbWVudCAhPT0gcmVzZXRQbGFjZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgICAgcGxhY2VtZW50OiByZXNldFBsYWNlbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogb3ZlcmZsb3cudG9wIC0gcmVjdC5oZWlnaHQsXG4gICAgcmlnaHQ6IG92ZXJmbG93LnJpZ2h0IC0gcmVjdC53aWR0aCxcbiAgICBib3R0b206IG92ZXJmbG93LmJvdHRvbSAtIHJlY3QuaGVpZ2h0LFxuICAgIGxlZnQ6IG92ZXJmbG93LmxlZnQgLSByZWN0LndpZHRoXG4gIH07XG59XG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgcmV0dXJuIHNpZGVzLnNvbWUoc2lkZSA9PiBvdmVyZmxvd1tzaWRlXSA+PSAwKTtcbn1cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBoaWRlIHRoZSBmbG9hdGluZyBlbGVtZW50IGluIGFwcGxpY2FibGUgc2l0dWF0aW9ucywgc3VjaCBhc1xuICogd2hlbiBpdCBpcyBub3QgaW4gdGhlIHNhbWUgY2xpcHBpbmcgY29udGV4dCBhcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaGlkZVxuICovXG5jb25zdCBoaWRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdoaWRlJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlY3RzXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0cmF0ZWd5ID0gJ3JlZmVyZW5jZUhpZGRlbicsXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIHN3aXRjaCAoc3RyYXRlZ3kpIHtcbiAgICAgICAgY2FzZSAncmVmZXJlbmNlSGlkZGVuJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICAgICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9ucyxcbiAgICAgICAgICAgICAgZWxlbWVudENvbnRleHQ6ICdyZWZlcmVuY2UnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdHMucmVmZXJlbmNlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VIaWRkZW5PZmZzZXRzOiBvZmZzZXRzLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUhpZGRlbjogaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG9mZnNldHMpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdlc2NhcGVkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICAgICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9ucyxcbiAgICAgICAgICAgICAgYWx0Qm91bmRhcnk6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0cy5mbG9hdGluZyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZE9mZnNldHM6IG9mZnNldHMsXG4gICAgICAgICAgICAgICAgZXNjYXBlZDogaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG9mZnNldHMpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdSZWN0KHJlY3RzKSB7XG4gIGNvbnN0IG1pblggPSBtaW4oLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC5sZWZ0KSk7XG4gIGNvbnN0IG1pblkgPSBtaW4oLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC50b3ApKTtcbiAgY29uc3QgbWF4WCA9IG1heCguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LnJpZ2h0KSk7XG4gIGNvbnN0IG1heFkgPSBtYXgoLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC5ib3R0b20pKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBtaW5YLFxuICAgIHk6IG1pblksXG4gICAgd2lkdGg6IG1heFggLSBtaW5YLFxuICAgIGhlaWdodDogbWF4WSAtIG1pbllcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFJlY3RzQnlMaW5lKHJlY3RzKSB7XG4gIGNvbnN0IHNvcnRlZFJlY3RzID0gcmVjdHMuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhLnkgLSBiLnkpO1xuICBjb25zdCBncm91cHMgPSBbXTtcbiAgbGV0IHByZXZSZWN0ID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3J0ZWRSZWN0cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHJlY3QgPSBzb3J0ZWRSZWN0c1tpXTtcbiAgICBpZiAoIXByZXZSZWN0IHx8IHJlY3QueSAtIHByZXZSZWN0LnkgPiBwcmV2UmVjdC5oZWlnaHQgLyAyKSB7XG4gICAgICBncm91cHMucHVzaChbcmVjdF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cHNbZ3JvdXBzLmxlbmd0aCAtIDFdLnB1c2gocmVjdCk7XG4gICAgfVxuICAgIHByZXZSZWN0ID0gcmVjdDtcbiAgfVxuICByZXR1cm4gZ3JvdXBzLm1hcChyZWN0ID0+IHJlY3RUb0NsaWVudFJlY3QoZ2V0Qm91bmRpbmdSZWN0KHJlY3QpKSk7XG59XG4vKipcbiAqIFByb3ZpZGVzIGltcHJvdmVkIHBvc2l0aW9uaW5nIGZvciBpbmxpbmUgcmVmZXJlbmNlIGVsZW1lbnRzIHRoYXQgY2FuIHNwYW5cbiAqIG92ZXIgbXVsdGlwbGUgbGluZXMsIHN1Y2ggYXMgaHlwZXJsaW5rcyBvciByYW5nZSBzZWxlY3Rpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubGluZVxuICovXG5jb25zdCBpbmxpbmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2lubGluZScsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIGVsZW1lbnRzLFxuICAgICAgICByZWN0cyxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9ID0gc3RhdGU7XG4gICAgICAvLyBBIE1vdXNlRXZlbnQncyBjbGllbnR7WCxZfSBjb29yZHMgY2FuIGJlIHVwIHRvIDIgcGl4ZWxzIG9mZiBhXG4gICAgICAvLyBDbGllbnRSZWN0J3MgYm91bmRzLCBkZXNwaXRlIHRoZSBldmVudCBsaXN0ZW5lciBiZWluZyB0cmlnZ2VyZWQuIEFcbiAgICAgIC8vIHBhZGRpbmcgb2YgMiBzZWVtcyB0byBoYW5kbGUgdGhpcyBpc3N1ZS5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFkZGluZyA9IDIsXG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBuYXRpdmVDbGllbnRSZWN0cyA9IEFycmF5LmZyb20oKGF3YWl0IChwbGF0Zm9ybS5nZXRDbGllbnRSZWN0cyA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0Q2xpZW50UmVjdHMoZWxlbWVudHMucmVmZXJlbmNlKSkpIHx8IFtdKTtcbiAgICAgIGNvbnN0IGNsaWVudFJlY3RzID0gZ2V0UmVjdHNCeUxpbmUobmF0aXZlQ2xpZW50UmVjdHMpO1xuICAgICAgY29uc3QgZmFsbGJhY2sgPSByZWN0VG9DbGllbnRSZWN0KGdldEJvdW5kaW5nUmVjdChuYXRpdmVDbGllbnRSZWN0cykpO1xuICAgICAgY29uc3QgcGFkZGluZ09iamVjdCA9IGdldFBhZGRpbmdPYmplY3QocGFkZGluZyk7XG4gICAgICBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSB0d28gcmVjdHMgYW5kIHRoZXkgYXJlIGRpc2pvaW5lZC5cbiAgICAgICAgaWYgKGNsaWVudFJlY3RzLmxlbmd0aCA9PT0gMiAmJiBjbGllbnRSZWN0c1swXS5sZWZ0ID4gY2xpZW50UmVjdHNbMV0ucmlnaHQgJiYgeCAhPSBudWxsICYmIHkgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IHJlY3QgaW4gd2hpY2ggdGhlIHBvaW50IGlzIGZ1bGx5IGluc2lkZS5cbiAgICAgICAgICByZXR1cm4gY2xpZW50UmVjdHMuZmluZChyZWN0ID0+IHggPiByZWN0LmxlZnQgLSBwYWRkaW5nT2JqZWN0LmxlZnQgJiYgeCA8IHJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0ICYmIHkgPiByZWN0LnRvcCAtIHBhZGRpbmdPYmplY3QudG9wICYmIHkgPCByZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tKSB8fCBmYWxsYmFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZXJlIGFyZSAyIG9yIG1vcmUgY29ubmVjdGVkIHJlY3RzLlxuICAgICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICBpZiAoZ2V0U2lkZUF4aXMocGxhY2VtZW50KSA9PT0gJ3knKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFJlY3QgPSBjbGllbnRSZWN0c1swXTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RSZWN0ID0gY2xpZW50UmVjdHNbY2xpZW50UmVjdHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBpc1RvcCA9IGdldFNpZGUocGxhY2VtZW50KSA9PT0gJ3RvcCc7XG4gICAgICAgICAgICBjb25zdCB0b3AgPSBmaXJzdFJlY3QudG9wO1xuICAgICAgICAgICAgY29uc3QgYm90dG9tID0gbGFzdFJlY3QuYm90dG9tO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IGlzVG9wID8gZmlyc3RSZWN0LmxlZnQgOiBsYXN0UmVjdC5sZWZ0O1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBpc1RvcCA/IGZpcnN0UmVjdC5yaWdodCA6IGxhc3RSZWN0LnJpZ2h0O1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgICAgIHk6IHRvcFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaXNMZWZ0U2lkZSA9IGdldFNpZGUocGxhY2VtZW50KSA9PT0gJ2xlZnQnO1xuICAgICAgICAgIGNvbnN0IG1heFJpZ2h0ID0gbWF4KC4uLmNsaWVudFJlY3RzLm1hcChyZWN0ID0+IHJlY3QucmlnaHQpKTtcbiAgICAgICAgICBjb25zdCBtaW5MZWZ0ID0gbWluKC4uLmNsaWVudFJlY3RzLm1hcChyZWN0ID0+IHJlY3QubGVmdCkpO1xuICAgICAgICAgIGNvbnN0IG1lYXN1cmVSZWN0cyA9IGNsaWVudFJlY3RzLmZpbHRlcihyZWN0ID0+IGlzTGVmdFNpZGUgPyByZWN0LmxlZnQgPT09IG1pbkxlZnQgOiByZWN0LnJpZ2h0ID09PSBtYXhSaWdodCk7XG4gICAgICAgICAgY29uc3QgdG9wID0gbWVhc3VyZVJlY3RzWzBdLnRvcDtcbiAgICAgICAgICBjb25zdCBib3R0b20gPSBtZWFzdXJlUmVjdHNbbWVhc3VyZVJlY3RzLmxlbmd0aCAtIDFdLmJvdHRvbTtcbiAgICAgICAgICBjb25zdCBsZWZ0ID0gbWluTGVmdDtcbiAgICAgICAgICBjb25zdCByaWdodCA9IG1heFJpZ2h0O1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICB4OiBsZWZ0LFxuICAgICAgICAgICAgeTogdG9wXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNldFJlY3RzID0gYXdhaXQgcGxhdGZvcm0uZ2V0RWxlbWVudFJlY3RzKHtcbiAgICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gICAgICAgIH0sXG4gICAgICAgIGZsb2F0aW5nOiBlbGVtZW50cy5mbG9hdGluZyxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlY3RzLnJlZmVyZW5jZS54ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS54IHx8IHJlY3RzLnJlZmVyZW5jZS55ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS55IHx8IHJlY3RzLnJlZmVyZW5jZS53aWR0aCAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2Uud2lkdGggfHwgcmVjdHMucmVmZXJlbmNlLmhlaWdodCAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2UuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHJlY3RzOiByZXNldFJlY3RzXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIEZvciB0eXBlIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCB0aGUgYE9mZnNldE9wdGlvbnNgIHR5cGUgd2FzIGFsc29cbi8vIERlcml2YWJsZS5cblxuYXN5bmMgZnVuY3Rpb24gY29udmVydFZhbHVlVG9Db29yZHMoc3RhdGUsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCxcbiAgICBwbGF0Zm9ybSxcbiAgICBlbGVtZW50c1xuICB9ID0gc3RhdGU7XG4gIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGNvbnN0IGlzVmVydGljYWwgPSBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneSc7XG4gIGNvbnN0IG1haW5BeGlzTXVsdGkgPSBbJ2xlZnQnLCAndG9wJ10uaW5jbHVkZXMoc2lkZSkgPyAtMSA6IDE7XG4gIGNvbnN0IGNyb3NzQXhpc011bHRpID0gcnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDE7XG4gIGNvbnN0IHJhd1ZhbHVlID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICBsZXQge1xuICAgIG1haW5BeGlzLFxuICAgIGNyb3NzQXhpcyxcbiAgICBhbGlnbm1lbnRBeGlzXG4gIH0gPSB0eXBlb2YgcmF3VmFsdWUgPT09ICdudW1iZXInID8ge1xuICAgIG1haW5BeGlzOiByYXdWYWx1ZSxcbiAgICBjcm9zc0F4aXM6IDAsXG4gICAgYWxpZ25tZW50QXhpczogbnVsbFxuICB9IDoge1xuICAgIG1haW5BeGlzOiAwLFxuICAgIGNyb3NzQXhpczogMCxcbiAgICBhbGlnbm1lbnRBeGlzOiBudWxsLFxuICAgIC4uLnJhd1ZhbHVlXG4gIH07XG4gIGlmIChhbGlnbm1lbnQgJiYgdHlwZW9mIGFsaWdubWVudEF4aXMgPT09ICdudW1iZXInKSB7XG4gICAgY3Jvc3NBeGlzID0gYWxpZ25tZW50ID09PSAnZW5kJyA/IGFsaWdubWVudEF4aXMgKiAtMSA6IGFsaWdubWVudEF4aXM7XG4gIH1cbiAgcmV0dXJuIGlzVmVydGljYWwgPyB7XG4gICAgeDogY3Jvc3NBeGlzICogY3Jvc3NBeGlzTXVsdGksXG4gICAgeTogbWFpbkF4aXMgKiBtYWluQXhpc011bHRpXG4gIH0gOiB7XG4gICAgeDogbWFpbkF4aXMgKiBtYWluQXhpc011bHRpLFxuICAgIHk6IGNyb3NzQXhpcyAqIGNyb3NzQXhpc011bHRpXG4gIH07XG59XG5cbi8qKlxuICogTW9kaWZpZXMgdGhlIHBsYWNlbWVudCBieSB0cmFuc2xhdGluZyB0aGUgZmxvYXRpbmcgZWxlbWVudCBhbG9uZyB0aGVcbiAqIHNwZWNpZmllZCBheGVzLlxuICogQSBudW1iZXIgKHNob3J0aGFuZCBmb3IgYG1haW5BeGlzYCBvciBkaXN0YW5jZSksIG9yIGFuIGF4ZXMgY29uZmlndXJhdGlvblxuICogb2JqZWN0IG1heSBiZSBwYXNzZWQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvb2Zmc2V0XG4gKi9cbmNvbnN0IG9mZnNldCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0gMDtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkb2Zmc2UsIF9taWRkbGV3YXJlRGF0YSRhcnJvdztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBtaWRkbGV3YXJlRGF0YVxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3QgZGlmZkNvb3JkcyA9IGF3YWl0IGNvbnZlcnRWYWx1ZVRvQ29vcmRzKHN0YXRlLCBvcHRpb25zKTtcblxuICAgICAgLy8gSWYgdGhlIHBsYWNlbWVudCBpcyB0aGUgc2FtZSBhbmQgdGhlIGFycm93IGNhdXNlZCBhbiBhbGlnbm1lbnQgb2Zmc2V0XG4gICAgICAvLyB0aGVuIHdlIGRvbid0IG5lZWQgdG8gY2hhbmdlIHRoZSBwb3NpdGlvbmluZyBjb29yZGluYXRlcy5cbiAgICAgIGlmIChwbGFjZW1lbnQgPT09ICgoX21pZGRsZXdhcmVEYXRhJG9mZnNlID0gbWlkZGxld2FyZURhdGEub2Zmc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJG9mZnNlLnBsYWNlbWVudCkgJiYgKF9taWRkbGV3YXJlRGF0YSRhcnJvdyA9IG1pZGRsZXdhcmVEYXRhLmFycm93KSAhPSBudWxsICYmIF9taWRkbGV3YXJlRGF0YSRhcnJvdy5hbGlnbm1lbnRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCArIGRpZmZDb29yZHMueCxcbiAgICAgICAgeTogeSArIGRpZmZDb29yZHMueSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIC4uLmRpZmZDb29yZHMsXG4gICAgICAgICAgcGxhY2VtZW50XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgc2hpZnRpbmcgaXQgaW4gb3JkZXIgdG9cbiAqIGtlZXAgaXQgaW4gdmlldyB3aGVuIGl0IHdpbGwgb3ZlcmZsb3cgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NoaWZ0XG4gKi9cbmNvbnN0IHNoaWZ0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdzaGlmdCcsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBwbGFjZW1lbnRcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gZmFsc2UsXG4gICAgICAgIGxpbWl0ZXIgPSB7XG4gICAgICAgICAgZm46IF9yZWYgPT4ge1xuICAgICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgfSA9IF9yZWY7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICB5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3QgY29vcmRzID0ge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9O1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IGNyb3NzQXhpcyA9IGdldFNpZGVBeGlzKGdldFNpZGUocGxhY2VtZW50KSk7XG4gICAgICBjb25zdCBtYWluQXhpcyA9IGdldE9wcG9zaXRlQXhpcyhjcm9zc0F4aXMpO1xuICAgICAgbGV0IG1haW5BeGlzQ29vcmQgPSBjb29yZHNbbWFpbkF4aXNdO1xuICAgICAgbGV0IGNyb3NzQXhpc0Nvb3JkID0gY29vcmRzW2Nyb3NzQXhpc107XG4gICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgICBjb25zdCBtaW5TaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/ICd0b3AnIDogJ2xlZnQnO1xuICAgICAgICBjb25zdCBtYXhTaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgICAgICAgY29uc3QgbWluID0gbWFpbkF4aXNDb29yZCArIG92ZXJmbG93W21pblNpZGVdO1xuICAgICAgICBjb25zdCBtYXggPSBtYWluQXhpc0Nvb3JkIC0gb3ZlcmZsb3dbbWF4U2lkZV07XG4gICAgICAgIG1haW5BeGlzQ29vcmQgPSBjbGFtcChtaW4sIG1haW5BeGlzQ29vcmQsIG1heCk7XG4gICAgICB9XG4gICAgICBpZiAoY2hlY2tDcm9zc0F4aXMpIHtcbiAgICAgICAgY29uc3QgbWluU2lkZSA9IGNyb3NzQXhpcyA9PT0gJ3knID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgICAgIGNvbnN0IG1heFNpZGUgPSBjcm9zc0F4aXMgPT09ICd5JyA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgICAgICAgY29uc3QgbWluID0gY3Jvc3NBeGlzQ29vcmQgKyBvdmVyZmxvd1ttaW5TaWRlXTtcbiAgICAgICAgY29uc3QgbWF4ID0gY3Jvc3NBeGlzQ29vcmQgLSBvdmVyZmxvd1ttYXhTaWRlXTtcbiAgICAgICAgY3Jvc3NBeGlzQ29vcmQgPSBjbGFtcChtaW4sIGNyb3NzQXhpc0Nvb3JkLCBtYXgpO1xuICAgICAgfVxuICAgICAgY29uc3QgbGltaXRlZENvb3JkcyA9IGxpbWl0ZXIuZm4oe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgW21haW5BeGlzXTogbWFpbkF4aXNDb29yZCxcbiAgICAgICAgW2Nyb3NzQXhpc106IGNyb3NzQXhpc0Nvb3JkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmxpbWl0ZWRDb29yZHMsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICB4OiBsaW1pdGVkQ29vcmRzLnggLSB4LFxuICAgICAgICAgIHk6IGxpbWl0ZWRDb29yZHMueSAtIHlcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuLyoqXG4gKiBCdWlsdC1pbiBgbGltaXRlcmAgdGhhdCB3aWxsIHN0b3AgYHNoaWZ0KClgIGF0IGEgY2VydGFpbiBwb2ludC5cbiAqL1xuY29uc3QgbGltaXRTaGlmdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBvcHRpb25zLFxuICAgIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9mZnNldCA9IDAsXG4gICAgICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICAgICAgY3Jvc3NBeGlzOiBjaGVja0Nyb3NzQXhpcyA9IHRydWVcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBjb29yZHMgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH07XG4gICAgICBjb25zdCBjcm9zc0F4aXMgPSBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgbWFpbkF4aXMgPSBnZXRPcHBvc2l0ZUF4aXMoY3Jvc3NBeGlzKTtcbiAgICAgIGxldCBtYWluQXhpc0Nvb3JkID0gY29vcmRzW21haW5BeGlzXTtcbiAgICAgIGxldCBjcm9zc0F4aXNDb29yZCA9IGNvb3Jkc1tjcm9zc0F4aXNdO1xuICAgICAgY29uc3QgcmF3T2Zmc2V0ID0gZXZhbHVhdGUob2Zmc2V0LCBzdGF0ZSk7XG4gICAgICBjb25zdCBjb21wdXRlZE9mZnNldCA9IHR5cGVvZiByYXdPZmZzZXQgPT09ICdudW1iZXInID8ge1xuICAgICAgICBtYWluQXhpczogcmF3T2Zmc2V0LFxuICAgICAgICBjcm9zc0F4aXM6IDBcbiAgICAgIH0gOiB7XG4gICAgICAgIG1haW5BeGlzOiAwLFxuICAgICAgICBjcm9zc0F4aXM6IDAsXG4gICAgICAgIC4uLnJhd09mZnNldFxuICAgICAgfTtcbiAgICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgICAgIGNvbnN0IGxpbWl0TWluID0gcmVjdHMucmVmZXJlbmNlW21haW5BeGlzXSAtIHJlY3RzLmZsb2F0aW5nW2xlbl0gKyBjb21wdXRlZE9mZnNldC5tYWluQXhpcztcbiAgICAgICAgY29uc3QgbGltaXRNYXggPSByZWN0cy5yZWZlcmVuY2VbbWFpbkF4aXNdICsgcmVjdHMucmVmZXJlbmNlW2xlbl0gLSBjb21wdXRlZE9mZnNldC5tYWluQXhpcztcbiAgICAgICAgaWYgKG1haW5BeGlzQ29vcmQgPCBsaW1pdE1pbikge1xuICAgICAgICAgIG1haW5BeGlzQ29vcmQgPSBsaW1pdE1pbjtcbiAgICAgICAgfSBlbHNlIGlmIChtYWluQXhpc0Nvb3JkID4gbGltaXRNYXgpIHtcbiAgICAgICAgICBtYWluQXhpc0Nvb3JkID0gbGltaXRNYXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJG9mZnNlLCBfbWlkZGxld2FyZURhdGEkb2Zmc2UyO1xuICAgICAgICBjb25zdCBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgICAgICBjb25zdCBpc09yaWdpblNpZGUgPSBbJ3RvcCcsICdsZWZ0J10uaW5jbHVkZXMoZ2V0U2lkZShwbGFjZW1lbnQpKTtcbiAgICAgICAgY29uc3QgbGltaXRNaW4gPSByZWN0cy5yZWZlcmVuY2VbY3Jvc3NBeGlzXSAtIHJlY3RzLmZsb2F0aW5nW2xlbl0gKyAoaXNPcmlnaW5TaWRlID8gKChfbWlkZGxld2FyZURhdGEkb2Zmc2UgPSBtaWRkbGV3YXJlRGF0YS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkb2Zmc2VbY3Jvc3NBeGlzXSkgfHwgMCA6IDApICsgKGlzT3JpZ2luU2lkZSA/IDAgOiBjb21wdXRlZE9mZnNldC5jcm9zc0F4aXMpO1xuICAgICAgICBjb25zdCBsaW1pdE1heCA9IHJlY3RzLnJlZmVyZW5jZVtjcm9zc0F4aXNdICsgcmVjdHMucmVmZXJlbmNlW2xlbl0gKyAoaXNPcmlnaW5TaWRlID8gMCA6ICgoX21pZGRsZXdhcmVEYXRhJG9mZnNlMiA9IG1pZGRsZXdhcmVEYXRhLm9mZnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRvZmZzZTJbY3Jvc3NBeGlzXSkgfHwgMCkgLSAoaXNPcmlnaW5TaWRlID8gY29tcHV0ZWRPZmZzZXQuY3Jvc3NBeGlzIDogMCk7XG4gICAgICAgIGlmIChjcm9zc0F4aXNDb29yZCA8IGxpbWl0TWluKSB7XG4gICAgICAgICAgY3Jvc3NBeGlzQ29vcmQgPSBsaW1pdE1pbjtcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0F4aXNDb29yZCA+IGxpbWl0TWF4KSB7XG4gICAgICAgICAgY3Jvc3NBeGlzQ29vcmQgPSBsaW1pdE1heDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW21haW5BeGlzXTogbWFpbkF4aXNDb29yZCxcbiAgICAgICAgW2Nyb3NzQXhpc106IGNyb3NzQXhpc0Nvb3JkXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0aGF0IGFsbG93cyB5b3UgdG8gY2hhbmdlIHRoZSBzaXplIG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IOKAlFxuICogZm9yIGluc3RhbmNlLCBwcmV2ZW50IGl0IGZyb20gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5IG9yIG1hdGNoIHRoZVxuICogd2lkdGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NpemVcbiAqL1xuY29uc3Qgc2l6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnc2l6ZScsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXBwbHkgPSAoKSA9PiB7fSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGlzWUF4aXMgPSBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneSc7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSByZWN0cy5mbG9hdGluZztcbiAgICAgIGxldCBoZWlnaHRTaWRlO1xuICAgICAgbGV0IHdpZHRoU2lkZTtcbiAgICAgIGlmIChzaWRlID09PSAndG9wJyB8fCBzaWRlID09PSAnYm90dG9tJykge1xuICAgICAgICBoZWlnaHRTaWRlID0gc2lkZTtcbiAgICAgICAgd2lkdGhTaWRlID0gYWxpZ25tZW50ID09PSAoKGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKSkgPyAnc3RhcnQnIDogJ2VuZCcpID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoU2lkZSA9IHNpZGU7XG4gICAgICAgIGhlaWdodFNpZGUgPSBhbGlnbm1lbnQgPT09ICdlbmQnID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG92ZXJmbG93QXZhaWxhYmxlSGVpZ2h0ID0gaGVpZ2h0IC0gb3ZlcmZsb3dbaGVpZ2h0U2lkZV07XG4gICAgICBjb25zdCBvdmVyZmxvd0F2YWlsYWJsZVdpZHRoID0gd2lkdGggLSBvdmVyZmxvd1t3aWR0aFNpZGVdO1xuICAgICAgY29uc3Qgbm9TaGlmdCA9ICFzdGF0ZS5taWRkbGV3YXJlRGF0YS5zaGlmdDtcbiAgICAgIGxldCBhdmFpbGFibGVIZWlnaHQgPSBvdmVyZmxvd0F2YWlsYWJsZUhlaWdodDtcbiAgICAgIGxldCBhdmFpbGFibGVXaWR0aCA9IG92ZXJmbG93QXZhaWxhYmxlV2lkdGg7XG4gICAgICBpZiAoaXNZQXhpcykge1xuICAgICAgICBjb25zdCBtYXhpbXVtQ2xpcHBpbmdXaWR0aCA9IHdpZHRoIC0gb3ZlcmZsb3cubGVmdCAtIG92ZXJmbG93LnJpZ2h0O1xuICAgICAgICBhdmFpbGFibGVXaWR0aCA9IGFsaWdubWVudCB8fCBub1NoaWZ0ID8gbWluKG92ZXJmbG93QXZhaWxhYmxlV2lkdGgsIG1heGltdW1DbGlwcGluZ1dpZHRoKSA6IG1heGltdW1DbGlwcGluZ1dpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF4aW11bUNsaXBwaW5nSGVpZ2h0ID0gaGVpZ2h0IC0gb3ZlcmZsb3cudG9wIC0gb3ZlcmZsb3cuYm90dG9tO1xuICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBhbGlnbm1lbnQgfHwgbm9TaGlmdCA/IG1pbihvdmVyZmxvd0F2YWlsYWJsZUhlaWdodCwgbWF4aW11bUNsaXBwaW5nSGVpZ2h0KSA6IG1heGltdW1DbGlwcGluZ0hlaWdodDtcbiAgICAgIH1cbiAgICAgIGlmIChub1NoaWZ0ICYmICFhbGlnbm1lbnQpIHtcbiAgICAgICAgY29uc3QgeE1pbiA9IG1heChvdmVyZmxvdy5sZWZ0LCAwKTtcbiAgICAgICAgY29uc3QgeE1heCA9IG1heChvdmVyZmxvdy5yaWdodCwgMCk7XG4gICAgICAgIGNvbnN0IHlNaW4gPSBtYXgob3ZlcmZsb3cudG9wLCAwKTtcbiAgICAgICAgY29uc3QgeU1heCA9IG1heChvdmVyZmxvdy5ib3R0b20sIDApO1xuICAgICAgICBpZiAoaXNZQXhpcykge1xuICAgICAgICAgIGF2YWlsYWJsZVdpZHRoID0gd2lkdGggLSAyICogKHhNaW4gIT09IDAgfHwgeE1heCAhPT0gMCA/IHhNaW4gKyB4TWF4IDogbWF4KG92ZXJmbG93LmxlZnQsIG92ZXJmbG93LnJpZ2h0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gaGVpZ2h0IC0gMiAqICh5TWluICE9PSAwIHx8IHlNYXggIT09IDAgPyB5TWluICsgeU1heCA6IG1heChvdmVyZmxvdy50b3AsIG92ZXJmbG93LmJvdHRvbSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhd2FpdCBhcHBseSh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBhdmFpbGFibGVXaWR0aCxcbiAgICAgICAgYXZhaWxhYmxlSGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG5leHREaW1lbnNpb25zID0gYXdhaXQgcGxhdGZvcm0uZ2V0RGltZW5zaW9ucyhlbGVtZW50cy5mbG9hdGluZyk7XG4gICAgICBpZiAod2lkdGggIT09IG5leHREaW1lbnNpb25zLndpZHRoIHx8IGhlaWdodCAhPT0gbmV4dERpbWVuc2lvbnMuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHJlY3RzOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbmV4cG9ydCB7IGFycm93LCBhdXRvUGxhY2VtZW50LCBjb21wdXRlUG9zaXRpb24sIGRldGVjdE92ZXJmbG93LCBmbGlwLCBoaWRlLCBpbmxpbmUsIGxpbWl0U2hpZnQsIG9mZnNldCwgc2hpZnQsIHNpemUgfTtcbiJdLCJuYW1lcyI6WyJnZXRTaWRlQXhpcyIsImdldEFsaWdubWVudEF4aXMiLCJnZXRBeGlzTGVuZ3RoIiwiZ2V0U2lkZSIsImdldEFsaWdubWVudCIsImV2YWx1YXRlIiwiZ2V0UGFkZGluZ09iamVjdCIsInJlY3RUb0NsaWVudFJlY3QiLCJtaW4iLCJjbGFtcCIsInBsYWNlbWVudHMiLCJnZXRBbGlnbm1lbnRTaWRlcyIsImdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50IiwiZ2V0T3Bwb3NpdGVQbGFjZW1lbnQiLCJnZXRFeHBhbmRlZFBsYWNlbWVudHMiLCJnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzIiwic2lkZXMiLCJtYXgiLCJnZXRPcHBvc2l0ZUF4aXMiLCJjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudCIsIl9yZWYiLCJwbGFjZW1lbnQiLCJydGwiLCJyZWZlcmVuY2UiLCJmbG9hdGluZyIsInNpZGVBeGlzIiwiYWxpZ25tZW50QXhpcyIsImFsaWduTGVuZ3RoIiwic2lkZSIsImlzVmVydGljYWwiLCJjb21tb25YIiwieCIsIndpZHRoIiwiY29tbW9uWSIsInkiLCJoZWlnaHQiLCJjb21tb25BbGlnbiIsImNvb3JkcyIsImNvbXB1dGVQb3NpdGlvbiIsImNvbmZpZyIsInN0cmF0ZWd5IiwibWlkZGxld2FyZSIsInBsYXRmb3JtIiwidmFsaWRNaWRkbGV3YXJlIiwiZmlsdGVyIiwiQm9vbGVhbiIsImlzUlRMIiwicmVjdHMiLCJnZXRFbGVtZW50UmVjdHMiLCJzdGF0ZWZ1bFBsYWNlbWVudCIsIm1pZGRsZXdhcmVEYXRhIiwicmVzZXRDb3VudCIsImkiLCJsZW5ndGgiLCJuYW1lIiwiZm4iLCJuZXh0WCIsIm5leHRZIiwiZGF0YSIsInJlc2V0IiwiaW5pdGlhbFBsYWNlbWVudCIsImVsZW1lbnRzIiwiX29iamVjdFNwcmVhZCIsImRldGVjdE92ZXJmbG93Iiwic3RhdGUiLCJvcHRpb25zIiwiX2F3YWl0JHBsYXRmb3JtJGlzRWxlIiwiYm91bmRhcnkiLCJyb290Qm91bmRhcnkiLCJlbGVtZW50Q29udGV4dCIsImFsdEJvdW5kYXJ5IiwicGFkZGluZyIsInBhZGRpbmdPYmplY3QiLCJhbHRDb250ZXh0IiwiZWxlbWVudCIsImNsaXBwaW5nQ2xpZW50UmVjdCIsImdldENsaXBwaW5nUmVjdCIsImlzRWxlbWVudCIsImNvbnRleHRFbGVtZW50IiwiZ2V0RG9jdW1lbnRFbGVtZW50IiwicmVjdCIsIm9mZnNldFBhcmVudCIsImdldE9mZnNldFBhcmVudCIsIm9mZnNldFNjYWxlIiwiZ2V0U2NhbGUiLCJlbGVtZW50Q2xpZW50UmVjdCIsImNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0IiwidG9wIiwiYm90dG9tIiwibGVmdCIsInJpZ2h0IiwiYXJyb3ciLCJheGlzIiwiYXJyb3dEaW1lbnNpb25zIiwiZ2V0RGltZW5zaW9ucyIsImlzWUF4aXMiLCJtaW5Qcm9wIiwibWF4UHJvcCIsImNsaWVudFByb3AiLCJlbmREaWZmIiwic3RhcnREaWZmIiwiYXJyb3dPZmZzZXRQYXJlbnQiLCJjbGllbnRTaXplIiwiY2VudGVyVG9SZWZlcmVuY2UiLCJsYXJnZXN0UG9zc2libGVQYWRkaW5nIiwibWluUGFkZGluZyIsIm1heFBhZGRpbmciLCJtaW4kMSIsImNlbnRlciIsIm9mZnNldCIsInNob3VsZEFkZE9mZnNldCIsImFsaWdubWVudE9mZnNldCIsImNlbnRlck9mZnNldCIsImdldFBsYWNlbWVudExpc3QiLCJhbGlnbm1lbnQiLCJhdXRvQWxpZ25tZW50IiwiYWxsb3dlZFBsYWNlbWVudHMiLCJhbGxvd2VkUGxhY2VtZW50c1NvcnRlZEJ5QWxpZ25tZW50IiwiYXV0b1BsYWNlbWVudCIsIl9taWRkbGV3YXJlRGF0YSRhdXRvUCIsIl9taWRkbGV3YXJlRGF0YSRhdXRvUDIiLCJfcGxhY2VtZW50c1RoYXRGaXRPbkUiLCJfZXZhbHVhdGUiLCJjcm9zc0F4aXMiLCJkZXRlY3RPdmVyZmxvd09wdGlvbnMiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJfZXhjbHVkZWQiLCJwbGFjZW1lbnRzJDEiLCJ1bmRlZmluZWQiLCJvdmVyZmxvdyIsImN1cnJlbnRJbmRleCIsImluZGV4IiwiY3VycmVudFBsYWNlbWVudCIsImFsaWdubWVudFNpZGVzIiwiY3VycmVudE92ZXJmbG93cyIsImFsbE92ZXJmbG93cyIsIm92ZXJmbG93cyIsIm5leHRQbGFjZW1lbnQiLCJwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2UiLCJtYXAiLCJkIiwic2xpY2UiLCJyZWR1Y2UiLCJhY2MiLCJ2Iiwic29ydCIsImEiLCJiIiwicGxhY2VtZW50c1RoYXRGaXRPbkVhY2hTaWRlIiwiZXZlcnkiLCJyZXNldFBsYWNlbWVudCIsImZsaXAiLCJfbWlkZGxld2FyZURhdGEkYXJyb3ciLCJfbWlkZGxld2FyZURhdGEkZmxpcCIsIl9ldmFsdWF0ZTIiLCJtYWluQXhpcyIsImNoZWNrTWFpbkF4aXMiLCJjaGVja0Nyb3NzQXhpcyIsImZhbGxiYWNrUGxhY2VtZW50cyIsInNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyIsImZhbGxiYWNrU3RyYXRlZ3kiLCJmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uIiwiZmxpcEFsaWdubWVudCIsIl9leGNsdWRlZDIiLCJpc0Jhc2VQbGFjZW1lbnQiLCJwdXNoIiwib3ZlcmZsb3dzRGF0YSIsIl9taWRkbGV3YXJlRGF0YSRmbGlwMiIsIl9vdmVyZmxvd3NEYXRhJGZpbHRlciIsIm5leHRJbmRleCIsIl9vdmVyZmxvd3NEYXRhJG1hcCRzbyIsImdldFNpZGVPZmZzZXRzIiwiaXNBbnlTaWRlRnVsbHlDbGlwcGVkIiwic29tZSIsImhpZGUiLCJfZXZhbHVhdGUzIiwiX2V4Y2x1ZGVkMyIsIm9mZnNldHMiLCJyZWZlcmVuY2VIaWRkZW5PZmZzZXRzIiwicmVmZXJlbmNlSGlkZGVuIiwiZXNjYXBlZE9mZnNldHMiLCJlc2NhcGVkIiwiZ2V0Qm91bmRpbmdSZWN0IiwibWluWCIsIm1pblkiLCJtYXhYIiwibWF4WSIsImdldFJlY3RzQnlMaW5lIiwic29ydGVkUmVjdHMiLCJncm91cHMiLCJwcmV2UmVjdCIsImlubGluZSIsIm5hdGl2ZUNsaWVudFJlY3RzIiwiQXJyYXkiLCJmcm9tIiwiZ2V0Q2xpZW50UmVjdHMiLCJjbGllbnRSZWN0cyIsImZhbGxiYWNrIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZmluZCIsImZpcnN0UmVjdCIsImxhc3RSZWN0IiwiaXNUb3AiLCJpc0xlZnRTaWRlIiwibWF4UmlnaHQiLCJtaW5MZWZ0IiwibWVhc3VyZVJlY3RzIiwicmVzZXRSZWN0cyIsImNvbnZlcnRWYWx1ZVRvQ29vcmRzIiwibWFpbkF4aXNNdWx0aSIsImluY2x1ZGVzIiwiY3Jvc3NBeGlzTXVsdGkiLCJyYXdWYWx1ZSIsIl9taWRkbGV3YXJlRGF0YSRvZmZzZSIsImRpZmZDb29yZHMiLCJzaGlmdCIsIl9ldmFsdWF0ZTQiLCJsaW1pdGVyIiwiX2V4Y2x1ZGVkNCIsIm1haW5BeGlzQ29vcmQiLCJjcm9zc0F4aXNDb29yZCIsIm1pblNpZGUiLCJtYXhTaWRlIiwibGltaXRlZENvb3JkcyIsImxpbWl0U2hpZnQiLCJyYXdPZmZzZXQiLCJjb21wdXRlZE9mZnNldCIsImxlbiIsImxpbWl0TWluIiwibGltaXRNYXgiLCJfbWlkZGxld2FyZURhdGEkb2Zmc2UyIiwiaXNPcmlnaW5TaWRlIiwic2l6ZSIsIl9ldmFsdWF0ZTUiLCJhcHBseSIsIl9leGNsdWRlZDUiLCJoZWlnaHRTaWRlIiwid2lkdGhTaWRlIiwib3ZlcmZsb3dBdmFpbGFibGVIZWlnaHQiLCJvdmVyZmxvd0F2YWlsYWJsZVdpZHRoIiwibm9TaGlmdCIsImF2YWlsYWJsZUhlaWdodCIsImF2YWlsYWJsZVdpZHRoIiwibWF4aW11bUNsaXBwaW5nV2lkdGgiLCJtYXhpbXVtQ2xpcHBpbmdIZWlnaHQiLCJ4TWluIiwieE1heCIsInlNaW4iLCJ5TWF4IiwibmV4dERpbWVuc2lvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   autoUpdate: () => (/* binding */ autoUpdate),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.offset),\n/* harmony export */   platform: () => (/* binding */ platform),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/core */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\n\n\nfunction getCssDimensions(element) {\n  const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(width) !== offsetWidth || (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\nfunction unwrapElement(element) {\n  return !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(element) ? element.contextElement : element;\n}\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(domElement)) {\n    return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(rect.width) : rect.width) / width;\n  let y = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\nconst noOffsets = /*#__PURE__*/(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);\nfunction getVisualOffsets(element) {\n  const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element);\n  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isWebKit)() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element)) {\n    return false;\n  }\n  return isFixed;\n}\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(domElement);\n    const offsetWin = offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(offsetParent) ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = currentWin.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(currentIFrame);\n      currentIFrame = currentWin.frameElement;\n    }\n  }\n  return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.rectToClientRect)({\n    width,\n    height,\n    x,\n    y\n  });\n}\nconst topLayerSelectors = [':popover-open', ':modal'];\nfunction isTopLayer(floating) {\n  return topLayerSelectors.some(selector => {\n    try {\n      return floating.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);\n  const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);\n  const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) !== 'body' || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isOverflowElement)(documentElement)) {\n      scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(offsetParent);\n    }\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element)).left + (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element);\n  const scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(element);\n  const body = element.ownerDocument.body;\n  const width = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(body).direction === 'rtl') {\n    x += (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getViewportRect(element, strategy) {\n  const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element);\n  const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isWebKit)();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) ? getScale(element) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element));\n  } else if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = _objectSpread(_objectSpread({}, clippingAncestor), {}, {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    });\n  }\n  return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.rectToClientRect)(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getParentNode)(element);\n  if (parentNode === stopNode || !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(parentNode) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isLastTraversableNode)(parentNode)) {\n    return false;\n  }\n  return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors)(element, [], false).filter(el => (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(el) && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element).position === 'fixed';\n  let currentNode = elementIsFixed ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getParentNode)(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(currentNode) && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isLastTraversableNode)(currentNode)) {\n    const computedStyle = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(currentNode);\n    const currentNodeIsContaining = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isContainingBlock)(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isOverflowElement)(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getParentNode)(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(rect.top, accRect.top);\n    accRect.right = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.min)(rect.right, accRect.right);\n    accRect.bottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.min)(rect.bottom, accRect.bottom);\n    accRect.left = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent);\n  const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) !== 'body' || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isOverflowElement)(documentElement)) {\n      scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  const x = rect.left + scroll.scrollLeft - offsets.x;\n  const y = rect.top + scroll.scrollTop - offsets.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element);\n  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) || isTopLayer(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isTableElement)(offsetParent) && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) === 'html' || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) === 'body' && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(offsetParent).position === 'static' && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isContainingBlock)(offsetParent))) {\n    return window;\n  }\n  return offsetParent || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getContainingBlock)(element) || window;\n}\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: _objectSpread({\n      x: 0,\n      y: 0\n    }, await getDimensionsFn(data.floating))\n  };\n};\nfunction isRTL(element) {\n  return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element).direction === 'rtl';\n}\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(top);\n    const insetRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(root.clientWidth - (left + width));\n    const insetBottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(root.clientHeight - (top + height));\n    const insetLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(0, (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.min)(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 100);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, _objectSpread(_objectSpread({}, options), {}, {\n        // Handle <iframe>s\n        root: root.ownerDocument\n      }));\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors)(referenceEl) : []), ...(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors)(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.autoPlacement;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.shift;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.flip;\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.size;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.hide;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.arrow;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.inline;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.limitShift;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = _objectSpread({\n    platform\n  }, options);\n  const platformWithCache = _objectSpread(_objectSpread({}, mergedOptions.platform), {}, {\n    _c: cache\n  });\n  return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.computePosition)(reference, floating, _objectSpread(_objectSpread({}, mergedOptions), {}, {\n    platform: platformWithCache\n  }));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLmRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpUTtBQUN0TTtBQUNlO0FBQ3FOO0FBQ2pPO0FBRTlELFNBQVN5QyxnQkFBZ0JBLENBQUNDLE9BQU8sRUFBRTtFQUNqQyxNQUFNQyxHQUFHLEdBQUdqQix3RUFBZ0IsQ0FBQ2dCLE9BQU8sQ0FBQztFQUNyQztFQUNBO0VBQ0EsSUFBSUUsS0FBSyxHQUFHQyxVQUFVLENBQUNGLEdBQUcsQ0FBQ0MsS0FBSyxDQUFDLElBQUksQ0FBQztFQUN0QyxJQUFJRSxNQUFNLEdBQUdELFVBQVUsQ0FBQ0YsR0FBRyxDQUFDRyxNQUFNLENBQUMsSUFBSSxDQUFDO0VBQ3hDLE1BQU1DLFNBQVMsR0FBR3BCLHFFQUFhLENBQUNlLE9BQU8sQ0FBQztFQUN4QyxNQUFNTSxXQUFXLEdBQUdELFNBQVMsR0FBR0wsT0FBTyxDQUFDTSxXQUFXLEdBQUdKLEtBQUs7RUFDM0QsTUFBTUssWUFBWSxHQUFHRixTQUFTLEdBQUdMLE9BQU8sQ0FBQ08sWUFBWSxHQUFHSCxNQUFNO0VBQzlELE1BQU1JLGNBQWMsR0FBRzdCLHlEQUFLLENBQUN1QixLQUFLLENBQUMsS0FBS0ksV0FBVyxJQUFJM0IseURBQUssQ0FBQ3lCLE1BQU0sQ0FBQyxLQUFLRyxZQUFZO0VBQ3JGLElBQUlDLGNBQWMsRUFBRTtJQUNsQk4sS0FBSyxHQUFHSSxXQUFXO0lBQ25CRixNQUFNLEdBQUdHLFlBQVk7RUFDdkI7RUFDQSxPQUFPO0lBQ0xMLEtBQUs7SUFDTEUsTUFBTTtJQUNOSyxDQUFDLEVBQUVEO0VBQ0wsQ0FBQztBQUNIO0FBRUEsU0FBU0UsYUFBYUEsQ0FBQ1YsT0FBTyxFQUFFO0VBQzlCLE9BQU8sQ0FBQ2QsaUVBQVMsQ0FBQ2MsT0FBTyxDQUFDLEdBQUdBLE9BQU8sQ0FBQ1csY0FBYyxHQUFHWCxPQUFPO0FBQy9EO0FBRUEsU0FB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eEQ7RUFDQTtFQUNBO0VBQ0EsTUFBTTFELEtBQUssR0FBRyxJQUFJK0YsR0FBRyxDQUFDLENBQUM7RUFDdkIsTUFBTUMsYUFBYSxHQUFBdEcsYUFBQTtJQUNqQjhDO0VBQVEsR0FDTGtCLE9BQU8sQ0FDWDtFQUNELE1BQU11QyxpQkFBaUIsR0FBQXZHLGFBQUEsQ0FBQUEsYUFBQSxLQUNsQnNHLGFBQWEsQ0FBQ3hELFFBQVE7SUFDekJyQixFQUFFLEVBQUVuQjtFQUFLLEVBQ1Y7RUFDRCxPQUFPbEgsa0VBQWlCLENBQUN3SixTQUFTLEVBQUUvRSxRQUFRLEVBQUFtQyxhQUFBLENBQUFBLGFBQUEsS0FDdkNzRyxhQUFhO0lBQ2hCeEQsUUFBUSxFQUFFeUQ7RUFBaUIsRUFDNUIsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xLWdlbmllLy4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9kb20vZGlzdC9mbG9hdGluZy11aS5kb20ubWpzPzNmYTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVjdFRvQ2xpZW50UmVjdCwgYXV0b1BsYWNlbWVudCBhcyBhdXRvUGxhY2VtZW50JDEsIHNoaWZ0IGFzIHNoaWZ0JDEsIGZsaXAgYXMgZmxpcCQxLCBzaXplIGFzIHNpemUkMSwgaGlkZSBhcyBoaWRlJDEsIGFycm93IGFzIGFycm93JDEsIGlubGluZSBhcyBpbmxpbmUkMSwgbGltaXRTaGlmdCBhcyBsaW1pdFNoaWZ0JDEsIGNvbXB1dGVQb3NpdGlvbiBhcyBjb21wdXRlUG9zaXRpb24kMSB9IGZyb20gJ0BmbG9hdGluZy11aS9jb3JlJztcbmV4cG9ydCB7IGRldGVjdE92ZXJmbG93LCBvZmZzZXQgfSBmcm9tICdAZmxvYXRpbmctdWkvY29yZSc7XG5pbXBvcnQgeyByb3VuZCwgY3JlYXRlQ29vcmRzLCBtYXgsIG1pbiwgZmxvb3IgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMnO1xuaW1wb3J0IHsgZ2V0Q29tcHV0ZWRTdHlsZSwgaXNIVE1MRWxlbWVudCwgaXNFbGVtZW50LCBnZXRXaW5kb3csIGlzV2ViS2l0LCBnZXREb2N1bWVudEVsZW1lbnQsIGdldE5vZGVOYW1lLCBpc092ZXJmbG93RWxlbWVudCwgZ2V0Tm9kZVNjcm9sbCwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMsIGdldFBhcmVudE5vZGUsIGlzTGFzdFRyYXZlcnNhYmxlTm9kZSwgaXNDb250YWluaW5nQmxvY2ssIGlzVGFibGVFbGVtZW50LCBnZXRDb250YWluaW5nQmxvY2sgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMvZG9tJztcbmV4cG9ydCB7IGdldE92ZXJmbG93QW5jZXN0b3JzIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzL2RvbSc7XG5cbmZ1bmN0aW9uIGdldENzc0RpbWVuc2lvbnMoZWxlbWVudCkge1xuICBjb25zdCBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAvLyBJbiB0ZXN0aW5nIGVudmlyb25tZW50cywgdGhlIGB3aWR0aGAgYW5kIGBoZWlnaHRgIHByb3BlcnRpZXMgYXJlIGVtcHR5XG4gIC8vIHN0cmluZ3MgZm9yIFNWRyBlbGVtZW50cywgcmV0dXJuaW5nIE5hTi4gRmFsbGJhY2sgdG8gYDBgIGluIHRoaXMgY2FzZS5cbiAgbGV0IHdpZHRoID0gcGFyc2VGbG9hdChjc3Mud2lkdGgpIHx8IDA7XG4gIGxldCBoZWlnaHQgPSBwYXJzZUZsb2F0KGNzcy5oZWlnaHQpIHx8IDA7XG4gIGNvbnN0IGhhc09mZnNldCA9IGlzSFRNTEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IG9mZnNldFdpZHRoID0gaGFzT2Zmc2V0ID8gZWxlbWVudC5vZmZzZXRXaWR0aCA6IHdpZHRoO1xuICBjb25zdCBvZmZzZXRIZWlnaHQgPSBoYXNPZmZzZXQgPyBlbGVtZW50Lm9mZnNldEhlaWdodCA6IGhlaWdodDtcbiAgY29uc3Qgc2hvdWxkRmFsbGJhY2sgPSByb3VuZCh3aWR0aCkgIT09IG9mZnNldFdpZHRoIHx8IHJvdW5kKGhlaWdodCkgIT09IG9mZnNldEhlaWdodDtcbiAgaWYgKHNob3VsZEZhbGxiYWNrKSB7XG4gICAgd2lkdGggPSBvZmZzZXRXaWR0aDtcbiAgICBoZWlnaHQgPSBvZmZzZXRIZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgJDogc2hvdWxkRmFsbGJhY2tcbiAgfTtcbn1cblxuZnVuY3Rpb24gdW53cmFwRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiAhaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudC5jb250ZXh0RWxlbWVudCA6IGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGdldFNjYWxlKGVsZW1lbnQpIHtcbiAgY29uc3QgZG9tRWxlbWVudCA9IHVud3JhcEVsZW1lbnQoZWxlbWVudCk7XG4gIGlmICghaXNIVE1MRWxlbWVudChkb21FbGVtZW50KSkge1xuICAgIHJldHVybiBjcmVhdGVDb29yZHMoMSk7XG4gIH1cbiAgY29uc3QgcmVjdCA9IGRvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgJFxuICB9ID0gZ2V0Q3NzRGltZW5zaW9ucyhkb21FbGVtZW50KTtcbiAgbGV0IHggPSAoJCA/IHJvdW5kKHJlY3Qud2lkdGgpIDogcmVjdC53aWR0aCkgLyB3aWR0aDtcbiAgbGV0IHkgPSAoJCA/IHJvdW5kKHJlY3QuaGVpZ2h0KSA6IHJlY3QuaGVpZ2h0KSAvIGhlaWdodDtcblxuICAvLyAwLCBOYU4sIG9yIEluZmluaXR5IHNob3VsZCBhbHdheXMgZmFsbGJhY2sgdG8gMS5cblxuICBpZiAoIXggfHwgIU51bWJlci5pc0Zpbml0ZSh4KSkge1xuICAgIHggPSAxO1xuICB9XG4gIGlmICgheSB8fCAhTnVtYmVyLmlzRmluaXRlKHkpKSB7XG4gICAgeSA9IDE7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuY29uc3Qgbm9PZmZzZXRzID0gLyojX19QVVJFX18qL2NyZWF0ZUNvb3JkcygwKTtcbmZ1bmN0aW9uIGdldFZpc3VhbE9mZnNldHMoZWxlbWVudCkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGlmICghaXNXZWJLaXQoKSB8fCAhd2luLnZpc3VhbFZpZXdwb3J0KSB7XG4gICAgcmV0dXJuIG5vT2Zmc2V0cztcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IHdpbi52aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0LFxuICAgIHk6IHdpbi52aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3BcbiAgfTtcbn1cbmZ1bmN0aW9uIHNob3VsZEFkZFZpc3VhbE9mZnNldHMoZWxlbWVudCwgaXNGaXhlZCwgZmxvYXRpbmdPZmZzZXRQYXJlbnQpIHtcbiAgaWYgKGlzRml4ZWQgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWQgPSBmYWxzZTtcbiAgfVxuICBpZiAoIWZsb2F0aW5nT2Zmc2V0UGFyZW50IHx8IGlzRml4ZWQgJiYgZmxvYXRpbmdPZmZzZXRQYXJlbnQgIT09IGdldFdpbmRvdyhlbGVtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNGaXhlZDtcbn1cblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGluY2x1ZGVTY2FsZSwgaXNGaXhlZFN0cmF0ZWd5LCBvZmZzZXRQYXJlbnQpIHtcbiAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzRml4ZWRTdHJhdGVneSA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZFN0cmF0ZWd5ID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgY2xpZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGRvbUVsZW1lbnQgPSB1bndyYXBFbGVtZW50KGVsZW1lbnQpO1xuICBsZXQgc2NhbGUgPSBjcmVhdGVDb29yZHMoMSk7XG4gIGlmIChpbmNsdWRlU2NhbGUpIHtcbiAgICBpZiAob2Zmc2V0UGFyZW50KSB7XG4gICAgICBpZiAoaXNFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgICAgc2NhbGUgPSBnZXRTY2FsZShvZmZzZXRQYXJlbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzY2FsZSA9IGdldFNjYWxlKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICBjb25zdCB2aXN1YWxPZmZzZXRzID0gc2hvdWxkQWRkVmlzdWFsT2Zmc2V0cyhkb21FbGVtZW50LCBpc0ZpeGVkU3RyYXRlZ3ksIG9mZnNldFBhcmVudCkgPyBnZXRWaXN1YWxPZmZzZXRzKGRvbUVsZW1lbnQpIDogY3JlYXRlQ29vcmRzKDApO1xuICBsZXQgeCA9IChjbGllbnRSZWN0LmxlZnQgKyB2aXN1YWxPZmZzZXRzLngpIC8gc2NhbGUueDtcbiAgbGV0IHkgPSAoY2xpZW50UmVjdC50b3AgKyB2aXN1YWxPZmZzZXRzLnkpIC8gc2NhbGUueTtcbiAgbGV0IHdpZHRoID0gY2xpZW50UmVjdC53aWR0aCAvIHNjYWxlLng7XG4gIGxldCBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodCAvIHNjYWxlLnk7XG4gIGlmIChkb21FbGVtZW50KSB7XG4gICAgY29uc3Qgd2luID0gZ2V0V2luZG93KGRvbUVsZW1lbnQpO1xuICAgIGNvbnN0IG9mZnNldFdpbiA9IG9mZnNldFBhcmVudCAmJiBpc0VsZW1lbnQob2Zmc2V0UGFyZW50KSA/IGdldFdpbmRvdyhvZmZzZXRQYXJlbnQpIDogb2Zmc2V0UGFyZW50O1xuICAgIGxldCBjdXJyZW50V2luID0gd2luO1xuICAgIGxldCBjdXJyZW50SUZyYW1lID0gY3VycmVudFdpbi5mcmFtZUVsZW1lbnQ7XG4gICAgd2hpbGUgKGN1cnJlbnRJRnJhbWUgJiYgb2Zmc2V0UGFyZW50ICYmIG9mZnNldFdpbiAhPT0gY3VycmVudFdpbikge1xuICAgICAgY29uc3QgaWZyYW1lU2NhbGUgPSBnZXRTY2FsZShjdXJyZW50SUZyYW1lKTtcbiAgICAgIGNvbnN0IGlmcmFtZVJlY3QgPSBjdXJyZW50SUZyYW1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50SUZyYW1lKTtcbiAgICAgIGNvbnN0IGxlZnQgPSBpZnJhbWVSZWN0LmxlZnQgKyAoY3VycmVudElGcmFtZS5jbGllbnRMZWZ0ICsgcGFyc2VGbG9hdChjc3MucGFkZGluZ0xlZnQpKSAqIGlmcmFtZVNjYWxlLng7XG4gICAgICBjb25zdCB0b3AgPSBpZnJhbWVSZWN0LnRvcCArIChjdXJyZW50SUZyYW1lLmNsaWVudFRvcCArIHBhcnNlRmxvYXQoY3NzLnBhZGRpbmdUb3ApKSAqIGlmcmFtZVNjYWxlLnk7XG4gICAgICB4ICo9IGlmcmFtZVNjYWxlLng7XG4gICAgICB5ICo9IGlmcmFtZVNjYWxlLnk7XG4gICAgICB3aWR0aCAqPSBpZnJhbWVTY2FsZS54O1xuICAgICAgaGVpZ2h0ICo9IGlmcmFtZVNjYWxlLnk7XG4gICAgICB4ICs9IGxlZnQ7XG4gICAgICB5ICs9IHRvcDtcbiAgICAgIGN1cnJlbnRXaW4gPSBnZXRXaW5kb3coY3VycmVudElGcmFtZSk7XG4gICAgICBjdXJyZW50SUZyYW1lID0gY3VycmVudFdpbi5mcmFtZUVsZW1lbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWN0VG9DbGllbnRSZWN0KHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH0pO1xufVxuXG5jb25zdCB0b3BMYXllclNlbGVjdG9ycyA9IFsnOnBvcG92ZXItb3BlbicsICc6bW9kYWwnXTtcbmZ1bmN0aW9uIGlzVG9wTGF5ZXIoZmxvYXRpbmcpIHtcbiAgcmV0dXJuIHRvcExheWVyU2VsZWN0b3JzLnNvbWUoc2VsZWN0b3IgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZmxvYXRpbmcubWF0Y2hlcyhzZWxlY3Rvcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50cyxcbiAgICByZWN0LFxuICAgIG9mZnNldFBhcmVudCxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgaXNGaXhlZCA9IHN0cmF0ZWd5ID09PSAnZml4ZWQnO1xuICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgdG9wTGF5ZXIgPSBlbGVtZW50cyA/IGlzVG9wTGF5ZXIoZWxlbWVudHMuZmxvYXRpbmcpIDogZmFsc2U7XG4gIGlmIChvZmZzZXRQYXJlbnQgPT09IGRvY3VtZW50RWxlbWVudCB8fCB0b3BMYXllciAmJiBpc0ZpeGVkKSB7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH1cbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBsZXQgc2NhbGUgPSBjcmVhdGVDb29yZHMoMSk7XG4gIGNvbnN0IG9mZnNldHMgPSBjcmVhdGVDb29yZHMoMCk7XG4gIGNvbnN0IGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCBpc092ZXJmbG93RWxlbWVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgIGNvbnN0IG9mZnNldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50KTtcbiAgICAgIHNjYWxlID0gZ2V0U2NhbGUob2Zmc2V0UGFyZW50KTtcbiAgICAgIG9mZnNldHMueCA9IG9mZnNldFJlY3QueCArIG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ID0gb2Zmc2V0UmVjdC55ICsgb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCAqIHNjYWxlLngsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodCAqIHNjYWxlLnksXG4gICAgeDogcmVjdC54ICogc2NhbGUueCAtIHNjcm9sbC5zY3JvbGxMZWZ0ICogc2NhbGUueCArIG9mZnNldHMueCxcbiAgICB5OiByZWN0LnkgKiBzY2FsZS55IC0gc2Nyb2xsLnNjcm9sbFRvcCAqIHNjYWxlLnkgKyBvZmZzZXRzLnlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdHMoZWxlbWVudCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmdldENsaWVudFJlY3RzKCkpO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpIHtcbiAgLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG59XG5cbi8vIEdldHMgdGhlIGVudGlyZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGRvY3VtZW50IGFyZWEsIGV2ZW4gZXh0ZW5kaW5nIG91dHNpZGVcbi8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGUuXG5mdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpO1xuICBjb25zdCBib2R5ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gIGNvbnN0IHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkuc2Nyb2xsV2lkdGgsIGJvZHkuY2xpZW50V2lkdGgpO1xuICBjb25zdCBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5LnNjcm9sbEhlaWdodCwgYm9keS5jbGllbnRIZWlnaHQpO1xuICBsZXQgeCA9IC1zY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIGNvbnN0IHkgPSAtc2Nyb2xsLnNjcm9sbFRvcDtcbiAgaWYgKGdldENvbXB1dGVkU3R5bGUoYm9keSkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHggKz0gbWF4KGh0bWwuY2xpZW50V2lkdGgsIGJvZHkuY2xpZW50V2lkdGgpIC0gd2lkdGg7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHZpc3VhbFZpZXdwb3J0ID0gd2luLnZpc3VhbFZpZXdwb3J0O1xuICBsZXQgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoO1xuICBsZXQgaGVpZ2h0ID0gaHRtbC5jbGllbnRIZWlnaHQ7XG4gIGxldCB4ID0gMDtcbiAgbGV0IHkgPSAwO1xuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcbiAgICBjb25zdCB2aXN1YWxWaWV3cG9ydEJhc2VkID0gaXNXZWJLaXQoKTtcbiAgICBpZiAoIXZpc3VhbFZpZXdwb3J0QmFzZWQgfHwgdmlzdWFsVmlld3BvcnRCYXNlZCAmJiBzdHJhdGVneSA9PT0gJ2ZpeGVkJykge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuLy8gUmV0dXJucyB0aGUgaW5uZXIgY2xpZW50IHJlY3QsIHN1YnRyYWN0aW5nIHNjcm9sbGJhcnMgaWYgcHJlc2VudC5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgdHJ1ZSwgc3RyYXRlZ3kgPT09ICdmaXhlZCcpO1xuICBjb25zdCB0b3AgPSBjbGllbnRSZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50VG9wO1xuICBjb25zdCBsZWZ0ID0gY2xpZW50UmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICBjb25zdCBzY2FsZSA9IGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRTY2FsZShlbGVtZW50KSA6IGNyZWF0ZUNvb3JkcygxKTtcbiAgY29uc3Qgd2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoICogc2NhbGUueDtcbiAgY29uc3QgaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQgKiBzY2FsZS55O1xuICBjb25zdCB4ID0gbGVmdCAqIHNjYWxlLng7XG4gIGNvbnN0IHkgPSB0b3AgKiBzY2FsZS55O1xuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkge1xuICBsZXQgcmVjdDtcbiAgaWYgKGNsaXBwaW5nQW5jZXN0b3IgPT09ICd2aWV3cG9ydCcpIHtcbiAgICByZWN0ID0gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KTtcbiAgfSBlbHNlIGlmIChjbGlwcGluZ0FuY2VzdG9yID09PSAnZG9jdW1lbnQnKSB7XG4gICAgcmVjdCA9IGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpO1xuICB9IGVsc2UgaWYgKGlzRWxlbWVudChjbGlwcGluZ0FuY2VzdG9yKSkge1xuICAgIHJlY3QgPSBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdmlzdWFsT2Zmc2V0cyA9IGdldFZpc3VhbE9mZnNldHMoZWxlbWVudCk7XG4gICAgcmVjdCA9IHtcbiAgICAgIC4uLmNsaXBwaW5nQW5jZXN0b3IsXG4gICAgICB4OiBjbGlwcGluZ0FuY2VzdG9yLnggLSB2aXN1YWxPZmZzZXRzLngsXG4gICAgICB5OiBjbGlwcGluZ0FuY2VzdG9yLnkgLSB2aXN1YWxPZmZzZXRzLnlcbiAgICB9O1xuICB9XG4gIHJldHVybiByZWN0VG9DbGllbnRSZWN0KHJlY3QpO1xufVxuZnVuY3Rpb24gaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKGVsZW1lbnQsIHN0b3BOb2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICBpZiAocGFyZW50Tm9kZSA9PT0gc3RvcE5vZGUgfHwgIWlzRWxlbWVudChwYXJlbnROb2RlKSB8fCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUocGFyZW50Tm9kZSkucG9zaXRpb24gPT09ICdmaXhlZCcgfHwgaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKHBhcmVudE5vZGUsIHN0b3BOb2RlKTtcbn1cblxuLy8gQSBcImNsaXBwaW5nIGFuY2VzdG9yXCIgaXMgYW4gYG92ZXJmbG93YCBlbGVtZW50IHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBjaGlsZCBlbGVtZW50cy4gVGhpcyByZXR1cm5zIGFsbCBjbGlwcGluZyBhbmNlc3RvcnNcbi8vIG9mIHRoZSBnaXZlbiBlbGVtZW50IHVwIHRoZSB0cmVlLlxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzKGVsZW1lbnQsIGNhY2hlKSB7XG4gIGNvbnN0IGNhY2hlZFJlc3VsdCA9IGNhY2hlLmdldChlbGVtZW50KTtcbiAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IGdldE92ZXJmbG93QW5jZXN0b3JzKGVsZW1lbnQsIFtdLCBmYWxzZSkuZmlsdGVyKGVsID0+IGlzRWxlbWVudChlbCkgJiYgZ2V0Tm9kZU5hbWUoZWwpICE9PSAnYm9keScpO1xuICBsZXQgY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgPSBudWxsO1xuICBjb25zdCBlbGVtZW50SXNGaXhlZCA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCc7XG4gIGxldCBjdXJyZW50Tm9kZSA9IGVsZW1lbnRJc0ZpeGVkID8gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcbiAgd2hpbGUgKGlzRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSk7XG4gICAgY29uc3QgY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgPSBpc0NvbnRhaW5pbmdCbG9jayhjdXJyZW50Tm9kZSk7XG4gICAgaWYgKCFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICBjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZERyb3BDdXJyZW50Tm9kZSA9IGVsZW1lbnRJc0ZpeGVkID8gIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmICFjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA6ICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnc3RhdGljJyAmJiAhIWN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlICYmIFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmNsdWRlcyhjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZS5wb3NpdGlvbikgfHwgaXNPdmVyZmxvd0VsZW1lbnQoY3VycmVudE5vZGUpICYmICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IoZWxlbWVudCwgY3VycmVudE5vZGUpO1xuICAgIGlmIChzaG91bGREcm9wQ3VycmVudE5vZGUpIHtcbiAgICAgIC8vIERyb3Agbm9uLWNvbnRhaW5pbmcgYmxvY2tzLlxuICAgICAgcmVzdWx0ID0gcmVzdWx0LmZpbHRlcihhbmNlc3RvciA9PiBhbmNlc3RvciAhPT0gY3VycmVudE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWNvcmQgbGFzdCBjb250YWluaW5nIGJsb2NrIGZvciBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgIGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZTtcbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKTtcbiAgfVxuICBjYWNoZS5zZXQoZWxlbWVudCwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgYW5jZXN0b3JzLlxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50LFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgZWxlbWVudENsaXBwaW5nQW5jZXN0b3JzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ0FuY2VzdG9ycycgPyBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnMoZWxlbWVudCwgdGhpcy5fYykgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICBjb25zdCBjbGlwcGluZ0FuY2VzdG9ycyA9IFsuLi5lbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMsIHJvb3RCb3VuZGFyeV07XG4gIGNvbnN0IGZpcnN0Q2xpcHBpbmdBbmNlc3RvciA9IGNsaXBwaW5nQW5jZXN0b3JzWzBdO1xuICBjb25zdCBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ0FuY2VzdG9ycy5yZWR1Y2UoKGFjY1JlY3QsIGNsaXBwaW5nQW5jZXN0b3IpID0+IHtcbiAgICBjb25zdCByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgZmlyc3RDbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdCxcbiAgICBoZWlnaHQ6IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wLFxuICAgIHg6IGNsaXBwaW5nUmVjdC5sZWZ0LFxuICAgIHk6IGNsaXBwaW5nUmVjdC50b3BcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyhlbGVtZW50KSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IGdldENzc0RpbWVuc2lvbnMoZWxlbWVudCk7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50KGVsZW1lbnQsIG9mZnNldFBhcmVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3QgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBpc0ZpeGVkID0gc3RyYXRlZ3kgPT09ICdmaXhlZCc7XG4gIGNvbnN0IHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgdHJ1ZSwgaXNGaXhlZCwgb2Zmc2V0UGFyZW50KTtcbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBjb25zdCBvZmZzZXRzID0gY3JlYXRlQ29vcmRzKDApO1xuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCBpc092ZXJmbG93RWxlbWVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCkge1xuICAgICAgY29uc3Qgb2Zmc2V0UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUsIGlzRml4ZWQsIG9mZnNldFBhcmVudCk7XG4gICAgICBvZmZzZXRzLnggPSBvZmZzZXRSZWN0LnggKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSA9IG9mZnNldFJlY3QueSArIG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgeCA9IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54O1xuICBjb25zdCB5ID0gcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55O1xuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCwgcG9seWZpbGwpIHtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocG9seWZpbGwpIHtcbiAgICByZXR1cm4gcG9seWZpbGwoZWxlbWVudCk7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xufVxuXG4vLyBHZXRzIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHBvc2l0aW9uZWQgZWxlbWVudC4gSGFuZGxlcyBzb21lIGVkZ2UgY2FzZXMsXG4vLyBzdWNoIGFzIHRhYmxlIGFuY2VzdG9ycyBhbmQgY3Jvc3MgYnJvd3NlciBidWdzLlxuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKSB7XG4gIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IGlzVG9wTGF5ZXIoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG4gIGxldCBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKTtcbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCwgcG9seWZpbGwpO1xuICB9XG4gIGlmIChvZmZzZXRQYXJlbnQgJiYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdodG1sJyB8fCBnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnYm9keScgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJyAmJiAhaXNDb250YWluaW5nQmxvY2sob2Zmc2V0UGFyZW50KSkpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcbn1cblxuY29uc3QgZ2V0RWxlbWVudFJlY3RzID0gYXN5bmMgZnVuY3Rpb24gKGRhdGEpIHtcbiAgY29uc3QgZ2V0T2Zmc2V0UGFyZW50Rm4gPSB0aGlzLmdldE9mZnNldFBhcmVudCB8fCBnZXRPZmZzZXRQYXJlbnQ7XG4gIGNvbnN0IGdldERpbWVuc2lvbnNGbiA9IHRoaXMuZ2V0RGltZW5zaW9ucztcbiAgcmV0dXJuIHtcbiAgICByZWZlcmVuY2U6IGdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50KGRhdGEucmVmZXJlbmNlLCBhd2FpdCBnZXRPZmZzZXRQYXJlbnRGbihkYXRhLmZsb2F0aW5nKSwgZGF0YS5zdHJhdGVneSksXG4gICAgZmxvYXRpbmc6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgLi4uKGF3YWl0IGdldERpbWVuc2lvbnNGbihkYXRhLmZsb2F0aW5nKSlcbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBpc1JUTChlbGVtZW50KSB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XG59XG5cbmNvbnN0IHBsYXRmb3JtID0ge1xuICBjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCxcbiAgZ2V0RG9jdW1lbnRFbGVtZW50LFxuICBnZXRDbGlwcGluZ1JlY3QsXG4gIGdldE9mZnNldFBhcmVudCxcbiAgZ2V0RWxlbWVudFJlY3RzLFxuICBnZXRDbGllbnRSZWN0cyxcbiAgZ2V0RGltZW5zaW9ucyxcbiAgZ2V0U2NhbGUsXG4gIGlzRWxlbWVudCxcbiAgaXNSVExcbn07XG5cbi8vIGh0dHBzOi8vc2FtdGhvci5hdS8yMDIxL29ic2VydmluZy1kb20vXG5mdW5jdGlvbiBvYnNlcnZlTW92ZShlbGVtZW50LCBvbk1vdmUpIHtcbiAgbGV0IGlvID0gbnVsbDtcbiAgbGV0IHRpbWVvdXRJZDtcbiAgY29uc3Qgcm9vdCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICB2YXIgX2lvO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIChfaW8gPSBpbykgPT0gbnVsbCB8fCBfaW8uZGlzY29ubmVjdCgpO1xuICAgIGlvID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiByZWZyZXNoKHNraXAsIHRocmVzaG9sZCkge1xuICAgIGlmIChza2lwID09PSB2b2lkIDApIHtcbiAgICAgIHNraXAgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRocmVzaG9sZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJlc2hvbGQgPSAxO1xuICAgIH1cbiAgICBjbGVhbnVwKCk7XG4gICAgY29uc3Qge1xuICAgICAgbGVmdCxcbiAgICAgIHRvcCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKCFza2lwKSB7XG4gICAgICBvbk1vdmUoKTtcbiAgICB9XG4gICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluc2V0VG9wID0gZmxvb3IodG9wKTtcbiAgICBjb25zdCBpbnNldFJpZ2h0ID0gZmxvb3Iocm9vdC5jbGllbnRXaWR0aCAtIChsZWZ0ICsgd2lkdGgpKTtcbiAgICBjb25zdCBpbnNldEJvdHRvbSA9IGZsb29yKHJvb3QuY2xpZW50SGVpZ2h0IC0gKHRvcCArIGhlaWdodCkpO1xuICAgIGNvbnN0IGluc2V0TGVmdCA9IGZsb29yKGxlZnQpO1xuICAgIGNvbnN0IHJvb3RNYXJnaW4gPSAtaW5zZXRUb3AgKyBcInB4IFwiICsgLWluc2V0UmlnaHQgKyBcInB4IFwiICsgLWluc2V0Qm90dG9tICsgXCJweCBcIiArIC1pbnNldExlZnQgKyBcInB4XCI7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHJvb3RNYXJnaW4sXG4gICAgICB0aHJlc2hvbGQ6IG1heCgwLCBtaW4oMSwgdGhyZXNob2xkKSkgfHwgMVxuICAgIH07XG4gICAgbGV0IGlzRmlyc3RVcGRhdGUgPSB0cnVlO1xuICAgIGZ1bmN0aW9uIGhhbmRsZU9ic2VydmUoZW50cmllcykge1xuICAgICAgY29uc3QgcmF0aW8gPSBlbnRyaWVzWzBdLmludGVyc2VjdGlvblJhdGlvO1xuICAgICAgaWYgKHJhdGlvICE9PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgaWYgKCFpc0ZpcnN0VXBkYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJhdGlvKSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByZWZyZXNoKGZhbHNlLCAxZS03KTtcbiAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnJlc2goZmFsc2UsIHJhdGlvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaXNGaXJzdFVwZGF0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIE9sZGVyIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgYSBgZG9jdW1lbnRgIGFzIHRoZSByb290IGFuZCB3aWxsIHRocm93IGFuXG4gICAgLy8gZXJyb3IuXG4gICAgdHJ5IHtcbiAgICAgIGlvID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGhhbmRsZU9ic2VydmUsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgLy8gSGFuZGxlIDxpZnJhbWU+c1xuICAgICAgICByb290OiByb290Lm93bmVyRG9jdW1lbnRcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlvID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGhhbmRsZU9ic2VydmUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpby5vYnNlcnZlKGVsZW1lbnQpO1xuICB9XG4gIHJlZnJlc2godHJ1ZSk7XG4gIHJldHVybiBjbGVhbnVwO1xufVxuXG4vKipcbiAqIEF1dG9tYXRpY2FsbHkgdXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgd2hlbiBuZWNlc3NhcnkuXG4gKiBTaG91bGQgb25seSBiZSBjYWxsZWQgd2hlbiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpcyBtb3VudGVkIG9uIHRoZSBET00gb3JcbiAqIHZpc2libGUgb24gdGhlIHNjcmVlbi5cbiAqIEByZXR1cm5zIGNsZWFudXAgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgaW52b2tlZCB3aGVuIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzXG4gKiByZW1vdmVkIGZyb20gdGhlIERPTSBvciBoaWRkZW4gZnJvbSB0aGUgc2NyZWVuLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9VcGRhdGVcbiAqL1xuZnVuY3Rpb24gYXV0b1VwZGF0ZShyZWZlcmVuY2UsIGZsb2F0aW5nLCB1cGRhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgYW5jZXN0b3JTY3JvbGwgPSB0cnVlLFxuICAgIGFuY2VzdG9yUmVzaXplID0gdHJ1ZSxcbiAgICBlbGVtZW50UmVzaXplID0gdHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSAnZnVuY3Rpb24nLFxuICAgIGxheW91dFNoaWZ0ID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSAnZnVuY3Rpb24nLFxuICAgIGFuaW1hdGlvbkZyYW1lID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHJlZmVyZW5jZUVsID0gdW53cmFwRWxlbWVudChyZWZlcmVuY2UpO1xuICBjb25zdCBhbmNlc3RvcnMgPSBhbmNlc3RvclNjcm9sbCB8fCBhbmNlc3RvclJlc2l6ZSA/IFsuLi4ocmVmZXJlbmNlRWwgPyBnZXRPdmVyZmxvd0FuY2VzdG9ycyhyZWZlcmVuY2VFbCkgOiBbXSksIC4uLmdldE92ZXJmbG93QW5jZXN0b3JzKGZsb2F0aW5nKV0gOiBbXTtcbiAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgIGFuY2VzdG9yU2Nyb2xsICYmIGFuY2VzdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHVwZGF0ZSwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGFuY2VzdG9yUmVzaXplICYmIGFuY2VzdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZSk7XG4gIH0pO1xuICBjb25zdCBjbGVhbnVwSW8gPSByZWZlcmVuY2VFbCAmJiBsYXlvdXRTaGlmdCA/IG9ic2VydmVNb3ZlKHJlZmVyZW5jZUVsLCB1cGRhdGUpIDogbnVsbDtcbiAgbGV0IHJlb2JzZXJ2ZUZyYW1lID0gLTE7XG4gIGxldCByZXNpemVPYnNlcnZlciA9IG51bGw7XG4gIGlmIChlbGVtZW50UmVzaXplKSB7XG4gICAgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoX3JlZiA9PiB7XG4gICAgICBsZXQgW2ZpcnN0RW50cnldID0gX3JlZjtcbiAgICAgIGlmIChmaXJzdEVudHJ5ICYmIGZpcnN0RW50cnkudGFyZ2V0ID09PSByZWZlcmVuY2VFbCAmJiByZXNpemVPYnNlcnZlcikge1xuICAgICAgICAvLyBQcmV2ZW50IHVwZGF0ZSBsb29wcyB3aGVuIHVzaW5nIHRoZSBgc2l6ZWAgbWlkZGxld2FyZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8xNzQwXG4gICAgICAgIHJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZShmbG9hdGluZyk7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlb2JzZXJ2ZUZyYW1lKTtcbiAgICAgICAgcmVvYnNlcnZlRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIHZhciBfcmVzaXplT2JzZXJ2ZXI7XG4gICAgICAgICAgKF9yZXNpemVPYnNlcnZlciA9IHJlc2l6ZU9ic2VydmVyKSA9PSBudWxsIHx8IF9yZXNpemVPYnNlcnZlci5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB1cGRhdGUoKTtcbiAgICB9KTtcbiAgICBpZiAocmVmZXJlbmNlRWwgJiYgIWFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKHJlZmVyZW5jZUVsKTtcbiAgICB9XG4gICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShmbG9hdGluZyk7XG4gIH1cbiAgbGV0IGZyYW1lSWQ7XG4gIGxldCBwcmV2UmVmUmVjdCA9IGFuaW1hdGlvbkZyYW1lID8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHJlZmVyZW5jZSkgOiBudWxsO1xuICBpZiAoYW5pbWF0aW9uRnJhbWUpIHtcbiAgICBmcmFtZUxvb3AoKTtcbiAgfVxuICBmdW5jdGlvbiBmcmFtZUxvb3AoKSB7XG4gICAgY29uc3QgbmV4dFJlZlJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlKTtcbiAgICBpZiAocHJldlJlZlJlY3QgJiYgKG5leHRSZWZSZWN0LnggIT09IHByZXZSZWZSZWN0LnggfHwgbmV4dFJlZlJlY3QueSAhPT0gcHJldlJlZlJlY3QueSB8fCBuZXh0UmVmUmVjdC53aWR0aCAhPT0gcHJldlJlZlJlY3Qud2lkdGggfHwgbmV4dFJlZlJlY3QuaGVpZ2h0ICE9PSBwcmV2UmVmUmVjdC5oZWlnaHQpKSB7XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG4gICAgcHJldlJlZlJlY3QgPSBuZXh0UmVmUmVjdDtcbiAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lTG9vcCk7XG4gIH1cbiAgdXBkYXRlKCk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgdmFyIF9yZXNpemVPYnNlcnZlcjI7XG4gICAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlKTtcbiAgICAgIGFuY2VzdG9yUmVzaXplICYmIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZSk7XG4gICAgfSk7XG4gICAgY2xlYW51cElvID09IG51bGwgfHwgY2xlYW51cElvKCk7XG4gICAgKF9yZXNpemVPYnNlcnZlcjIgPSByZXNpemVPYnNlcnZlcikgPT0gbnVsbCB8fCBfcmVzaXplT2JzZXJ2ZXIyLmRpc2Nvbm5lY3QoKTtcbiAgICByZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgaWYgKGFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZUlkKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGNob29zaW5nIHRoZSBwbGFjZW1lbnRcbiAqIHRoYXQgaGFzIHRoZSBtb3N0IHNwYWNlIGF2YWlsYWJsZSBhdXRvbWF0aWNhbGx5LCB3aXRob3V0IG5lZWRpbmcgdG8gc3BlY2lmeSBhXG4gKiBwcmVmZXJyZWQgcGxhY2VtZW50LiBBbHRlcm5hdGl2ZSB0byBgZmxpcGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXV0b1BsYWNlbWVudFxuICovXG5jb25zdCBhdXRvUGxhY2VtZW50ID0gYXV0b1BsYWNlbWVudCQxO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBzaGlmdGluZyBpdCBpbiBvcmRlciB0b1xuICoga2VlcCBpdCBpbiB2aWV3IHdoZW4gaXQgd2lsbCBvdmVyZmxvdyB0aGUgY2xpcHBpbmcgYm91bmRhcnkuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2hpZnRcbiAqL1xuY29uc3Qgc2hpZnQgPSBzaGlmdCQxO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBmbGlwcGluZyB0aGUgYHBsYWNlbWVudGBcbiAqIGluIG9yZGVyIHRvIGtlZXAgaXQgaW4gdmlldyB3aGVuIHRoZSBwcmVmZXJyZWQgcGxhY2VtZW50KHMpIHdpbGwgb3ZlcmZsb3cgdGhlXG4gKiBjbGlwcGluZyBib3VuZGFyeS4gQWx0ZXJuYXRpdmUgdG8gYGF1dG9QbGFjZW1lbnRgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2ZsaXBcbiAqL1xuY29uc3QgZmxpcCA9IGZsaXAkMTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRoYXQgYWxsb3dzIHlvdSB0byBjaGFuZ2UgdGhlIHNpemUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQg4oCUXG4gKiBmb3IgaW5zdGFuY2UsIHByZXZlbnQgaXQgZnJvbSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgYm91bmRhcnkgb3IgbWF0Y2ggdGhlXG4gKiB3aWR0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2l6ZVxuICovXG5jb25zdCBzaXplID0gc2l6ZSQxO1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gaGlkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbiBhcHBsaWNhYmxlIHNpdHVhdGlvbnMsIHN1Y2ggYXNcbiAqIHdoZW4gaXQgaXMgbm90IGluIHRoZSBzYW1lIGNsaXBwaW5nIGNvbnRleHQgYXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2hpZGVcbiAqL1xuY29uc3QgaGlkZSA9IGhpZGUkMTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGFuIGlubmVyIGVsZW1lbnQgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgc28gdGhhdCBpdFxuICogYXBwZWFycyBjZW50ZXJlZCB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXJyb3dcbiAqL1xuY29uc3QgYXJyb3cgPSBhcnJvdyQxO1xuXG4vKipcbiAqIFByb3ZpZGVzIGltcHJvdmVkIHBvc2l0aW9uaW5nIGZvciBpbmxpbmUgcmVmZXJlbmNlIGVsZW1lbnRzIHRoYXQgY2FuIHNwYW5cbiAqIG92ZXIgbXVsdGlwbGUgbGluZXMsIHN1Y2ggYXMgaHlwZXJsaW5rcyBvciByYW5nZSBzZWxlY3Rpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubGluZVxuICovXG5jb25zdCBpbmxpbmUgPSBpbmxpbmUkMTtcblxuLyoqXG4gKiBCdWlsdC1pbiBgbGltaXRlcmAgdGhhdCB3aWxsIHN0b3AgYHNoaWZ0KClgIGF0IGEgY2VydGFpbiBwb2ludC5cbiAqL1xuY29uc3QgbGltaXRTaGlmdCA9IGxpbWl0U2hpZnQkMTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgdGhhdCB3aWxsIHBsYWNlIHRoZSBmbG9hdGluZyBlbGVtZW50XG4gKiBuZXh0IHRvIGEgZ2l2ZW4gcmVmZXJlbmNlIGVsZW1lbnQuXG4gKi9cbmNvbnN0IGNvbXB1dGVQb3NpdGlvbiA9IChyZWZlcmVuY2UsIGZsb2F0aW5nLCBvcHRpb25zKSA9PiB7XG4gIC8vIFRoaXMgY2FjaGVzIHRoZSBleHBlbnNpdmUgYGdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9yc2AgZnVuY3Rpb24gc28gdGhhdFxuICAvLyBtdWx0aXBsZSBsaWZlY3ljbGUgcmVzZXRzIHJlLXVzZSB0aGUgc2FtZSByZXN1bHQuIEl0IG9ubHkgbGl2ZXMgZm9yIGFcbiAgLy8gc2luZ2xlIGNhbGwuIElmIG90aGVyIGZ1bmN0aW9ucyBiZWNvbWUgZXhwZW5zaXZlLCB3ZSBjYW4gYWRkIHRoZW0gYXMgd2VsbC5cbiAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSB7XG4gICAgcGxhdGZvcm0sXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCBwbGF0Zm9ybVdpdGhDYWNoZSA9IHtcbiAgICAuLi5tZXJnZWRPcHRpb25zLnBsYXRmb3JtLFxuICAgIF9jOiBjYWNoZVxuICB9O1xuICByZXR1cm4gY29tcHV0ZVBvc2l0aW9uJDEocmVmZXJlbmNlLCBmbG9hdGluZywge1xuICAgIC4uLm1lcmdlZE9wdGlvbnMsXG4gICAgcGxhdGZvcm06IHBsYXRmb3JtV2l0aENhY2hlXG4gIH0pO1xufTtcblxuZXhwb3J0IHsgYXJyb3csIGF1dG9QbGFjZW1lbnQsIGF1dG9VcGRhdGUsIGNvbXB1dGVQb3NpdGlvbiwgZmxpcCwgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBwbGF0Zm9ybSwgc2hpZnQsIHNpemUgfTtcbiJdLCJuYW1lcyI6WyJyZWN0VG9DbGllbnRSZWN0IiwiYXV0b1BsYWNlbWVudCIsImF1dG9QbGFjZW1lbnQkMSIsInNoaWZ0Iiwic2hpZnQkMSIsImZsaXAiLCJmbGlwJDEiLCJzaXplIiwic2l6ZSQxIiwiaGlkZSIsImhpZGUkMSIsImFycm93IiwiYXJyb3ckMSIsImlubGluZSIsImlubGluZSQxIiwibGltaXRTaGlmdCIsImxpbWl0U2hpZnQkMSIsImNvbXB1dGVQb3NpdGlvbiIsImNvbXB1dGVQb3NpdGlvbiQxIiwiZGV0ZWN0T3ZlcmZsb3ciLCJvZmZzZXQiLCJyb3VuZCIsImNyZWF0ZUNvb3JkcyIsIm1heCIsIm1pbiIsImZsb29yIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImlzSFRNTEVsZW1lbnQiLCJpc0VsZW1lbnQiLCJnZXRXaW5kb3ciLCJpc1dlYktpdCIsImdldERvY3VtZW50RWxlbWVudCIsImdldE5vZGVOYW1lIiwiaXNPdmVyZmxvd0VsZW1lbnQiLCJnZXROb2RlU2Nyb2xsIiwiZ2V0T3ZlcmZsb3dBbmNlc3RvcnMiLCJnZXRQYXJlbnROb2RlIiwiaXNMYXN0VHJhdmVyc2FibGVOb2RlIiwiaXNDb250YWluaW5nQmxvY2siLCJpc1RhYmxlRWxlbWVudCIsImdldENvbnRhaW5pbmdCbG9jayIsImdldENzc0RpbWVuc2lvbnMiLCJlbGVtZW50IiwiY3NzIiwid2lkdGgiLCJwYXJzZUZsb2F0IiwiaGVpZ2h0IiwiaGFzT2Zmc2V0Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJzaG91bGRGYWxsYmFjayIsIiQiLCJ1bndyYXBFbGVtZW50IiwiY29udGV4dEVsZW1lbnQiLCJnZXRTY2FsZSIsImRvbUVsZW1lbnQiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwieCIsInkiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIm5vT2Zmc2V0cyIsImdldFZpc3VhbE9mZnNldHMiLCJ3aW4iLCJ2aXN1YWxWaWV3cG9ydCIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJzaG91bGRBZGRWaXN1YWxPZmZzZXRzIiwiaXNGaXhlZCIsImZsb2F0aW5nT2Zmc2V0UGFyZW50IiwiaW5jbHVkZVNjYWxlIiwiaXNGaXhlZFN0cmF0ZWd5Iiwib2Zmc2V0UGFyZW50IiwiY2xpZW50UmVjdCIsInNjYWxlIiwidmlzdWFsT2Zmc2V0cyIsImxlZnQiLCJ0b3AiLCJvZmZzZXRXaW4iLCJjdXJyZW50V2luIiwiY3VycmVudElGcmFtZSIsImZyYW1lRWxlbWVudCIsImlmcmFtZVNjYWxlIiwiaWZyYW1lUmVjdCIsImNsaWVudExlZnQiLCJwYWRkaW5nTGVmdCIsImNsaWVudFRvcCIsInBhZGRpbmdUb3AiLCJ0b3BMYXllclNlbGVjdG9ycyIsImlzVG9wTGF5ZXIiLCJmbG9hdGluZyIsInNvbWUiLCJzZWxlY3RvciIsIm1hdGNoZXMiLCJlIiwiY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QiLCJfcmVmIiwiZWxlbWVudHMiLCJzdHJhdGVneSIsImRvY3VtZW50RWxlbWVudCIsInRvcExheWVyIiwic2Nyb2xsIiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsIm9mZnNldHMiLCJpc09mZnNldFBhcmVudEFuRWxlbWVudCIsIm9mZnNldFJlY3QiLCJnZXRDbGllbnRSZWN0cyIsIkFycmF5IiwiZnJvbSIsImdldFdpbmRvd1Njcm9sbEJhclgiLCJnZXREb2N1bWVudFJlY3QiLCJodG1sIiwiYm9keSIsIm93bmVyRG9jdW1lbnQiLCJzY3JvbGxXaWR0aCIsImNsaWVudFdpZHRoIiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiZGlyZWN0aW9uIiwiZ2V0Vmlld3BvcnRSZWN0IiwidmlzdWFsVmlld3BvcnRCYXNlZCIsImdldElubmVyQm91bmRpbmdDbGllbnRSZWN0IiwiZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yIiwiY2xpcHBpbmdBbmNlc3RvciIsIl9vYmplY3RTcHJlYWQiLCJoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IiLCJzdG9wTm9kZSIsInBhcmVudE5vZGUiLCJwb3NpdGlvbiIsImdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9ycyIsImNhY2hlIiwiY2FjaGVkUmVzdWx0IiwiZ2V0IiwicmVzdWx0IiwiZmlsdGVyIiwiZWwiLCJjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSIsImVsZW1lbnRJc0ZpeGVkIiwiY3VycmVudE5vZGUiLCJjb21wdXRlZFN0eWxlIiwiY3VycmVudE5vZGVJc0NvbnRhaW5pbmciLCJzaG91bGREcm9wQ3VycmVudE5vZGUiLCJpbmNsdWRlcyIsImFuY2VzdG9yIiwic2V0IiwiZ2V0Q2xpcHBpbmdSZWN0IiwiYm91bmRhcnkiLCJyb290Qm91bmRhcnkiLCJlbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMiLCJfYyIsImNvbmNhdCIsImNsaXBwaW5nQW5jZXN0b3JzIiwiZmlyc3RDbGlwcGluZ0FuY2VzdG9yIiwiY2xpcHBpbmdSZWN0IiwicmVkdWNlIiwiYWNjUmVjdCIsInJpZ2h0IiwiYm90dG9tIiwiZ2V0RGltZW5zaW9ucyIsImdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50IiwiZ2V0VHJ1ZU9mZnNldFBhcmVudCIsInBvbHlmaWxsIiwiZ2V0T2Zmc2V0UGFyZW50Iiwid2luZG93IiwiZ2V0RWxlbWVudFJlY3RzIiwiZGF0YSIsImdldE9mZnNldFBhcmVudEZuIiwiZ2V0RGltZW5zaW9uc0ZuIiwicmVmZXJlbmNlIiwiaXNSVEwiLCJwbGF0Zm9ybSIsIm9ic2VydmVNb3ZlIiwib25Nb3ZlIiwiaW8iLCJ0aW1lb3V0SWQiLCJyb290IiwiY2xlYW51cCIsIl9pbyIsImNsZWFyVGltZW91dCIsImRpc2Nvbm5lY3QiLCJyZWZyZXNoIiwic2tpcCIsInRocmVzaG9sZCIsImluc2V0VG9wIiwiaW5zZXRSaWdodCIsImluc2V0Qm90dG9tIiwiaW5zZXRMZWZ0Iiwicm9vdE1hcmdpbiIsIm9wdGlvbnMiLCJpc0ZpcnN0VXBkYXRlIiwiaGFuZGxlT2JzZXJ2ZSIsImVudHJpZXMiLCJyYXRpbyIsImludGVyc2VjdGlvblJhdGlvIiwic2V0VGltZW91dCIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwib2JzZXJ2ZSIsImF1dG9VcGRhdGUiLCJ1cGRhdGUiLCJhbmNlc3RvclNjcm9sbCIsImFuY2VzdG9yUmVzaXplIiwiZWxlbWVudFJlc2l6ZSIsIlJlc2l6ZU9ic2VydmVyIiwibGF5b3V0U2hpZnQiLCJhbmltYXRpb25GcmFtZSIsInJlZmVyZW5jZUVsIiwiYW5jZXN0b3JzIiwiZm9yRWFjaCIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwiY2xlYW51cElvIiwicmVvYnNlcnZlRnJhbWUiLCJyZXNpemVPYnNlcnZlciIsImZpcnN0RW50cnkiLCJ0YXJnZXQiLCJ1bm9ic2VydmUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIl9yZXNpemVPYnNlcnZlciIsImZyYW1lSWQiLCJwcmV2UmVmUmVjdCIsImZyYW1lTG9vcCIsIm5leHRSZWZSZWN0IiwiX3Jlc2l6ZU9ic2VydmVyMiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJNYXAiLCJtZXJnZWRPcHRpb25zIiwicGxhdGZvcm1XaXRoQ2FjaGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoPlacement),\n/* harmony export */   autoUpdate: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoUpdate),\n/* harmony export */   computePosition: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.detectOverflow),\n/* harmony export */   flip: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.hide),\n/* harmony export */   inline: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.inline),\n/* harmony export */   limitShift: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.offset),\n/* harmony export */   platform: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.platform),\n/* harmony export */   shift: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.shift),\n/* harmony export */   size: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.size),\n/* harmony export */   useFloating: () => (/* binding */ useFloating)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n\n\n\n\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => {\n  function isRef(value) {\n    return {}.hasOwnProperty.call(value, 'current');\n  }\n  return {\n    name: 'arrow',\n    options,\n    fn(state) {\n      const {\n        element,\n        padding\n      } = typeof options === 'function' ? options(state) : options;\n      if (element && isRef(element)) {\n        if (element.current != null) {\n          return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({\n            element: element.current,\n            padding\n          }).fn(state);\n        }\n        return {};\n      }\n      if (element) {\n        return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({\n          element,\n          padding\n        }).fn(state);\n      }\n      return {};\n    }\n  };\n};\nvar index = typeof document !== 'undefined' ? react__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_3__.useEffect;\n\n// Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (typeof a === 'function' && a.toString() === b.toString()) {\n    return true;\n  }\n  let length;\n  let i;\n  let keys;\n  if (a && b && typeof a === 'object') {\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length !== b.length) return false;\n      for (i = length; i-- !== 0;) {\n        if (!deepEqual(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) {\n      return false;\n    }\n    for (i = length; i-- !== 0;) {\n      if (!{}.hasOwnProperty.call(b, keys[i])) {\n        return false;\n      }\n    }\n    for (i = length; i-- !== 0;) {\n      const key = keys[i];\n      if (key === '_owner' && a.$$typeof) {\n        continue;\n      }\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // biome-ignore lint/suspicious/noSelfCompare: in source\n  return a !== a && b !== b;\n}\nfunction getDPR(element) {\n  if (true) {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\nfunction useLatestRef(value) {\n  const ref = react__WEBPACK_IMPORTED_MODULE_3__.useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\n/**\n * Provides data to position a floating element.\n * @see https://floating-ui.com/docs/useFloating\n */\nfunction useFloating(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform,\n    elements: {\n      reference: externalReference,\n      floating: externalFloating\n    } = {},\n    transform = true,\n    whileElementsMounted,\n    open\n  } = options;\n  const [data, setData] = react__WEBPACK_IMPORTED_MODULE_3__.useState({\n    x: 0,\n    y: 0,\n    strategy,\n    placement,\n    middlewareData: {},\n    isPositioned: false\n  });\n  const [latestMiddleware, setLatestMiddleware] = react__WEBPACK_IMPORTED_MODULE_3__.useState(middleware);\n  if (!deepEqual(latestMiddleware, middleware)) {\n    setLatestMiddleware(middleware);\n  }\n  const [_reference, _setReference] = react__WEBPACK_IMPORTED_MODULE_3__.useState(null);\n  const [_floating, _setFloating] = react__WEBPACK_IMPORTED_MODULE_3__.useState(null);\n  const setReference = react__WEBPACK_IMPORTED_MODULE_3__.useCallback(node => {\n    if (node !== referenceRef.current) {\n      referenceRef.current = node;\n      _setReference(node);\n    }\n  }, []);\n  const setFloating = react__WEBPACK_IMPORTED_MODULE_3__.useCallback(node => {\n    if (node !== floatingRef.current) {\n      floatingRef.current = node;\n      _setFloating(node);\n    }\n  }, []);\n  const referenceEl = externalReference || _reference;\n  const floatingEl = externalFloating || _floating;\n  const referenceRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(null);\n  const floatingRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(null);\n  const dataRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(data);\n  const hasWhileElementsMounted = whileElementsMounted != null;\n  const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n  const platformRef = useLatestRef(platform);\n  const update = react__WEBPACK_IMPORTED_MODULE_3__.useCallback(() => {\n    if (!referenceRef.current || !floatingRef.current) {\n      return;\n    }\n    const config = {\n      placement,\n      strategy,\n      middleware: latestMiddleware\n    };\n    if (platformRef.current) {\n      config.platform = platformRef.current;\n    }\n    (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.computePosition)(referenceRef.current, floatingRef.current, config).then(data => {\n      const fullData = _objectSpread(_objectSpread({}, data), {}, {\n        isPositioned: true\n      });\n      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n        dataRef.current = fullData;\n        react_dom__WEBPACK_IMPORTED_MODULE_4__.flushSync(() => {\n          setData(fullData);\n        });\n      }\n    });\n  }, [latestMiddleware, placement, strategy, platformRef]);\n  index(() => {\n    if (open === false && dataRef.current.isPositioned) {\n      dataRef.current.isPositioned = false;\n      setData(data => _objectSpread(_objectSpread({}, data), {}, {\n        isPositioned: false\n      }));\n    }\n  }, [open]);\n  const isMountedRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(false);\n  index(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: `hasWhileElementsMounted` is intentionally included.\n  index(() => {\n    if (referenceEl) referenceRef.current = referenceEl;\n    if (floatingEl) floatingRef.current = floatingEl;\n    if (referenceEl && floatingEl) {\n      if (whileElementsMountedRef.current) {\n        return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n      }\n      update();\n    }\n  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);\n  const refs = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(() => ({\n    reference: referenceRef,\n    floating: floatingRef,\n    setReference,\n    setFloating\n  }), [setReference, setFloating]);\n  const elements = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(() => ({\n    reference: referenceEl,\n    floating: floatingEl\n  }), [referenceEl, floatingEl]);\n  const floatingStyles = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(() => {\n    const initialStyles = {\n      position: strategy,\n      left: 0,\n      top: 0\n    };\n    if (!elements.floating) {\n      return initialStyles;\n    }\n    const x = roundByDPR(elements.floating, data.x);\n    const y = roundByDPR(elements.floating, data.y);\n    if (transform) {\n      return _objectSpread(_objectSpread({}, initialStyles), {}, {\n        transform: \"translate(\" + x + \"px, \" + y + \"px)\"\n      }, getDPR(elements.floating) >= 1.5 && {\n        willChange: 'transform'\n      });\n    }\n    return {\n      position: strategy,\n      left: x,\n      top: y\n    };\n  }, [strategy, transform, elements.floating, data.x, data.y]);\n  return react__WEBPACK_IMPORTED_MODULE_3__.useMemo(() => _objectSpread(_objectSpread({}, data), {}, {\n    update,\n    refs,\n    elements,\n    floatingStyles\n  }), [data, update, refs, elements, floatingStyles]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0LWRvbS9kaXN0L2Zsb2F0aW5nLXVpLnJlYWN0LWRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxRTtBQUM4RztBQUNwSjtBQUNvQjtBQUNiOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQSxLQUFLLEdBQUdtQixPQUFPLElBQUk7RUFDdkIsU0FBU0MsS0FBS0EsQ0FBQ0MsS0FBSyxFQUFFO0lBQ3BCLE9BQU8sQ0FBQyxDQUFDLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDRixLQUFLLEVBQUUsU0FBUyxDQUFDO0VBQ2pEO0VBQ0EsT0FBTztJQUNMRyxJQUFJLEVBQUUsT0FBTztJQUNiTCxPQUFPO0lBQ1BNLEVBQUVBLENBQUNDLEtBQUssRUFBRTtNQUNSLE1BQU07UUFDSkMsT0FBTztRQUNQQztNQUNGLENBQUMsR0FBRyxPQUFPVCxPQUFPLEtBQUssVUFBVSxHQUFHQSxPQUFPLENBQUNPLEtBQUssQ0FBQyxHQUFHUCxPQUFPO01BQzVELElBQUlRLE9BQU8sSUFBSVAsS0FBSyxDQUFDTyxPQUFPLENBQUMsRUFBRTtRQUM3QixJQUFJQSxPQUFPLENBQUNFLE9BQU8sSUFBSSxJQUFJLEVBQUU7VUFDM0IsT0FBTzVCLHVEQUFPLENBQUM7WUFDYjBCLE9BQU8sRUFBRUEsT0FBTyxDQUFDRSxPQUFPO1lBQ3hCRDtVQUNGLENBQUMsQ0FBQyxDQUFDSCxFQUFFLENBQUNDLEtBQUssQ0FBQztRQUNkO1FBQ0EsT0FBTyxDQUFDLENBQUM7TUFDWDtNQUNBLElBQUlDLE9BQU8sRUFBRTtRQUNYLE9BQU8xQix1REFBTyxDQUFDO1VBQ2IwQixPQUFPO1VBQ1BDO1FBQ0YsQ0FBQyxDQUFDLENBQUNILEVBQUUsQ0FBQ0MsS0FBSyxDQUFDO01BQ2Q7TUFDQSxPQUFPLENBQUMsQ0FBQztJQUNYO0VBQ0YsQ0FBQztBQUNILENBQUM7QUFFRCxJ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QyxNQUFBbUYsYUFBQSxDQUFBQSxhQUFBLEtBQ2hCN0IsSUFBSTtJQUNQeUIsTUFBTTtJQUNOTyxJQUFJO0lBQ0p4QyxRQUFRO0lBQ1IwQztFQUFjLEVBQ2QsRUFBRSxDQUFDbEMsSUFBSSxFQUFFeUIsTUFBTSxFQUFFTyxJQUFJLEVBQUV4QyxRQUFRLEVBQUUwQyxjQUFjLENBQUMsQ0FBQztBQUNyRCIsInNvdXJjZXMiOlsid2VicGFjazovL3EtZ2VuaWUvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0LWRvbS9kaXN0L2Zsb2F0aW5nLXVpLnJlYWN0LWRvbS5tanM/Yzc5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhcnJvdyBhcyBhcnJvdyQxLCBjb21wdXRlUG9zaXRpb24gfSBmcm9tICdAZmxvYXRpbmctdWkvZG9tJztcbmV4cG9ydCB7IGF1dG9QbGFjZW1lbnQsIGF1dG9VcGRhdGUsIGNvbXB1dGVQb3NpdGlvbiwgZGV0ZWN0T3ZlcmZsb3csIGZsaXAsIGdldE92ZXJmbG93QW5jZXN0b3JzLCBoaWRlLCBpbmxpbmUsIGxpbWl0U2hpZnQsIG9mZnNldCwgcGxhdGZvcm0sIHNoaWZ0LCBzaXplIH0gZnJvbSAnQGZsb2F0aW5nLXVpL2RvbSc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogVGhpcyB3cmFwcyB0aGUgY29yZSBgYXJyb3dgIG1pZGRsZXdhcmUgdG8gYWxsb3cgUmVhY3QgcmVmcyBhcyB0aGUgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hcnJvd1xuICovXG5jb25zdCBhcnJvdyA9IG9wdGlvbnMgPT4ge1xuICBmdW5jdGlvbiBpc1JlZih2YWx1ZSkge1xuICAgIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY3VycmVudCcpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2Fycm93JyxcbiAgICBvcHRpb25zLFxuICAgIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIHBhZGRpbmdcbiAgICAgIH0gPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMoc3RhdGUpIDogb3B0aW9ucztcbiAgICAgIGlmIChlbGVtZW50ICYmIGlzUmVmKGVsZW1lbnQpKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBhcnJvdyQxKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQuY3VycmVudCxcbiAgICAgICAgICAgIHBhZGRpbmdcbiAgICAgICAgICB9KS5mbihzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGFycm93JDEoe1xuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgcGFkZGluZ1xuICAgICAgICB9KS5mbihzdGF0ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxudmFyIGluZGV4ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxuLy8gRm9yayBvZiBgZmFzdC1kZWVwLWVxdWFsYCB0aGF0IG9ubHkgZG9lcyB0aGUgY29tcGFyaXNvbnMgd2UgbmVlZCBhbmQgY29tcGFyZXNcbi8vIGZ1bmN0aW9uc1xuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIGEgIT09IHR5cGVvZiBiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJyAmJiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGxldCBsZW5ndGg7XG4gIGxldCBpO1xuICBsZXQga2V5cztcbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICAgIGlmICghZGVlcEVxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChrZXkgPT09ICdfb3duZXInICYmIGEuJCR0eXBlb2YpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGJpb21lLWlnbm9yZSBsaW50L3N1c3BpY2lvdXMvbm9TZWxmQ29tcGFyZTogaW4gc291cmNlXG4gIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XG59XG5cbmZ1bmN0aW9uIGdldERQUihlbGVtZW50KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiAxO1xuICB9XG4gIGNvbnN0IHdpbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gIHJldHVybiB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xufVxuXG5mdW5jdGlvbiByb3VuZEJ5RFBSKGVsZW1lbnQsIHZhbHVlKSB7XG4gIGNvbnN0IGRwciA9IGdldERQUihlbGVtZW50KTtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBkcHIpIC8gZHByO1xufVxuXG5mdW5jdGlvbiB1c2VMYXRlc3RSZWYodmFsdWUpIHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKHZhbHVlKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVmO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gcG9zaXRpb24gYSBmbG9hdGluZyBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUZsb2F0aW5nXG4gKi9cbmZ1bmN0aW9uIHVzZUZsb2F0aW5nKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgcGxhY2VtZW50ID0gJ2JvdHRvbScsXG4gICAgc3RyYXRlZ3kgPSAnYWJzb2x1dGUnLFxuICAgIG1pZGRsZXdhcmUgPSBbXSxcbiAgICBwbGF0Zm9ybSxcbiAgICBlbGVtZW50czoge1xuICAgICAgcmVmZXJlbmNlOiBleHRlcm5hbFJlZmVyZW5jZSxcbiAgICAgIGZsb2F0aW5nOiBleHRlcm5hbEZsb2F0aW5nXG4gICAgfSA9IHt9LFxuICAgIHRyYW5zZm9ybSA9IHRydWUsXG4gICAgd2hpbGVFbGVtZW50c01vdW50ZWQsXG4gICAgb3BlblxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgW2RhdGEsIHNldERhdGFdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICBzdHJhdGVneSxcbiAgICBwbGFjZW1lbnQsXG4gICAgbWlkZGxld2FyZURhdGE6IHt9LFxuICAgIGlzUG9zaXRpb25lZDogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IFtsYXRlc3RNaWRkbGV3YXJlLCBzZXRMYXRlc3RNaWRkbGV3YXJlXSA9IFJlYWN0LnVzZVN0YXRlKG1pZGRsZXdhcmUpO1xuICBpZiAoIWRlZXBFcXVhbChsYXRlc3RNaWRkbGV3YXJlLCBtaWRkbGV3YXJlKSkge1xuICAgIHNldExhdGVzdE1pZGRsZXdhcmUobWlkZGxld2FyZSk7XG4gIH1cbiAgY29uc3QgW19yZWZlcmVuY2UsIF9zZXRSZWZlcmVuY2VdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtfZmxvYXRpbmcsIF9zZXRGbG9hdGluZ10gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3Qgc2V0UmVmZXJlbmNlID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgaWYgKG5vZGUgIT09IHJlZmVyZW5jZVJlZi5jdXJyZW50KSB7XG4gICAgICByZWZlcmVuY2VSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICBfc2V0UmVmZXJlbmNlKG5vZGUpO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCBzZXRGbG9hdGluZyA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGlmIChub2RlICE9PSBmbG9hdGluZ1JlZi5jdXJyZW50KSB7XG4gICAgICBmbG9hdGluZ1JlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgIF9zZXRGbG9hdGluZyhub2RlKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVmZXJlbmNlRWwgPSBleHRlcm5hbFJlZmVyZW5jZSB8fCBfcmVmZXJlbmNlO1xuICBjb25zdCBmbG9hdGluZ0VsID0gZXh0ZXJuYWxGbG9hdGluZyB8fCBfZmxvYXRpbmc7XG4gIGNvbnN0IHJlZmVyZW5jZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZmxvYXRpbmdSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGRhdGFSZWYgPSBSZWFjdC51c2VSZWYoZGF0YSk7XG4gIGNvbnN0IGhhc1doaWxlRWxlbWVudHNNb3VudGVkID0gd2hpbGVFbGVtZW50c01vdW50ZWQgIT0gbnVsbDtcbiAgY29uc3Qgd2hpbGVFbGVtZW50c01vdW50ZWRSZWYgPSB1c2VMYXRlc3RSZWYod2hpbGVFbGVtZW50c01vdW50ZWQpO1xuICBjb25zdCBwbGF0Zm9ybVJlZiA9IHVzZUxhdGVzdFJlZihwbGF0Zm9ybSk7XG4gIGNvbnN0IHVwZGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIXJlZmVyZW5jZVJlZi5jdXJyZW50IHx8ICFmbG9hdGluZ1JlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIHN0cmF0ZWd5LFxuICAgICAgbWlkZGxld2FyZTogbGF0ZXN0TWlkZGxld2FyZVxuICAgIH07XG4gICAgaWYgKHBsYXRmb3JtUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbmZpZy5wbGF0Zm9ybSA9IHBsYXRmb3JtUmVmLmN1cnJlbnQ7XG4gICAgfVxuICAgIGNvbXB1dGVQb3NpdGlvbihyZWZlcmVuY2VSZWYuY3VycmVudCwgZmxvYXRpbmdSZWYuY3VycmVudCwgY29uZmlnKS50aGVuKGRhdGEgPT4ge1xuICAgICAgY29uc3QgZnVsbERhdGEgPSB7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIGlzUG9zaXRpb25lZDogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGlmIChpc01vdW50ZWRSZWYuY3VycmVudCAmJiAhZGVlcEVxdWFsKGRhdGFSZWYuY3VycmVudCwgZnVsbERhdGEpKSB7XG4gICAgICAgIGRhdGFSZWYuY3VycmVudCA9IGZ1bGxEYXRhO1xuICAgICAgICBSZWFjdERPTS5mbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICAgIHNldERhdGEoZnVsbERhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW2xhdGVzdE1pZGRsZXdhcmUsIHBsYWNlbWVudCwgc3RyYXRlZ3ksIHBsYXRmb3JtUmVmXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAob3BlbiA9PT0gZmFsc2UgJiYgZGF0YVJlZi5jdXJyZW50LmlzUG9zaXRpb25lZCkge1xuICAgICAgZGF0YVJlZi5jdXJyZW50LmlzUG9zaXRpb25lZCA9IGZhbHNlO1xuICAgICAgc2V0RGF0YShkYXRhID0+ICh7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIGlzUG9zaXRpb25lZDogZmFsc2VcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIFtvcGVuXSk7XG4gIGNvbnN0IGlzTW91bnRlZFJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIC8vIGJpb21lLWlnbm9yZSBsaW50L2NvcnJlY3RuZXNzL3VzZUV4aGF1c3RpdmVEZXBlbmRlbmNpZXM6IGBoYXNXaGlsZUVsZW1lbnRzTW91bnRlZGAgaXMgaW50ZW50aW9uYWxseSBpbmNsdWRlZC5cbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChyZWZlcmVuY2VFbCkgcmVmZXJlbmNlUmVmLmN1cnJlbnQgPSByZWZlcmVuY2VFbDtcbiAgICBpZiAoZmxvYXRpbmdFbCkgZmxvYXRpbmdSZWYuY3VycmVudCA9IGZsb2F0aW5nRWw7XG4gICAgaWYgKHJlZmVyZW5jZUVsICYmIGZsb2F0aW5nRWwpIHtcbiAgICAgIGlmICh3aGlsZUVsZW1lbnRzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybiB3aGlsZUVsZW1lbnRzTW91bnRlZFJlZi5jdXJyZW50KHJlZmVyZW5jZUVsLCBmbG9hdGluZ0VsLCB1cGRhdGUpO1xuICAgICAgfVxuICAgICAgdXBkYXRlKCk7XG4gICAgfVxuICB9LCBbcmVmZXJlbmNlRWwsIGZsb2F0aW5nRWwsIHVwZGF0ZSwgd2hpbGVFbGVtZW50c01vdW50ZWRSZWYsIGhhc1doaWxlRWxlbWVudHNNb3VudGVkXSk7XG4gIGNvbnN0IHJlZnMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VSZWYsXG4gICAgZmxvYXRpbmc6IGZsb2F0aW5nUmVmLFxuICAgIHNldFJlZmVyZW5jZSxcbiAgICBzZXRGbG9hdGluZ1xuICB9KSwgW3NldFJlZmVyZW5jZSwgc2V0RmxvYXRpbmddKTtcbiAgY29uc3QgZWxlbWVudHMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VFbCxcbiAgICBmbG9hdGluZzogZmxvYXRpbmdFbFxuICB9KSwgW3JlZmVyZW5jZUVsLCBmbG9hdGluZ0VsXSk7XG4gIGNvbnN0IGZsb2F0aW5nU3R5bGVzID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICAgIHBvc2l0aW9uOiBzdHJhdGVneSxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDBcbiAgICB9O1xuICAgIGlmICghZWxlbWVudHMuZmxvYXRpbmcpIHtcbiAgICAgIHJldHVybiBpbml0aWFsU3R5bGVzO1xuICAgIH1cbiAgICBjb25zdCB4ID0gcm91bmRCeURQUihlbGVtZW50cy5mbG9hdGluZywgZGF0YS54KTtcbiAgICBjb25zdCB5ID0gcm91bmRCeURQUihlbGVtZW50cy5mbG9hdGluZywgZGF0YS55KTtcbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5pbml0aWFsU3R5bGVzLFxuICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgpXCIsXG4gICAgICAgIC4uLihnZXREUFIoZWxlbWVudHMuZmxvYXRpbmcpID49IDEuNSAmJiB7XG4gICAgICAgICAgd2lsbENoYW5nZTogJ3RyYW5zZm9ybSdcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiB4LFxuICAgICAgdG9wOiB5XG4gICAgfTtcbiAgfSwgW3N0cmF0ZWd5LCB0cmFuc2Zvcm0sIGVsZW1lbnRzLmZsb2F0aW5nLCBkYXRhLngsIGRhdGEueV0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLmRhdGEsXG4gICAgdXBkYXRlLFxuICAgIHJlZnMsXG4gICAgZWxlbWVudHMsXG4gICAgZmxvYXRpbmdTdHlsZXNcbiAgfSksIFtkYXRhLCB1cGRhdGUsIHJlZnMsIGVsZW1lbnRzLCBmbG9hdGluZ1N0eWxlc10pO1xufVxuXG5leHBvcnQgeyBhcnJvdywgdXNlRmxvYXRpbmcgfTtcbiJdLCJuYW1lcyI6WyJhcnJvdyIsImFycm93JDEiLCJjb21wdXRlUG9zaXRpb24iLCJhdXRvUGxhY2VtZW50IiwiYXV0b1VwZGF0ZSIsImRldGVjdE92ZXJmbG93IiwiZmxpcCIsImdldE92ZXJmbG93QW5jZXN0b3JzIiwiaGlkZSIsImlubGluZSIsImxpbWl0U2hpZnQiLCJvZmZzZXQiLCJwbGF0Zm9ybSIsInNoaWZ0Iiwic2l6ZSIsIlJlYWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwiUmVhY3RET00iLCJvcHRpb25zIiwiaXNSZWYiLCJ2YWx1ZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIm5hbWUiLCJmbiIsInN0YXRlIiwiZWxlbWVudCIsInBhZGRpbmciLCJjdXJyZW50IiwiaW5kZXgiLCJkb2N1bWVudCIsImRlZXBFcXVhbCIsImEiLCJiIiwidG9TdHJpbmciLCJsZW5ndGgiLCJpIiwia2V5cyIsIkFycmF5IiwiaXNBcnJheSIsIk9iamVjdCIsImtleSIsIiQkdHlwZW9mIiwiZ2V0RFBSIiwid2luIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3Iiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsInJvdW5kQnlEUFIiLCJkcHIiLCJNYXRoIiwicm91bmQiLCJ1c2VMYXRlc3RSZWYiLCJyZWYiLCJ1c2VSZWYiLCJ1c2VGbG9hdGluZyIsInBsYWNlbWVudCIsInN0cmF0ZWd5IiwibWlkZGxld2FyZSIsImVsZW1lbnRzIiwicmVmZXJlbmNlIiwiZXh0ZXJuYWxSZWZlcmVuY2UiLCJmbG9hdGluZyIsImV4dGVybmFsRmxvYXRpbmciLCJ0cmFuc2Zvcm0iLCJ3aGlsZUVsZW1lbnRzTW91bnRlZCIsIm9wZW4iLCJkYXRhIiwic2V0RGF0YSIsInVzZVN0YXRlIiwieCIsInkiLCJtaWRkbGV3YXJlRGF0YSIsImlzUG9zaXRpb25lZCIsImxhdGVzdE1pZGRsZXdhcmUiLCJzZXRMYXRlc3RNaWRkbGV3YXJlIiwiX3JlZmVyZW5jZSIsIl9zZXRSZWZlcmVuY2UiLCJfZmxvYXRpbmciLCJfc2V0RmxvYXRpbmciLCJzZXRSZWZlcmVuY2UiLCJ1c2VDYWxsYmFjayIsIm5vZGUiLCJyZWZlcmVuY2VSZWYiLCJzZXRGbG9hdGluZyIsImZsb2F0aW5nUmVmIiwicmVmZXJlbmNlRWwiLCJmbG9hdGluZ0VsIiwiZGF0YVJlZiIsImhhc1doaWxlRWxlbWVudHNNb3VudGVkIiwid2hpbGVFbGVtZW50c01vdW50ZWRSZWYiLCJwbGF0Zm9ybVJlZiIsInVwZGF0ZSIsImNvbmZpZyIsInRoZW4iLCJmdWxsRGF0YSIsIl9vYmplY3RTcHJlYWQiLCJpc01vdW50ZWRSZWYiLCJmbHVzaFN5bmMiLCJyZWZzIiwidXNlTWVtbyIsImZsb2F0aW5nU3R5bGVzIiwiaW5pdGlhbFN0eWxlcyIsInBvc2l0aW9uIiwibGVmdCIsInRvcCIsIndpbGxDaGFuZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@floating-ui/react/dist/floating-ui.react.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Composite: () => (/* binding */ Composite),\n/* harmony export */   CompositeItem: () => (/* binding */ CompositeItem),\n/* harmony export */   FloatingArrow: () => (/* binding */ FloatingArrow),\n/* harmony export */   FloatingDelayGroup: () => (/* binding */ FloatingDelayGroup),\n/* harmony export */   FloatingFocusManager: () => (/* binding */ FloatingFocusManager),\n/* harmony export */   FloatingList: () => (/* binding */ FloatingList),\n/* harmony export */   FloatingNode: () => (/* binding */ FloatingNode),\n/* harmony export */   FloatingOverlay: () => (/* binding */ FloatingOverlay),\n/* harmony export */   FloatingPortal: () => (/* binding */ FloatingPortal),\n/* harmony export */   FloatingTree: () => (/* binding */ FloatingTree),\n/* harmony export */   arrow: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.arrow),\n/* harmony export */   autoPlacement: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.autoPlacement),\n/* harmony export */   autoUpdate: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.autoUpdate),\n/* harmony export */   computePosition: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.detectOverflow),\n/* harmony export */   flip: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.hide),\n/* harmony export */   inline: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.inline),\n/* harmony export */   inner: () => (/* binding */ inner),\n/* harmony export */   limitShift: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.offset),\n/* harmony export */   platform: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.platform),\n/* harmony export */   safePolygon: () => (/* binding */ safePolygon),\n/* harmony export */   shift: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.shift),\n/* harmony export */   size: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.size),\n/* harmony export */   useClick: () => (/* binding */ useClick),\n/* harmony export */   useClientPoint: () => (/* binding */ useClientPoint),\n/* harmony export */   useDelayGroup: () => (/* binding */ useDelayGroup),\n/* harmony export */   useDelayGroupContext: () => (/* binding */ useDelayGroupContext),\n/* harmony export */   useDismiss: () => (/* binding */ useDismiss),\n/* harmony export */   useFloating: () => (/* binding */ useFloating),\n/* harmony export */   useFloatingNodeId: () => (/* binding */ useFloatingNodeId),\n/* harmony export */   useFloatingParentNodeId: () => (/* binding */ useFloatingParentNodeId),\n/* harmony export */   useFloatingPortalNode: () => (/* binding */ useFloatingPortalNode),\n/* harmony export */   useFloatingTree: () => (/* binding */ useFloatingTree),\n/* harmony export */   useFocus: () => (/* binding */ useFocus),\n/* harmony export */   useHover: () => (/* binding */ useHover),\n/* harmony export */   useId: () => (/* binding */ useId),\n/* harmony export */   useInnerOffset: () => (/* binding */ useInnerOffset),\n/* harmony export */   useInteractions: () => (/* binding */ useInteractions),\n/* harmony export */   useListItem: () => (/* binding */ useListItem),\n/* harmony export */   useListNavigation: () => (/* binding */ useListNavigation),\n/* harmony export */   useMergeRefs: () => (/* binding */ useMergeRefs),\n/* harmony export */   useRole: () => (/* binding */ useRole),\n/* harmony export */   useTransitionStatus: () => (/* binding */ useTransitionStatus),\n/* harmony export */   useTransitionStyles: () => (/* binding */ useTransitionStyles),\n/* harmony export */   useTypeahead: () => (/* binding */ useTypeahead)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @floating-ui/react/utils */ \"(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs\");\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var tabbable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! tabbable */ \"(ssr)/./node_modules/tabbable/dist/index.esm.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\nconst _excluded = [\"render\", \"orientation\", \"loop\", \"cols\", \"disabledIndices\", \"activeIndex\", \"onNavigate\", \"itemSizes\", \"dense\"],\n  _excluded2 = [\"render\"],\n  _excluded3 = [\"transform\"],\n  _excluded4 = [\"context\", \"width\", \"height\", \"tipRadius\", \"strokeWidth\", \"staticOffset\", \"stroke\", \"d\", \"style\"],\n  _excluded5 = [\"lockScroll\"],\n  _excluded6 = [\"listRef\", \"overflowRef\", \"onFallbackChange\", \"offset\", \"index\", \"minItemsVisible\", \"referenceOverflowThreshold\", \"scrollRef\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n\n\n\n\n\n\n\n\n\n/**\n * Merges an array of refs into a single memoized callback ref or `null`.\n * @see https://floating-ui.com/docs/react-utils#usemergerefs\n */\nfunction useMergeRefs(refs) {\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (refs.every(ref => ref == null)) {\n      return null;\n    }\n    return value => {\n      refs.forEach(ref => {\n        if (typeof ref === 'function') {\n          ref(value);\n        } else if (ref != null) {\n          ref.current = value;\n        }\n      });\n    };\n  }, refs);\n}\n\n// `toString()` prevents bundlers from trying to `import { useInsertionEffect } from 'react'`\nconst useInsertionEffect = /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))[/*#__PURE__*/'useInsertionEffect'.toString()];\nconst useSafeInsertionEffect = useInsertionEffect || (fn => fn());\nfunction useEffectEvent(callback) {\n  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(() => {\n    if (true) {\n      throw new Error('Cannot call an event handler while rendering.');\n    }\n  });\n  useSafeInsertionEffect(() => {\n    ref.current = callback;\n  });\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return ref.current == null ? void 0 : ref.current(...args);\n  }, []);\n}\nconst ARROW_UP = 'ArrowUp';\nconst ARROW_DOWN = 'ArrowDown';\nconst ARROW_LEFT = 'ArrowLeft';\nconst ARROW_RIGHT = 'ArrowRight';\nfunction isDifferentRow(index, cols, prevRow) {\n  return Math.floor(index / cols) !== prevRow;\n}\nfunction isIndexOutOfBounds(listRef, index) {\n  return index < 0 || index >= listRef.current.length;\n}\nfunction getMinIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    disabledIndices\n  });\n}\nfunction getMaxIndex(listRef, disabledIndices) {\n  return findNonDisabledIndex(listRef, {\n    decrement: true,\n    startingIndex: listRef.current.length,\n    disabledIndices\n  });\n}\nfunction findNonDisabledIndex(listRef, _temp) {\n  let {\n    startingIndex = -1,\n    decrement = false,\n    disabledIndices,\n    amount = 1\n  } = _temp === void 0 ? {} : _temp;\n  const list = listRef.current;\n  const isDisabledIndex = disabledIndices ? index => disabledIndices.includes(index) : index => {\n    const element = list[index];\n    return element == null || element.hasAttribute('disabled') || element.getAttribute('aria-disabled') === 'true';\n  };\n  let index = startingIndex;\n  do {\n    index += decrement ? -amount : amount;\n  } while (index >= 0 && index <= list.length - 1 && isDisabledIndex(index));\n  return index;\n}\nfunction getGridNavigatedIndex(elementsRef, _ref) {\n  let {\n    event,\n    orientation,\n    loop,\n    cols,\n    disabledIndices,\n    minIndex,\n    maxIndex,\n    prevIndex,\n    stopEvent: stop = false\n  } = _ref;\n  let nextIndex = prevIndex;\n  if (event.key === ARROW_UP) {\n    stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n    if (prevIndex === -1) {\n      nextIndex = maxIndex;\n    } else {\n      nextIndex = findNonDisabledIndex(elementsRef, {\n        startingIndex: nextIndex,\n        amount: cols,\n        decrement: true,\n        disabledIndices\n      });\n      if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {\n        const col = prevIndex % cols;\n        const maxCol = maxIndex % cols;\n        const offset = maxIndex - (maxCol - col);\n        if (maxCol === col) {\n          nextIndex = maxIndex;\n        } else {\n          nextIndex = maxCol > col ? offset : offset - cols;\n        }\n      }\n    }\n    if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n      nextIndex = prevIndex;\n    }\n  }\n  if (event.key === ARROW_DOWN) {\n    stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n    if (prevIndex === -1) {\n      nextIndex = minIndex;\n    } else {\n      nextIndex = findNonDisabledIndex(elementsRef, {\n        startingIndex: prevIndex,\n        amount: cols,\n        disabledIndices\n      });\n      if (loop && prevIndex + cols > maxIndex) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex % cols - cols,\n          amount: cols,\n          disabledIndices\n        });\n      }\n    }\n    if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n      nextIndex = prevIndex;\n    }\n  }\n\n  // Remains on the same row/column.\n  if (orientation === 'both') {\n    const prevRow = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_7__.floor)(prevIndex / cols);\n    if (event.key === ARROW_RIGHT) {\n      stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n      if (prevIndex % cols !== cols - 1) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex,\n          disabledIndices\n        });\n        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {\n          nextIndex = findNonDisabledIndex(elementsRef, {\n            startingIndex: prevIndex - prevIndex % cols - 1,\n            disabledIndices\n          });\n        }\n      } else if (loop) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex - prevIndex % cols - 1,\n          disabledIndices\n        });\n      }\n      if (isDifferentRow(nextIndex, cols, prevRow)) {\n        nextIndex = prevIndex;\n      }\n    }\n    if (event.key === ARROW_LEFT) {\n      stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n      if (prevIndex % cols !== 0) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex,\n          disabledIndices,\n          decrement: true\n        });\n        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {\n          nextIndex = findNonDisabledIndex(elementsRef, {\n            startingIndex: prevIndex + (cols - prevIndex % cols),\n            decrement: true,\n            disabledIndices\n          });\n        }\n      } else if (loop) {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex + (cols - prevIndex % cols),\n          decrement: true,\n          disabledIndices\n        });\n      }\n      if (isDifferentRow(nextIndex, cols, prevRow)) {\n        nextIndex = prevIndex;\n      }\n    }\n    const lastRow = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_7__.floor)(maxIndex / cols) === prevRow;\n    if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n      if (loop && lastRow) {\n        nextIndex = event.key === ARROW_LEFT ? maxIndex : findNonDisabledIndex(elementsRef, {\n          startingIndex: prevIndex - prevIndex % cols - 1,\n          disabledIndices\n        });\n      } else {\n        nextIndex = prevIndex;\n      }\n    }\n  }\n  return nextIndex;\n}\n\n/** For each cell index, gets the item index that occupies that cell */\nfunction buildCellMap(sizes, cols, dense) {\n  const cellMap = [];\n  let startIndex = 0;\n  sizes.forEach((_ref2, index) => {\n    let {\n      width,\n      height\n    } = _ref2;\n    if (width > cols) {\n      if (true) {\n        throw new Error(\"[Floating UI]: Invalid grid - item width at index \" + index + \" is greater than grid columns\");\n      }\n    }\n    let itemPlaced = false;\n    if (dense) {\n      startIndex = 0;\n    }\n    while (!itemPlaced) {\n      const targetCells = [];\n      for (let i = 0; i < width; i++) {\n        for (let j = 0; j < height; j++) {\n          targetCells.push(startIndex + i + j * cols);\n        }\n      }\n      if (startIndex % cols + width <= cols && targetCells.every(cell => cellMap[cell] == null)) {\n        targetCells.forEach(cell => {\n          cellMap[cell] = index;\n        });\n        itemPlaced = true;\n      } else {\n        startIndex++;\n      }\n    }\n  });\n\n  // convert into a non-sparse array\n  return [...cellMap];\n}\n\n/** Gets cell index of an item's corner or -1 when index is -1. */\nfunction getCellIndexOfCorner(index, sizes, cellMap, cols, corner) {\n  if (index === -1) return -1;\n  const firstCellIndex = cellMap.indexOf(index);\n  switch (corner) {\n    case 'tl':\n      return firstCellIndex;\n    case 'tr':\n      return firstCellIndex + sizes[index].width - 1;\n    case 'bl':\n      return firstCellIndex + (sizes[index].height - 1) * cols;\n    case 'br':\n      return cellMap.lastIndexOf(index);\n  }\n}\n\n/** Gets all cell indices that correspond to the specified indices */\nfunction getCellIndices(indices, cellMap) {\n  return cellMap.flatMap((index, cellIndex) => indices.includes(index) ? [cellIndex] : []);\n}\nlet rafId = 0;\nfunction enqueueFocus(el, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    preventScroll = false,\n    cancelPrevious = true,\n    sync = false\n  } = options;\n  cancelPrevious && cancelAnimationFrame(rafId);\n  const exec = () => el == null ? void 0 : el.focus({\n    preventScroll\n  });\n  if (sync) {\n    exec();\n  } else {\n    rafId = requestAnimationFrame(exec);\n  }\n}\nvar index = typeof document !== 'undefined' ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction sortByDocumentPosition(a, b) {\n  const position = a.compareDocumentPosition(b);\n  if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n    return -1;\n  }\n  if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {\n    return 1;\n  }\n  return 0;\n}\nfunction areMapsEqual(map1, map2) {\n  if (map1.size !== map2.size) {\n    return false;\n  }\n  for (const [key, value] of map1.entries()) {\n    if (value !== map2.get(key)) {\n      return false;\n    }\n  }\n  return true;\n}\nconst FloatingListContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  register: () => {},\n  unregister: () => {},\n  map: /*#__PURE__*/new Map(),\n  elementsRef: {\n    current: []\n  }\n});\n/**\n * Provides context for a list of items within the floating element.\n * @see https://floating-ui.com/docs/FloatingList\n */\nfunction FloatingList(_ref) {\n  let {\n    children,\n    elementsRef,\n    labelsRef\n  } = _ref;\n  const [map, setMap] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => new Map());\n  const register = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    setMap(prevMap => new Map(prevMap).set(node, null));\n  }, []);\n  const unregister = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    setMap(prevMap => {\n      const map = new Map(prevMap);\n      map.delete(node);\n      return map;\n    });\n  }, []);\n  index(() => {\n    const newMap = new Map(map);\n    const nodes = Array.from(newMap.keys()).sort(sortByDocumentPosition);\n    nodes.forEach((node, index) => {\n      newMap.set(node, index);\n    });\n    if (!areMapsEqual(map, newMap)) {\n      setMap(newMap);\n    }\n  }, [map]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingListContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      register,\n      unregister,\n      map,\n      elementsRef,\n      labelsRef\n    }), [register, unregister, map, elementsRef, labelsRef])\n  }, children);\n}\n/**\n * Used to register a list item and its index (DOM position) in the\n * `FloatingList`.\n * @see https://floating-ui.com/docs/FloatingList#uselistitem\n */\nfunction useListItem(_temp) {\n  let {\n    label\n  } = _temp === void 0 ? {} : _temp;\n  const [index$1, setIndex] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n  const componentRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const {\n    register,\n    unregister,\n    map,\n    elementsRef,\n    labelsRef\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingListContext);\n  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    componentRef.current = node;\n    if (index$1 !== null) {\n      elementsRef.current[index$1] = node;\n      if (labelsRef) {\n        var _node$textContent;\n        const isLabelDefined = label !== undefined;\n        labelsRef.current[index$1] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;\n      }\n    }\n  }, [index$1, elementsRef, labelsRef, label]);\n  index(() => {\n    const node = componentRef.current;\n    if (node) {\n      register(node);\n      return () => {\n        unregister(node);\n      };\n    }\n  }, [register, unregister]);\n  index(() => {\n    const index = componentRef.current ? map.get(componentRef.current) : null;\n    if (index != null) {\n      setIndex(index);\n    }\n  }, [map]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    ref,\n    index: index$1 == null ? -1 : index$1\n  }), [index$1, ref]);\n}\nfunction renderJsx(render, computedProps) {\n  if (typeof render === 'function') {\n    return render(computedProps);\n  }\n  if (render) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(render, computedProps);\n  }\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", computedProps);\n}\nconst CompositeContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  activeIndex: 0,\n  onNavigate: () => {}\n});\nconst horizontalKeys = [ARROW_LEFT, ARROW_RIGHT];\nconst verticalKeys = [ARROW_UP, ARROW_DOWN];\nconst allKeys = [...horizontalKeys, ...verticalKeys];\n\n/**\n * Creates a single tab stop whose items are navigated by arrow keys, which\n * provides list navigation outside of floating element contexts.\n *\n * This is useful to enable navigation of a list of items that aren’t part of a\n * floating element. A menubar is an example of a composite, with each reference\n * element being an item.\n * @see https://floating-ui.com/docs/Composite\n */\nconst Composite = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function Composite(_ref, forwardedRef) {\n  let {\n      render,\n      orientation = 'both',\n      loop = true,\n      cols = 1,\n      disabledIndices = [],\n      activeIndex: externalActiveIndex,\n      onNavigate: externalSetActiveIndex,\n      itemSizes,\n      dense = false\n    } = _ref,\n    props = _objectWithoutProperties(_ref, _excluded);\n  const [internalActiveIndex, internalSetActiveIndex] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);\n  const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;\n  const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);\n  const elementsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);\n  const renderElementProps = render && typeof render !== 'function' ? render.props : {};\n  const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    activeIndex,\n    onNavigate\n  }), [activeIndex, onNavigate]);\n  const isGrid = cols > 1;\n  function handleKeyDown(event) {\n    if (!allKeys.includes(event.key)) return;\n    let nextIndex = activeIndex;\n    if (isGrid) {\n      const sizes = itemSizes || Array.from({\n        length: elementsRef.current.length\n      }, () => ({\n        width: 1,\n        height: 1\n      }));\n      // To calculate movements on the grid, we use hypothetical cell indices\n      // as if every item was 1x1, then convert back to real indices.\n      const cellMap = buildCellMap(sizes, cols, dense);\n      const minGridIndex = cellMap.findIndex(index => index != null && !disabledIndices.includes(index));\n      // last enabled index\n      const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !(disabledIndices != null && disabledIndices.includes(index)) ? cellIndex : foundIndex, -1);\n      nextIndex = cellMap[getGridNavigatedIndex({\n        current: cellMap.map(itemIndex => itemIndex ? elementsRef.current[itemIndex] : null)\n      }, {\n        event,\n        orientation,\n        loop,\n        cols,\n        // treat undefined (empty grid spaces) as disabled indices so we\n        // don't end up in them\n        disabledIndices: getCellIndices([...disabledIndices, undefined], cellMap),\n        minIndex: minGridIndex,\n        maxIndex: maxGridIndex,\n        prevIndex: getCellIndexOfCorner(activeIndex, sizes, cellMap, cols,\n        // use a corner matching the edge closest to the direction we're\n        // moving in so we don't end up in the same item. Prefer\n        // top/left over bottom/right.\n        event.key === ARROW_DOWN ? 'bl' : event.key === ARROW_RIGHT ? 'tr' : 'tl')\n      })]; // navigated cell will never be nullish\n    }\n\n    const minIndex = getMinIndex(elementsRef, disabledIndices);\n    const maxIndex = getMaxIndex(elementsRef, disabledIndices);\n    const toEndKeys = {\n      horizontal: [ARROW_RIGHT],\n      vertical: [ARROW_DOWN],\n      both: [ARROW_RIGHT, ARROW_DOWN]\n    }[orientation];\n    const toStartKeys = {\n      horizontal: [ARROW_LEFT],\n      vertical: [ARROW_UP],\n      both: [ARROW_LEFT, ARROW_UP]\n    }[orientation];\n    const preventedKeys = isGrid ? allKeys : {\n      horizontal: horizontalKeys,\n      vertical: verticalKeys,\n      both: allKeys\n    }[orientation];\n    if (nextIndex === activeIndex && [...toEndKeys, ...toStartKeys].includes(event.key)) {\n      if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {\n        nextIndex = minIndex;\n      } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {\n        nextIndex = maxIndex;\n      } else {\n        nextIndex = findNonDisabledIndex(elementsRef, {\n          startingIndex: nextIndex,\n          decrement: toStartKeys.includes(event.key),\n          disabledIndices\n        });\n      }\n    }\n    if (nextIndex !== activeIndex && !isIndexOutOfBounds(elementsRef, nextIndex)) {\n      event.stopPropagation();\n      if (preventedKeys.includes(event.key)) {\n        event.preventDefault();\n      }\n      onNavigate(nextIndex);\n\n      // Wait for FocusManager `returnFocus` to execute.\n      queueMicrotask(() => {\n        enqueueFocus(elementsRef.current[nextIndex]);\n      });\n    }\n  }\n  const computedProps = _objectSpread(_objectSpread(_objectSpread({}, props), renderElementProps), {}, {\n    ref: forwardedRef,\n    'aria-orientation': orientation === 'both' ? undefined : orientation,\n    onKeyDown(e) {\n      props.onKeyDown == null || props.onKeyDown(e);\n      renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e);\n      handleKeyDown(e);\n    }\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(CompositeContext.Provider, {\n    value: contextValue\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingList, {\n    elementsRef: elementsRef\n  }, renderJsx(render, computedProps)));\n});\n/**\n * @see https://floating-ui.com/docs/Composite\n */\nconst CompositeItem = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function CompositeItem(_ref2, forwardedRef) {\n  let {\n      render\n    } = _ref2,\n    props = _objectWithoutProperties(_ref2, _excluded2);\n  const renderElementProps = render && typeof render !== 'function' ? render.props : {};\n  const {\n    activeIndex,\n    onNavigate\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CompositeContext);\n  const {\n    ref,\n    index\n  } = useListItem();\n  const mergedRef = useMergeRefs([ref, forwardedRef, renderElementProps.ref]);\n  const isActive = activeIndex === index;\n  const computedProps = _objectSpread(_objectSpread(_objectSpread({}, props), renderElementProps), {}, {\n    ref: mergedRef,\n    tabIndex: isActive ? 0 : -1,\n    'data-active': isActive ? '' : undefined,\n    onFocus(e) {\n      props.onFocus == null || props.onFocus(e);\n      renderElementProps.onFocus == null || renderElementProps.onFocus(e);\n      onNavigate(index);\n    }\n  });\n  return renderJsx(render, computedProps);\n});\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nlet serverHandoffComplete = false;\nlet count = 0;\nconst genId = () => \"floating-ui-\" + count++;\nfunction useFloatingId() {\n  const [id, setId] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => serverHandoffComplete ? genId() : undefined);\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n  index(() => {\n    if (id == null) {\n      setId(genId());\n    }\n  }, []);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!serverHandoffComplete) {\n      serverHandoffComplete = true;\n    }\n  }, []);\n  return id;\n}\n\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useReactId = /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))[/*#__PURE__*/'useId'.toString()];\n\n/**\n * Uses React 18's built-in `useId()` when available, or falls back to a\n * slightly less performant (requiring a double render) implementation for\n * earlier React versions.\n * @see https://floating-ui.com/docs/react-utils#useid\n */\nconst useId = useReactId || useFloatingId;\n\n/**\n * Renders a pointing arrow triangle.\n * @see https://floating-ui.com/docs/FloatingArrow\n */\nconst FloatingArrow = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FloatingArrow(_ref, ref) {\n  let {\n      context: {\n        placement,\n        elements: {\n          floating\n        },\n        middlewareData: {\n          arrow\n        }\n      },\n      width = 14,\n      height = 7,\n      tipRadius = 0,\n      strokeWidth = 0,\n      staticOffset,\n      stroke,\n      d,\n      style: {\n        transform\n      } = {}\n    } = _ref,\n    restStyle = _objectWithoutProperties(_ref.style, _excluded3),\n    rest = _objectWithoutProperties(_ref, _excluded4);\n  if (true) {\n    if (!ref) {\n      console.warn('Floating UI: The `ref` prop is required for the `FloatingArrow`', 'component.');\n    }\n  }\n  const clipPathId = useId();\n  if (!floating) {\n    return null;\n  }\n\n  // Strokes must be double the border width, this ensures the stroke's width\n  // works as you'd expect.\n  strokeWidth *= 2;\n  const halfStrokeWidth = strokeWidth / 2;\n  const svgX = width / 2 * (tipRadius / -8 + 1);\n  const svgY = height / 2 * tipRadius / 4;\n  const [side, alignment] = placement.split('-');\n  const isRTL = _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.platform.isRTL(floating);\n  const isCustomShape = !!d;\n  const isVerticalSide = side === 'top' || side === 'bottom';\n  const yOffsetProp = staticOffset && alignment === 'end' ? 'bottom' : 'top';\n  let xOffsetProp = staticOffset && alignment === 'end' ? 'right' : 'left';\n  if (staticOffset && isRTL) {\n    xOffsetProp = alignment === 'end' ? 'left' : 'right';\n  }\n  const arrowX = (arrow == null ? void 0 : arrow.x) != null ? staticOffset || arrow.x : '';\n  const arrowY = (arrow == null ? void 0 : arrow.y) != null ? staticOffset || arrow.y : '';\n  const dValue = d ||\n  // biome-ignore lint/style/useTemplate: readability\n  'M0,0' + (\" H\" + width) + (\" L\" + (width - svgX) + \",\" + (height - svgY)) + (\" Q\" + width / 2 + \",\" + height + \" \" + svgX + \",\" + (height - svgY)) + ' Z';\n  const rotation = {\n    top: isCustomShape ? 'rotate(180deg)' : '',\n    left: isCustomShape ? 'rotate(90deg)' : 'rotate(-90deg)',\n    bottom: isCustomShape ? '' : 'rotate(180deg)',\n    right: isCustomShape ? 'rotate(-90deg)' : 'rotate(90deg)'\n  }[side];\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", _extends({}, rest, {\n    \"aria-hidden\": true,\n    ref: ref,\n    width: isCustomShape ? width : width + strokeWidth,\n    height: width,\n    viewBox: \"0 0 \" + width + \" \" + (height > width ? height : width),\n    style: _objectSpread({\n      position: 'absolute',\n      pointerEvents: 'none',\n      [xOffsetProp]: arrowX,\n      [yOffsetProp]: arrowY,\n      [side]: isVerticalSide || isCustomShape ? '100%' : \"calc(100% - \" + strokeWidth / 2 + \"px)\",\n      transform: \"\" + rotation + (transform != null ? transform : '')\n    }, restStyle)\n  }), strokeWidth > 0 && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    clipPath: \"url(#\" + clipPathId + \")\",\n    fill: \"none\",\n    stroke: stroke\n    // Account for the stroke on the fill path rendered below.\n    ,\n\n    strokeWidth: strokeWidth + (d ? 0 : 1),\n    d: dValue\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    stroke: strokeWidth && !d ? rest.fill : 'none',\n    d: dValue\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"clipPath\", {\n    id: clipPathId\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n    x: -halfStrokeWidth,\n    y: halfStrokeWidth * (isCustomShape ? -1 : 1),\n    width: width + strokeWidth,\n    height: width\n  })));\n});\nfunction createPubSub() {\n  const map = new Map();\n  return {\n    emit(event, data) {\n      var _map$get;\n      (_map$get = map.get(event)) == null || _map$get.forEach(handler => handler(data));\n    },\n    on(event, listener) {\n      map.set(event, [...(map.get(event) || []), listener]);\n    },\n    off(event, listener) {\n      var _map$get2;\n      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter(l => l !== listener)) || []);\n    }\n  };\n}\nconst FloatingNodeContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst FloatingTreeContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n\n/**\n * Returns the parent node id for nested floating elements, if available.\n * Returns `null` for top-level floating elements.\n */\nconst useFloatingParentNodeId = () => {\n  var _React$useContext;\n  return ((_React$useContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;\n};\n\n/**\n * Returns the nearest floating tree context, if available.\n */\nconst useFloatingTree = () => react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingTreeContext);\n\n/**\n * Registers a node into the `FloatingTree`, returning its id.\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction useFloatingNodeId(customParentId) {\n  const id = useId();\n  const tree = useFloatingTree();\n  const reactParentId = useFloatingParentNodeId();\n  const parentId = customParentId || reactParentId;\n  index(() => {\n    const node = {\n      id,\n      parentId\n    };\n    tree == null || tree.addNode(node);\n    return () => {\n      tree == null || tree.removeNode(node);\n    };\n  }, [tree, id, parentId]);\n  return id;\n}\n\n/**\n * Provides parent node context for nested floating elements.\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction FloatingNode(_ref) {\n  let {\n    children,\n    id\n  } = _ref;\n  const parentId = useFloatingParentNodeId();\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingNodeContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      id,\n      parentId\n    }), [id, parentId])\n  }, children);\n}\n\n/**\n * Provides context for nested floating elements when they are not children of\n * each other on the DOM.\n * This is not necessary in all cases, except when there must be explicit communication between parent and child floating elements. It is necessary for:\n * - The `bubbles` option in the `useDismiss()` Hook\n * - Nested virtual list navigation\n * - Nested floating elements that each open on hover\n * - Custom communication between parent and child floating elements\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction FloatingTree(_ref2) {\n  let {\n    children\n  } = _ref2;\n  const nodesRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);\n  const addNode = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    nodesRef.current = [...nodesRef.current, node];\n  }, []);\n  const removeNode = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    nodesRef.current = nodesRef.current.filter(n => n !== node);\n  }, []);\n  const events = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => createPubSub())[0];\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingTreeContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      nodesRef,\n      addNode,\n      removeNode,\n      events\n    }), [addNode, removeNode, events])\n  }, children);\n}\nfunction createAttribute(name) {\n  return \"data-floating-ui-\" + name;\n}\nfunction useLatestRef(value) {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\nconst safePolygonIdentifier = /*#__PURE__*/createAttribute('safe-polygon');\nfunction getDelay(value, prop, pointerType) {\n  if (pointerType && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerType)) {\n    return 0;\n  }\n  if (typeof value === 'number') {\n    return value;\n  }\n  return value == null ? void 0 : value[prop];\n}\n/**\n * Opens the floating element while hovering over the reference element, like\n * CSS `:hover`.\n * @see https://floating-ui.com/docs/useHover\n */\nfunction useHover(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    events,\n    elements: {\n      domReference,\n      floating\n    },\n    refs\n  } = context;\n  const {\n    enabled = true,\n    delay = 0,\n    handleClose = null,\n    mouseOnly = false,\n    restMs = 0,\n    move = true\n  } = props;\n  const tree = useFloatingTree();\n  const parentId = useFloatingParentNodeId();\n  const handleCloseRef = useLatestRef(handleClose);\n  const delayRef = useLatestRef(delay);\n  const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const handlerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const restTimeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const blockMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n  const performedPointerEventsMutationRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const unbindMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(() => {});\n  const isHoverOpen = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    var _dataRef$current$open;\n    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;\n    return (type == null ? void 0 : type.includes('mouse')) && type !== 'mousedown';\n  }, [dataRef]);\n\n  // When closing before opening, clear the delay timeouts to cancel it\n  // from showing.\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onOpenChange(_ref) {\n      let {\n        open\n      } = _ref;\n      if (!open) {\n        clearTimeout(timeoutRef.current);\n        clearTimeout(restTimeoutRef.current);\n        blockMouseMoveRef.current = true;\n      }\n    }\n    events.on('openchange', onOpenChange);\n    return () => {\n      events.off('openchange', onOpenChange);\n    };\n  }, [enabled, events]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled || !handleCloseRef.current || !open) {\n      return;\n    }\n    function onLeave(event) {\n      if (isHoverOpen()) {\n        onOpenChange(false, event, 'hover');\n      }\n    }\n    const html = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating).documentElement;\n    html.addEventListener('mouseleave', onLeave);\n    return () => {\n      html.removeEventListener('mouseleave', onLeave);\n    };\n  }, [floating, open, onOpenChange, enabled, handleCloseRef, isHoverOpen]);\n  const closeWithDelay = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (event, runElseBranch, reason) {\n    if (runElseBranch === void 0) {\n      runElseBranch = true;\n    }\n    if (reason === void 0) {\n      reason = 'hover';\n    }\n    const closeDelay = getDelay(delayRef.current, 'close', pointerTypeRef.current);\n    if (closeDelay && !handlerRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = setTimeout(() => onOpenChange(false, event, reason), closeDelay);\n    } else if (runElseBranch) {\n      clearTimeout(timeoutRef.current);\n      onOpenChange(false, event, reason);\n    }\n  }, [delayRef, onOpenChange]);\n  const cleanupMouseMoveHandler = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    unbindMouseMoveRef.current();\n    handlerRef.current = undefined;\n  }, []);\n  const clearPointerEvents = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    if (performedPointerEventsMutationRef.current) {\n      const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(refs.floating.current).body;\n      body.style.pointerEvents = '';\n      body.removeAttribute(safePolygonIdentifier);\n      performedPointerEventsMutationRef.current = false;\n    }\n  }, [refs]);\n\n  // Registering the mouse events on the reference directly to bypass React's\n  // delegation system. If the cursor was on a disabled element and then entered\n  // the reference (no gap), `mouseenter` doesn't fire in the delegation system.\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function isClickLikeOpenEvent() {\n      return dataRef.current.openEvent ? ['click', 'mousedown'].includes(dataRef.current.openEvent.type) : false;\n    }\n    function onMouseEnter(event) {\n      clearTimeout(timeoutRef.current);\n      blockMouseMoveRef.current = false;\n      if (mouseOnly && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerTypeRef.current) || restMs > 0 && getDelay(delayRef.current, 'open') === 0) {\n        return;\n      }\n      const openDelay = getDelay(delayRef.current, 'open', pointerTypeRef.current);\n      if (openDelay) {\n        timeoutRef.current = setTimeout(() => {\n          onOpenChange(true, event, 'hover');\n        }, openDelay);\n      } else {\n        onOpenChange(true, event, 'hover');\n      }\n    }\n    function onMouseLeave(event) {\n      if (isClickLikeOpenEvent()) {\n        return;\n      }\n      unbindMouseMoveRef.current();\n      const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating);\n      clearTimeout(restTimeoutRef.current);\n      if (handleCloseRef.current) {\n        // Prevent clearing `onScrollMouseLeave` timeout.\n        if (!open) {\n          clearTimeout(timeoutRef.current);\n        }\n        handlerRef.current = handleCloseRef.current(_objectSpread(_objectSpread({}, context), {}, {\n          tree,\n          x: event.clientX,\n          y: event.clientY,\n          onClose() {\n            clearPointerEvents();\n            cleanupMouseMoveHandler();\n            closeWithDelay(event, true, 'safe-polygon');\n          }\n        }));\n        const handler = handlerRef.current;\n        doc.addEventListener('mousemove', handler);\n        unbindMouseMoveRef.current = () => {\n          doc.removeEventListener('mousemove', handler);\n        };\n        return;\n      }\n\n      // Allow interactivity without `safePolygon` on touch devices. With a\n      // pointer, a short close delay is an alternative, so it should work\n      // consistently.\n      const shouldClose = pointerTypeRef.current === 'touch' ? !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, event.relatedTarget) : true;\n      if (shouldClose) {\n        closeWithDelay(event);\n      }\n    }\n\n    // Ensure the floating element closes after scrolling even if the pointer\n    // did not move.\n    // https://github.com/floating-ui/floating-ui/discussions/1692\n    function onScrollMouseLeave(event) {\n      if (isClickLikeOpenEvent()) {\n        return;\n      }\n      handleCloseRef.current == null || handleCloseRef.current(_objectSpread(_objectSpread({}, context), {}, {\n        tree,\n        x: event.clientX,\n        y: event.clientY,\n        onClose() {\n          clearPointerEvents();\n          cleanupMouseMoveHandler();\n          closeWithDelay(event);\n        }\n      }))(event);\n    }\n    if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(domReference)) {\n      const ref = domReference;\n      open && ref.addEventListener('mouseleave', onScrollMouseLeave);\n      floating == null || floating.addEventListener('mouseleave', onScrollMouseLeave);\n      move && ref.addEventListener('mousemove', onMouseEnter, {\n        once: true\n      });\n      ref.addEventListener('mouseenter', onMouseEnter);\n      ref.addEventListener('mouseleave', onMouseLeave);\n      return () => {\n        open && ref.removeEventListener('mouseleave', onScrollMouseLeave);\n        floating == null || floating.removeEventListener('mouseleave', onScrollMouseLeave);\n        move && ref.removeEventListener('mousemove', onMouseEnter);\n        ref.removeEventListener('mouseenter', onMouseEnter);\n        ref.removeEventListener('mouseleave', onMouseLeave);\n      };\n    }\n  }, [domReference, floating, enabled, context, mouseOnly, restMs, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, tree, delayRef, handleCloseRef, dataRef]);\n\n  // Block pointer-events of every element other than the reference and floating\n  // while the floating element is open and has a `handleClose` handler. Also\n  // handles nested floating elements.\n  // https://github.com/floating-ui/floating-ui/issues/1722\n  index(() => {\n    var _handleCloseRef$curre;\n    if (!enabled) {\n      return;\n    }\n    if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {\n      const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating).body;\n      body.setAttribute(safePolygonIdentifier, '');\n      body.style.pointerEvents = 'none';\n      performedPointerEventsMutationRef.current = true;\n      if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(domReference) && floating) {\n        var _tree$nodesRef$curren;\n        const ref = domReference;\n        const parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;\n        if (parentFloating) {\n          parentFloating.style.pointerEvents = '';\n        }\n        ref.style.pointerEvents = 'auto';\n        floating.style.pointerEvents = 'auto';\n        return () => {\n          ref.style.pointerEvents = '';\n          floating.style.pointerEvents = '';\n        };\n      }\n    }\n  }, [enabled, open, parentId, floating, domReference, tree, handleCloseRef, isHoverOpen]);\n  index(() => {\n    if (!open) {\n      pointerTypeRef.current = undefined;\n      cleanupMouseMoveHandler();\n      clearPointerEvents();\n    }\n  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    return () => {\n      cleanupMouseMoveHandler();\n      clearTimeout(timeoutRef.current);\n      clearTimeout(restTimeoutRef.current);\n      clearPointerEvents();\n    };\n  }, [enabled, domReference, cleanupMouseMoveHandler, clearPointerEvents]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    function setPointerRef(event) {\n      pointerTypeRef.current = event.pointerType;\n    }\n    return {\n      reference: {\n        onPointerDown: setPointerRef,\n        onPointerEnter: setPointerRef,\n        onMouseMove(event) {\n          if (open || restMs === 0) {\n            return;\n          }\n          clearTimeout(restTimeoutRef.current);\n          restTimeoutRef.current = setTimeout(() => {\n            if (!blockMouseMoveRef.current) {\n              onOpenChange(true, event.nativeEvent, 'hover');\n            }\n          }, restMs);\n        }\n      },\n      floating: {\n        onMouseEnter() {\n          clearTimeout(timeoutRef.current);\n        },\n        onMouseLeave(event) {\n          closeWithDelay(event.nativeEvent, false);\n        }\n      }\n    };\n  }, [enabled, restMs, open, onOpenChange, closeWithDelay]);\n}\nconst FloatingDelayGroupContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  delay: 0,\n  initialDelay: 0,\n  timeoutMs: 0,\n  currentId: null,\n  setCurrentId: () => {},\n  setState: () => {},\n  isInstantPhase: false\n});\nconst useDelayGroupContext = () => react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingDelayGroupContext);\n/**\n * Provides context for a group of floating elements that should share a\n * `delay`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */\nconst FloatingDelayGroup = _ref => {\n  let {\n    children,\n    delay,\n    timeoutMs = 0\n  } = _ref;\n  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useReducer((prev, next) => _objectSpread(_objectSpread({}, prev), next), {\n    delay,\n    timeoutMs,\n    initialDelay: delay,\n    currentId: null,\n    isInstantPhase: false\n  });\n  const initialCurrentIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const setCurrentId = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(currentId => {\n    setState({\n      currentId\n    });\n  }, []);\n  index(() => {\n    if (state.currentId) {\n      if (initialCurrentIdRef.current === null) {\n        initialCurrentIdRef.current = state.currentId;\n      } else {\n        setState({\n          isInstantPhase: true\n        });\n      }\n    } else {\n      setState({\n        isInstantPhase: false\n      });\n      initialCurrentIdRef.current = null;\n    }\n  }, [state.currentId]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingDelayGroupContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => _objectSpread(_objectSpread({}, state), {}, {\n      setState,\n      setCurrentId\n    }), [state, setCurrentId])\n  }, children);\n};\n/**\n * Enables grouping when called inside a component that's a child of a\n * `FloatingDelayGroup`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */\nconst useDelayGroup = (_ref2, _ref3) => {\n  let {\n    open,\n    onOpenChange\n  } = _ref2;\n  let {\n    id\n  } = _ref3;\n  const {\n    currentId,\n    setCurrentId,\n    initialDelay,\n    setState,\n    timeoutMs\n  } = useDelayGroupContext();\n  index(() => {\n    if (currentId) {\n      setState({\n        delay: {\n          open: 1,\n          close: getDelay(initialDelay, 'close')\n        }\n      });\n      if (currentId !== id) {\n        onOpenChange(false);\n      }\n    }\n  }, [id, onOpenChange, setState, currentId, initialDelay]);\n  index(() => {\n    function unset() {\n      onOpenChange(false);\n      setState({\n        delay: initialDelay,\n        currentId: null\n      });\n    }\n    if (!open && currentId === id) {\n      if (timeoutMs) {\n        const timeout = window.setTimeout(unset, timeoutMs);\n        return () => {\n          clearTimeout(timeout);\n        };\n      }\n      unset();\n    }\n  }, [open, setState, currentId, id, onOpenChange, initialDelay, timeoutMs]);\n  index(() => {\n    if (open) {\n      setCurrentId(id);\n    }\n  }, [open, setCurrentId, id]);\n};\nfunction getAncestors(nodes, id) {\n  var _nodes$find;\n  let allAncestors = [];\n  let currentParentId = (_nodes$find = nodes.find(node => node.id === id)) == null ? void 0 : _nodes$find.parentId;\n  while (currentParentId) {\n    const currentNode = nodes.find(node => node.id === currentParentId);\n    currentParentId = currentNode == null ? void 0 : currentNode.parentId;\n    if (currentNode) {\n      allAncestors = allAncestors.concat(currentNode);\n    }\n  }\n  return allAncestors;\n}\nfunction getChildren(nodes, id) {\n  let allChildren = nodes.filter(node => {\n    var _node$context;\n    return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);\n  });\n  let currentChildren = allChildren;\n  while (currentChildren.length) {\n    currentChildren = nodes.filter(node => {\n      var _currentChildren;\n      return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some(n => {\n        var _node$context2;\n        return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);\n      });\n    });\n    allChildren = allChildren.concat(currentChildren);\n  }\n  return allChildren;\n}\nfunction getDeepestNode(nodes, id) {\n  let deepestNodeId;\n  let maxDepth = -1;\n  function findDeepest(nodeId, depth) {\n    if (depth > maxDepth) {\n      deepestNodeId = nodeId;\n      maxDepth = depth;\n    }\n    const children = getChildren(nodes, nodeId);\n    children.forEach(child => {\n      findDeepest(child.id, depth + 1);\n    });\n  }\n  findDeepest(id, 0);\n  return nodes.find(node => node.id === deepestNodeId);\n}\n\n// Modified to add conditional `aria-hidden` support:\n// https://github.com/theKashey/aria-hidden/blob/9220c8f4a4fd35f63bee5510a9f41a37264382d4/src/index.ts\nlet counterMap = /*#__PURE__*/new WeakMap();\nlet uncontrolledElementsSet = /*#__PURE__*/new WeakSet();\nlet markerMap = {};\nlet lockCount = 0;\nconst supportsInert = () => typeof HTMLElement !== 'undefined' && 'inert' in HTMLElement.prototype;\nconst unwrapHost = node => node && (node.host || unwrapHost(node.parentNode));\nconst correctElements = (parent, targets) => targets.map(target => {\n  if (parent.contains(target)) {\n    return target;\n  }\n  const correctedTarget = unwrapHost(target);\n  if (parent.contains(correctedTarget)) {\n    return correctedTarget;\n  }\n  return null;\n}).filter(x => x != null);\nfunction applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, inert) {\n  const markerName = 'data-floating-ui-inert';\n  const controlAttribute = inert ? 'inert' : ariaHidden ? 'aria-hidden' : null;\n  const avoidElements = correctElements(body, uncorrectedAvoidElements);\n  const elementsToKeep = new Set();\n  const elementsToStop = new Set(avoidElements);\n  const hiddenElements = [];\n  if (!markerMap[markerName]) {\n    markerMap[markerName] = new WeakMap();\n  }\n  const markerCounter = markerMap[markerName];\n  avoidElements.forEach(keep);\n  deep(body);\n  elementsToKeep.clear();\n  function keep(el) {\n    if (!el || elementsToKeep.has(el)) {\n      return;\n    }\n    elementsToKeep.add(el);\n    el.parentNode && keep(el.parentNode);\n  }\n  function deep(parent) {\n    if (!parent || elementsToStop.has(parent)) {\n      return;\n    }\n    Array.prototype.forEach.call(parent.children, node => {\n      if (elementsToKeep.has(node)) {\n        deep(node);\n      } else {\n        const attr = controlAttribute ? node.getAttribute(controlAttribute) : null;\n        const alreadyHidden = attr !== null && attr !== 'false';\n        const counterValue = (counterMap.get(node) || 0) + 1;\n        const markerValue = (markerCounter.get(node) || 0) + 1;\n        counterMap.set(node, counterValue);\n        markerCounter.set(node, markerValue);\n        hiddenElements.push(node);\n        if (counterValue === 1 && alreadyHidden) {\n          uncontrolledElementsSet.add(node);\n        }\n        if (markerValue === 1) {\n          node.setAttribute(markerName, '');\n        }\n        if (!alreadyHidden && controlAttribute) {\n          node.setAttribute(controlAttribute, 'true');\n        }\n      }\n    });\n  }\n  lockCount++;\n  return () => {\n    hiddenElements.forEach(element => {\n      const counterValue = (counterMap.get(element) || 0) - 1;\n      const markerValue = (markerCounter.get(element) || 0) - 1;\n      counterMap.set(element, counterValue);\n      markerCounter.set(element, markerValue);\n      if (!counterValue) {\n        if (!uncontrolledElementsSet.has(element) && controlAttribute) {\n          element.removeAttribute(controlAttribute);\n        }\n        uncontrolledElementsSet.delete(element);\n      }\n      if (!markerValue) {\n        element.removeAttribute(markerName);\n      }\n    });\n    lockCount--;\n    if (!lockCount) {\n      counterMap = new WeakMap();\n      counterMap = new WeakMap();\n      uncontrolledElementsSet = new WeakSet();\n      markerMap = {};\n    }\n  };\n}\nfunction markOthers(avoidElements, ariaHidden, inert) {\n  if (ariaHidden === void 0) {\n    ariaHidden = false;\n  }\n  if (inert === void 0) {\n    inert = false;\n  }\n  const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(avoidElements[0]).body;\n  return applyAttributeToOthers(avoidElements.concat(Array.from(body.querySelectorAll('[aria-live]'))), body, ariaHidden, inert);\n}\nconst getTabbableOptions = () => ({\n  getShadowRoot: true,\n  displayCheck:\n  // JSDOM does not support the `tabbable` library. To solve this we can\n  // check if `ResizeObserver` is a real function (not polyfilled), which\n  // determines if the current environment is JSDOM-like.\n  typeof ResizeObserver === 'function' && ResizeObserver.toString().includes('[native code]') ? 'full' : 'none'\n});\nfunction getTabbableIn(container, direction) {\n  const allTabbable = (0,tabbable__WEBPACK_IMPORTED_MODULE_8__.tabbable)(container, getTabbableOptions());\n  if (direction === 'prev') {\n    allTabbable.reverse();\n  }\n  const activeIndex = allTabbable.indexOf((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(container)));\n  const nextTabbableElements = allTabbable.slice(activeIndex + 1);\n  return nextTabbableElements[0];\n}\nfunction getNextTabbable() {\n  return getTabbableIn(document.body, 'next');\n}\nfunction getPreviousTabbable() {\n  return getTabbableIn(document.body, 'prev');\n}\nfunction isOutsideEvent(event, container) {\n  const containerElement = container || event.currentTarget;\n  const relatedTarget = event.relatedTarget;\n  return !relatedTarget || !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(containerElement, relatedTarget);\n}\nfunction disableFocusInside(container) {\n  const tabbableElements = (0,tabbable__WEBPACK_IMPORTED_MODULE_8__.tabbable)(container, getTabbableOptions());\n  tabbableElements.forEach(element => {\n    element.dataset.tabindex = element.getAttribute('tabindex') || '';\n    element.setAttribute('tabindex', '-1');\n  });\n}\nfunction enableFocusInside(container) {\n  const elements = container.querySelectorAll('[data-tabindex]');\n  elements.forEach(element => {\n    const tabindex = element.dataset.tabindex;\n    // biome-ignore lint/performance/noDelete: purity\n    delete element.dataset.tabindex;\n    if (tabindex) {\n      element.setAttribute('tabindex', tabindex);\n    } else {\n      element.removeAttribute('tabindex');\n    }\n  });\n}\n\n// See Diego Haz's Sandbox for making this logic work well on Safari/iOS:\n// https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/FocusTrap.tsx\n\nconst HIDDEN_STYLES = {\n  border: 0,\n  clip: 'rect(0 0 0 0)',\n  height: '1px',\n  margin: '-1px',\n  overflow: 'hidden',\n  padding: 0,\n  position: 'fixed',\n  whiteSpace: 'nowrap',\n  width: '1px',\n  top: 0,\n  left: 0\n};\nlet timeoutId;\nfunction setActiveElementOnTab(event) {\n  if (event.key === 'Tab') {\n    event.target;\n    clearTimeout(timeoutId);\n  }\n}\nconst FocusGuard = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FocusGuard(props, ref) {\n  const [role, setRole] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  index(() => {\n    if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isSafari)()) {\n      // Unlike other screen readers such as NVDA and JAWS, the virtual cursor\n      // on VoiceOver does trigger the onFocus event, so we can use the focus\n      // trap element. On Safari, only buttons trigger the onFocus event.\n      // NB: \"group\" role in the Sandbox no longer appears to work, must be a\n      // button role.\n      setRole('button');\n    }\n    document.addEventListener('keydown', setActiveElementOnTab);\n    return () => {\n      document.removeEventListener('keydown', setActiveElementOnTab);\n    };\n  }, []);\n  const restProps = {\n    ref,\n    tabIndex: 0,\n    // Role is only for VoiceOver\n    role,\n    'aria-hidden': role ? undefined : true,\n    [createAttribute('focus-guard')]: '',\n    style: HIDDEN_STYLES\n  };\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", _extends({}, props, restProps));\n});\nconst PortalContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst attr = /*#__PURE__*/createAttribute('portal');\n\n/**\n * @see https://floating-ui.com/docs/FloatingPortal#usefloatingportalnode\n */\nfunction useFloatingPortalNode(_temp) {\n  let {\n    id,\n    root\n  } = _temp === void 0 ? {} : _temp;\n  const [portalNode, setPortalNode] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n  const uniqueId = useId();\n  const portalContext = usePortalContext();\n  const portalNodeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  index(() => {\n    return () => {\n      portalNode == null || portalNode.remove();\n      // Allow the subsequent layout effects to create a new node on updates.\n      // The portal node will still be cleaned up on unmount.\n      // https://github.com/floating-ui/floating-ui/issues/2454\n      queueMicrotask(() => {\n        portalNodeRef.current = null;\n      });\n    };\n  }, [portalNode]);\n  index(() => {\n    if (portalNodeRef.current) return;\n    const existingIdRoot = id ? document.getElementById(id) : null;\n    if (!existingIdRoot) return;\n    const subRoot = document.createElement('div');\n    subRoot.id = uniqueId;\n    subRoot.setAttribute(attr, '');\n    existingIdRoot.appendChild(subRoot);\n    portalNodeRef.current = subRoot;\n    setPortalNode(subRoot);\n  }, [id, uniqueId]);\n  index(() => {\n    if (portalNodeRef.current) return;\n    let container = root || (portalContext == null ? void 0 : portalContext.portalNode);\n    if (container && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(container)) container = container.current;\n    container = container || document.body;\n    let idWrapper = null;\n    if (id) {\n      idWrapper = document.createElement('div');\n      idWrapper.id = id;\n      container.appendChild(idWrapper);\n    }\n    const subRoot = document.createElement('div');\n    subRoot.id = uniqueId;\n    subRoot.setAttribute(attr, '');\n    container = idWrapper || container;\n    container.appendChild(subRoot);\n    portalNodeRef.current = subRoot;\n    setPortalNode(subRoot);\n  }, [id, root, uniqueId, portalContext]);\n  return portalNode;\n}\n/**\n * Portals the floating element into a given container element — by default,\n * outside of the app root and into the body.\n * This is necessary to ensure the floating element can appear outside any\n * potential parent containers that cause clipping (such as `overflow: hidden`),\n * while retaining its location in the React tree.\n * @see https://floating-ui.com/docs/FloatingPortal\n */\nfunction FloatingPortal(_ref) {\n  let {\n    children,\n    id,\n    root = null,\n    preserveTabOrder = true\n  } = _ref;\n  const portalNode = useFloatingPortalNode({\n    id,\n    root\n  });\n  const [focusManagerState, setFocusManagerState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n  const beforeOutsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const afterOutsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const beforeInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const afterInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const shouldRenderGuards =\n  // The FocusManager and therefore floating element are currently open/\n  // rendered.\n  !!focusManagerState &&\n  // Guards are only for non-modal focus management.\n  !focusManagerState.modal &&\n  // Don't render if unmount is transitioning.\n  focusManagerState.open && preserveTabOrder && !!(root || portalNode);\n\n  // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/TabbablePortal.tsx\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!portalNode || !preserveTabOrder || focusManagerState != null && focusManagerState.modal) {\n      return;\n    }\n\n    // Make sure elements inside the portal element are tabbable only when the\n    // portal has already been focused, either by tabbing into a focus trap\n    // element outside or using the mouse.\n    function onFocus(event) {\n      if (portalNode && isOutsideEvent(event)) {\n        const focusing = event.type === 'focusin';\n        const manageFocus = focusing ? enableFocusInside : disableFocusInside;\n        manageFocus(portalNode);\n      }\n    }\n    // Listen to the event on the capture phase so they run before the focus\n    // trap elements onFocus prop is called.\n    portalNode.addEventListener('focusin', onFocus, true);\n    portalNode.addEventListener('focusout', onFocus, true);\n    return () => {\n      portalNode.removeEventListener('focusin', onFocus, true);\n      portalNode.removeEventListener('focusout', onFocus, true);\n    };\n  }, [portalNode, preserveTabOrder, focusManagerState == null ? void 0 : focusManagerState.modal]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(PortalContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      preserveTabOrder,\n      beforeOutsideRef,\n      afterOutsideRef,\n      beforeInsideRef,\n      afterInsideRef,\n      portalNode,\n      setFocusManagerState\n    }), [preserveTabOrder, portalNode])\n  }, shouldRenderGuards && portalNode && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n    \"data-type\": \"outside\",\n    ref: beforeOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _beforeInsideRef$curr;\n        (_beforeInsideRef$curr = beforeInsideRef.current) == null || _beforeInsideRef$curr.focus();\n      } else {\n        const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        prevTabbable == null || prevTabbable.focus();\n      }\n    }\n  }), shouldRenderGuards && portalNode && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n    \"aria-owns\": portalNode.id,\n    style: HIDDEN_STYLES\n  }), portalNode && /*#__PURE__*/(0,react_dom__WEBPACK_IMPORTED_MODULE_5__.createPortal)(children, portalNode), shouldRenderGuards && portalNode && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n    \"data-type\": \"outside\",\n    ref: afterOutsideRef,\n    onFocus: event => {\n      if (isOutsideEvent(event, portalNode)) {\n        var _afterInsideRef$curre;\n        (_afterInsideRef$curre = afterInsideRef.current) == null || _afterInsideRef$curre.focus();\n      } else {\n        const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n        nextTabbable == null || nextTabbable.focus();\n        (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent));\n      }\n    }\n  }));\n}\nconst usePortalContext = () => react__WEBPACK_IMPORTED_MODULE_0__.useContext(PortalContext);\nconst LIST_LIMIT = 20;\nlet previouslyFocusedElements = [];\nfunction addPreviouslyFocusedElement(element) {\n  previouslyFocusedElements = previouslyFocusedElements.filter(el => el.isConnected);\n  if (element && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getNodeName)(element) !== 'body') {\n    previouslyFocusedElements.push(element);\n    if (previouslyFocusedElements.length > LIST_LIMIT) {\n      previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT);\n    }\n  }\n}\nfunction getPreviouslyFocusedElement() {\n  return previouslyFocusedElements.slice().reverse().find(el => el.isConnected);\n}\nconst VisuallyHiddenDismiss = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function VisuallyHiddenDismiss(props, ref) {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", _extends({}, props, {\n    type: \"button\",\n    ref: ref,\n    tabIndex: -1,\n    style: HIDDEN_STYLES\n  }));\n});\n/**\n * Provides focus management for the floating element.\n * @see https://floating-ui.com/docs/FloatingFocusManager\n */\nfunction FloatingFocusManager(props) {\n  const {\n    context,\n    children,\n    disabled = false,\n    order = ['content'],\n    guards: _guards = true,\n    initialFocus = 0,\n    returnFocus = true,\n    modal = true,\n    visuallyHiddenDismiss = false,\n    closeOnFocusOut = true\n  } = props;\n  const {\n    open,\n    refs,\n    nodeId,\n    onOpenChange,\n    events,\n    dataRef,\n    elements: {\n      domReference,\n      floating\n    }\n  } = context;\n  const ignoreInitialFocus = typeof initialFocus === 'number' && initialFocus < 0;\n  // If the reference is a combobox and is typeable (e.g. input/textarea),\n  // there are different focus semantics. The guards should not be rendered, but\n  // aria-hidden should be applied to all nodes still. Further, the visually\n  // hidden dismiss button should only appear at the end of the list, not the\n  // start.\n  const isUntrappedTypeableCombobox = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableCombobox)(domReference) && ignoreInitialFocus;\n\n  // Force the guards to be rendered if the `inert` attribute is not supported.\n  const guards = supportsInert() ? _guards : true;\n  const orderRef = useLatestRef(order);\n  const initialFocusRef = useLatestRef(initialFocus);\n  const returnFocusRef = useLatestRef(returnFocus);\n  const tree = useFloatingTree();\n  const portalContext = usePortalContext();\n  const startDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const endDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const preventReturnFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const isPointerDownRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const isInsidePortal = portalContext != null;\n  const getTabbableContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (container) {\n    if (container === void 0) {\n      container = floating;\n    }\n    return container ? (0,tabbable__WEBPACK_IMPORTED_MODULE_8__.tabbable)(container, getTabbableOptions()) : [];\n  }, [floating]);\n  const getTabbableElements = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(container => {\n    const content = getTabbableContent(container);\n    return orderRef.current.map(type => {\n      if (domReference && type === 'reference') {\n        return domReference;\n      }\n      if (floating && type === 'floating') {\n        return floating;\n      }\n      return content;\n    }).filter(Boolean).flat();\n  }, [domReference, floating, orderRef, getTabbableContent]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (disabled || !modal) return;\n    function onKeyDown(event) {\n      if (event.key === 'Tab') {\n        // The focus guards have nothing to focus, so we need to stop the event.\n        if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating))) && getTabbableContent().length === 0 && !isUntrappedTypeableCombobox) {\n          (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n        }\n        const els = getTabbableElements();\n        const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n        if (orderRef.current[0] === 'reference' && target === domReference) {\n          (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n          if (event.shiftKey) {\n            enqueueFocus(els[els.length - 1]);\n          } else {\n            enqueueFocus(els[1]);\n          }\n        }\n        if (orderRef.current[1] === 'floating' && target === floating && event.shiftKey) {\n          (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n          enqueueFocus(els[0]);\n        }\n      }\n    }\n    const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating);\n    doc.addEventListener('keydown', onKeyDown);\n    return () => {\n      doc.removeEventListener('keydown', onKeyDown);\n    };\n  }, [disabled, domReference, floating, modal, orderRef, isUntrappedTypeableCombobox, getTabbableContent, getTabbableElements]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (disabled || !closeOnFocusOut) return;\n\n    // In Safari, buttons lose focus when pressing them.\n    function handlePointerDown() {\n      isPointerDownRef.current = true;\n      setTimeout(() => {\n        isPointerDownRef.current = false;\n      });\n    }\n    function handleFocusOutside(event) {\n      const relatedTarget = event.relatedTarget;\n      queueMicrotask(() => {\n        const movedToUnrelatedNode = !((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(domReference, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(relatedTarget, floating) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute('focus-guard')) || tree && (getChildren(tree.nodesRef.current, nodeId).find(node => {\n          var _node$context, _node$context2;\n          return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);\n        }) || getAncestors(tree.nodesRef.current, nodeId).find(node => {\n          var _node$context3, _node$context4;\n          return ((_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;\n        })));\n\n        // Focus did not move inside the floating tree, and there are no tabbable\n        // portal guards to handle closing.\n        if (relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current &&\n        // Fix React 18 Strict Mode returnFocus due to double rendering.\n        relatedTarget !== getPreviouslyFocusedElement()) {\n          preventReturnFocusRef.current = true;\n          onOpenChange(false, event);\n        }\n      });\n    }\n    if (floating && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(domReference)) {\n      domReference.addEventListener('focusout', handleFocusOutside);\n      domReference.addEventListener('pointerdown', handlePointerDown);\n      !modal && floating.addEventListener('focusout', handleFocusOutside);\n      return () => {\n        domReference.removeEventListener('focusout', handleFocusOutside);\n        domReference.removeEventListener('pointerdown', handlePointerDown);\n        !modal && floating.removeEventListener('focusout', handleFocusOutside);\n      };\n    }\n  }, [disabled, domReference, floating, modal, nodeId, tree, portalContext, onOpenChange, closeOnFocusOut]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    var _portalContext$portal;\n    if (disabled) return;\n\n    // Don't hide portals nested within the parent portal.\n    const portalNodes = Array.from((portalContext == null || (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll(\"[\" + createAttribute('portal') + \"]\")) || []);\n    if (floating) {\n      const insideElements = [floating, ...portalNodes, startDismissButtonRef.current, endDismissButtonRef.current, orderRef.current.includes('reference') || isUntrappedTypeableCombobox ? domReference : null].filter(x => x != null);\n      const cleanup = modal || isUntrappedTypeableCombobox ? markOthers(insideElements, guards, !guards) : markOthers(insideElements);\n      return () => {\n        cleanup();\n      };\n    }\n  }, [disabled, domReference, floating, modal, orderRef, portalContext, isUntrappedTypeableCombobox, guards]);\n  index(() => {\n    if (disabled || !floating) return;\n    const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating);\n    const previouslyFocusedElement = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(doc);\n\n    // Wait for any layout effect state setters to execute to set `tabIndex`.\n    queueMicrotask(() => {\n      const focusableElements = getTabbableElements(floating);\n      const initialFocusValue = initialFocusRef.current;\n      const elToFocus = (typeof initialFocusValue === 'number' ? focusableElements[initialFocusValue] : initialFocusValue.current) || floating;\n      const focusAlreadyInsideFloatingEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, previouslyFocusedElement);\n      if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {\n        enqueueFocus(elToFocus, {\n          preventScroll: elToFocus === floating\n        });\n      }\n    });\n  }, [disabled, open, floating, ignoreInitialFocus, getTabbableElements, initialFocusRef]);\n  index(() => {\n    if (disabled || !floating) return;\n    let preventReturnFocusScroll = false;\n    const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating);\n    const previouslyFocusedElement = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(doc);\n    const contextData = dataRef.current;\n    addPreviouslyFocusedElement(previouslyFocusedElement);\n\n    // Dismissing via outside press should always ignore `returnFocus` to\n    // prevent unwanted scrolling.\n    function onOpenChange(_ref) {\n      let {\n        reason,\n        event,\n        nested\n      } = _ref;\n      if (reason === 'escape-key' && refs.domReference.current) {\n        addPreviouslyFocusedElement(refs.domReference.current);\n      }\n      if (reason === 'hover' && event.type === 'mouseleave') {\n        preventReturnFocusRef.current = true;\n      }\n      if (reason !== 'outside-press') return;\n      if (nested) {\n        preventReturnFocusRef.current = false;\n        preventReturnFocusScroll = true;\n      } else {\n        preventReturnFocusRef.current = !((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualClick)(event) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualPointerEvent)(event));\n      }\n    }\n    events.on('openchange', onOpenChange);\n    return () => {\n      events.off('openchange', onOpenChange);\n      const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(doc);\n      const isFocusInsideFloatingTree = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, activeEl) || tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n        var _node$context5;\n        return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.floating, activeEl);\n      });\n      const shouldFocusReference = isFocusInsideFloatingTree || contextData.openEvent && ['click', 'mousedown'].includes(contextData.openEvent.type);\n      if (shouldFocusReference && refs.domReference.current) {\n        addPreviouslyFocusedElement(refs.domReference.current);\n      }\n      const returnElement = getPreviouslyFocusedElement();\n      if (returnFocusRef.current && !preventReturnFocusRef.current && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(returnElement) && (\n      // If the focus moved somewhere else after mount, avoid returning focus\n      // since it likely entered a different element which should be\n      // respected: https://github.com/floating-ui/floating-ui/issues/2607\n      returnElement !== activeEl && activeEl !== doc.body ? isFocusInsideFloatingTree : true)) {\n        enqueueFocus(returnElement, {\n          // When dismissing nested floating elements, by the time the rAF has\n          // executed, the menus will all have been unmounted. When they try\n          // to get focused, the calls get ignored — leaving the root\n          // reference focused as desired.\n          cancelPrevious: false,\n          preventScroll: preventReturnFocusScroll\n        });\n      }\n    };\n  }, [disabled, floating, returnFocusRef, dataRef, refs, events, tree, nodeId]);\n\n  // Synchronize the `context` & `modal` value to the FloatingPortal context.\n  // It will decide whether or not it needs to render its own guards.\n  index(() => {\n    if (disabled || !portalContext) return;\n    portalContext.setFocusManagerState({\n      modal,\n      closeOnFocusOut,\n      open,\n      onOpenChange,\n      refs\n    });\n    return () => {\n      portalContext.setFocusManagerState(null);\n    };\n  }, [disabled, portalContext, modal, open, onOpenChange, refs, closeOnFocusOut]);\n  index(() => {\n    if (disabled || !floating || typeof MutationObserver !== 'function' || ignoreInitialFocus) {\n      return;\n    }\n    const handleMutation = () => {\n      const tabIndex = floating.getAttribute('tabindex');\n      if (orderRef.current.includes('floating') || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating)) !== refs.domReference.current && getTabbableContent().length === 0) {\n        if (tabIndex !== '0') {\n          floating.setAttribute('tabindex', '0');\n        }\n      } else if (tabIndex !== '-1') {\n        floating.setAttribute('tabindex', '-1');\n      }\n    };\n    handleMutation();\n    const observer = new MutationObserver(handleMutation);\n    observer.observe(floating, {\n      childList: true,\n      subtree: true,\n      attributes: true\n    });\n    return () => {\n      observer.disconnect();\n    };\n  }, [disabled, floating, refs, orderRef, getTabbableContent, ignoreInitialFocus]);\n  function renderDismissButton(location) {\n    if (disabled || !visuallyHiddenDismiss || !modal) {\n      return null;\n    }\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(VisuallyHiddenDismiss, {\n      ref: location === 'start' ? startDismissButtonRef : endDismissButtonRef,\n      onClick: event => onOpenChange(false, event.nativeEvent)\n    }, typeof visuallyHiddenDismiss === 'string' ? visuallyHiddenDismiss : 'Dismiss');\n  }\n  const shouldRenderGuards = !disabled && guards && (isInsidePortal || modal);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, shouldRenderGuards && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n    \"data-type\": \"inside\",\n    ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,\n    onFocus: event => {\n      if (modal) {\n        const els = getTabbableElements();\n        enqueueFocus(order[0] === 'reference' ? els[0] : els[els.length - 1]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        preventReturnFocusRef.current = false;\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const nextTabbable = getNextTabbable() || domReference;\n          nextTabbable == null || nextTabbable.focus();\n        } else {\n          var _portalContext$before;\n          (_portalContext$before = portalContext.beforeOutsideRef.current) == null || _portalContext$before.focus();\n        }\n      }\n    }\n  }), !isUntrappedTypeableCombobox && renderDismissButton('start'), children, renderDismissButton('end'), shouldRenderGuards && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n    \"data-type\": \"inside\",\n    ref: portalContext == null ? void 0 : portalContext.afterInsideRef,\n    onFocus: event => {\n      if (modal) {\n        enqueueFocus(getTabbableElements()[0]);\n      } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n        if (closeOnFocusOut) {\n          preventReturnFocusRef.current = true;\n        }\n        if (isOutsideEvent(event, portalContext.portalNode)) {\n          const prevTabbable = getPreviousTabbable() || domReference;\n          prevTabbable == null || prevTabbable.focus();\n        } else {\n          var _portalContext$afterO;\n          (_portalContext$afterO = portalContext.afterOutsideRef.current) == null || _portalContext$afterO.focus();\n        }\n      }\n    }\n  }));\n}\nconst activeLocks = /*#__PURE__*/new Set();\n/**\n * Provides base styling for a fixed overlay element to dim content or block\n * pointer events behind a floating element.\n * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.\n * @see https://floating-ui.com/docs/FloatingOverlay\n */\nconst FloatingOverlay = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FloatingOverlay(_ref, ref) {\n  let {\n      lockScroll = false\n    } = _ref,\n    rest = _objectWithoutProperties(_ref, _excluded5);\n  const lockId = useId();\n  index(() => {\n    if (!lockScroll) return;\n    activeLocks.add(lockId);\n    const isIOS = /iP(hone|ad|od)|iOS/.test((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getPlatform)());\n    const bodyStyle = document.body.style;\n    // RTL <body> scrollbar\n    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;\n    const paddingProp = scrollbarX ? 'paddingLeft' : 'paddingRight';\n    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n    const scrollX = bodyStyle.left ? parseFloat(bodyStyle.left) : window.pageXOffset;\n    const scrollY = bodyStyle.top ? parseFloat(bodyStyle.top) : window.pageYOffset;\n    bodyStyle.overflow = 'hidden';\n    if (scrollbarWidth) {\n      bodyStyle[paddingProp] = scrollbarWidth + \"px\";\n    }\n\n    // Only iOS doesn't respect `overflow: hidden` on document.body, and this\n    // technique has fewer side effects.\n    if (isIOS) {\n      var _window$visualViewpor, _window$visualViewpor2;\n      // iOS 12 does not support `visualViewport`.\n      const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;\n      const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;\n      Object.assign(bodyStyle, {\n        position: 'fixed',\n        top: -(scrollY - Math.floor(offsetTop)) + \"px\",\n        left: -(scrollX - Math.floor(offsetLeft)) + \"px\",\n        right: '0'\n      });\n    }\n    return () => {\n      activeLocks.delete(lockId);\n      if (activeLocks.size === 0) {\n        Object.assign(bodyStyle, {\n          overflow: '',\n          [paddingProp]: ''\n        });\n        if (isIOS) {\n          Object.assign(bodyStyle, {\n            position: '',\n            top: '',\n            left: '',\n            right: ''\n          });\n          window.scrollTo(scrollX, scrollY);\n        }\n      }\n    };\n  }, [lockId, lockScroll]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", _extends({\n    ref: ref\n  }, rest, {\n    style: _objectSpread({\n      position: 'fixed',\n      overflow: 'auto',\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }, rest.style)\n  }));\n});\nfunction isButtonTarget(event) {\n  return (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(event.target) && event.target.tagName === 'BUTTON';\n}\nfunction isSpaceIgnored(element) {\n  return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableElement)(element);\n}\n/**\n * Opens or closes the floating element when clicking the reference element.\n * @see https://floating-ui.com/docs/useClick\n */\nfunction useClick(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    elements: {\n      domReference\n    }\n  } = context;\n  const {\n    enabled = true,\n    event: eventOption = 'click',\n    toggle = true,\n    ignoreMouse = false,\n    keyboardHandlers = true\n  } = props;\n  const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const didKeyDownRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) return {};\n    return {\n      reference: {\n        onPointerDown(event) {\n          pointerTypeRef.current = event.pointerType;\n        },\n        onMouseDown(event) {\n          // Ignore all buttons except for the \"main\" button.\n          // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n          if (event.button !== 0) {\n            return;\n          }\n          if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerTypeRef.current, true) && ignoreMouse) {\n            return;\n          }\n          if (eventOption === 'click') {\n            return;\n          }\n          if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'mousedown' : true)) {\n            onOpenChange(false, event.nativeEvent, 'click');\n          } else {\n            // Prevent stealing focus from the floating element\n            event.preventDefault();\n            onOpenChange(true, event.nativeEvent, 'click');\n          }\n        },\n        onClick(event) {\n          if (eventOption === 'mousedown' && pointerTypeRef.current) {\n            pointerTypeRef.current = undefined;\n            return;\n          }\n          if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerTypeRef.current, true) && ignoreMouse) {\n            return;\n          }\n          if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === 'click' : true)) {\n            onOpenChange(false, event.nativeEvent, 'click');\n          } else {\n            onOpenChange(true, event.nativeEvent, 'click');\n          }\n        },\n        onKeyDown(event) {\n          pointerTypeRef.current = undefined;\n          if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {\n            return;\n          }\n          if (event.key === ' ' && !isSpaceIgnored(domReference)) {\n            // Prevent scrolling\n            event.preventDefault();\n            didKeyDownRef.current = true;\n          }\n          if (event.key === 'Enter') {\n            if (open && toggle) {\n              onOpenChange(false, event.nativeEvent, 'click');\n            } else {\n              onOpenChange(true, event.nativeEvent, 'click');\n            }\n          }\n        },\n        onKeyUp(event) {\n          if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {\n            return;\n          }\n          if (event.key === ' ' && didKeyDownRef.current) {\n            didKeyDownRef.current = false;\n            if (open && toggle) {\n              onOpenChange(false, event.nativeEvent, 'click');\n            } else {\n              onOpenChange(true, event.nativeEvent, 'click');\n            }\n          }\n        }\n      }\n    };\n  }, [enabled, dataRef, eventOption, ignoreMouse, keyboardHandlers, domReference, toggle, open, onOpenChange]);\n}\nfunction createVirtualElement(domRef, data) {\n  let offsetX = null;\n  let offsetY = null;\n  let isAutoUpdateEvent = false;\n  return {\n    contextElement: domRef.current || undefined,\n    getBoundingClientRect() {\n      var _domRef$current, _data$dataRef$current;\n      const domRect = ((_domRef$current = domRef.current) == null ? void 0 : _domRef$current.getBoundingClientRect()) || {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0\n      };\n      const isXAxis = data.axis === 'x' || data.axis === 'both';\n      const isYAxis = data.axis === 'y' || data.axis === 'both';\n      const canTrackCursorOnAutoUpdate = ['mouseenter', 'mousemove'].includes(((_data$dataRef$current = data.dataRef.current.openEvent) == null ? void 0 : _data$dataRef$current.type) || '') && data.pointerType !== 'touch';\n      let width = domRect.width;\n      let height = domRect.height;\n      let x = domRect.x;\n      let y = domRect.y;\n      if (offsetX == null && data.x && isXAxis) {\n        offsetX = domRect.x - data.x;\n      }\n      if (offsetY == null && data.y && isYAxis) {\n        offsetY = domRect.y - data.y;\n      }\n      x -= offsetX || 0;\n      y -= offsetY || 0;\n      width = 0;\n      height = 0;\n      if (!isAutoUpdateEvent || canTrackCursorOnAutoUpdate) {\n        width = data.axis === 'y' ? domRect.width : 0;\n        height = data.axis === 'x' ? domRect.height : 0;\n        x = isXAxis && data.x != null ? data.x : x;\n        y = isYAxis && data.y != null ? data.y : y;\n      } else if (isAutoUpdateEvent && !canTrackCursorOnAutoUpdate) {\n        height = data.axis === 'x' ? domRect.height : height;\n        width = data.axis === 'y' ? domRect.width : width;\n      }\n      isAutoUpdateEvent = true;\n      return {\n        width,\n        height,\n        x,\n        y,\n        top: y,\n        right: x + width,\n        bottom: y + height,\n        left: x\n      };\n    }\n  };\n}\nfunction isMouseBasedEvent(event) {\n  return event != null && event.clientX != null;\n}\n/**\n * Positions the floating element relative to a client point (in the viewport),\n * such as the mouse position. By default, it follows the mouse cursor.\n * @see https://floating-ui.com/docs/useClientPoint\n */\nfunction useClientPoint(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    refs,\n    dataRef,\n    elements: {\n      floating\n    }\n  } = context;\n  const {\n    enabled = true,\n    axis = 'both',\n    x = null,\n    y = null\n  } = props;\n  const initialRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const cleanupListenerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const [pointerType, setPointerType] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  const [reactive, setReactive] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);\n  const setReference = useEffectEvent((x, y) => {\n    if (initialRef.current) return;\n\n    // Prevent setting if the open event was not a mouse-like one\n    // (e.g. focus to open, then hover over the reference element).\n    // Only apply if the event exists.\n    if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {\n      return;\n    }\n    refs.setPositionReference(createVirtualElement(refs.domReference, {\n      x,\n      y,\n      axis,\n      dataRef,\n      pointerType\n    }));\n  });\n  const handleReferenceEnterOrMove = useEffectEvent(event => {\n    if (x != null || y != null) return;\n    if (!open) {\n      setReference(event.clientX, event.clientY);\n    } else if (!cleanupListenerRef.current) {\n      // If there's no cleanup, there's no listener, but we want to ensure\n      // we add the listener if the cursor landed on the floating element and\n      // then back on the reference (i.e. it's interactive).\n      setReactive([]);\n    }\n  });\n\n  // If the pointer is a mouse-like pointer, we want to continue following the\n  // mouse even if the floating element is transitioning out. On touch\n  // devices, this is undesirable because the floating element will move to\n  // the dismissal touch point.\n  const openCheck = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerType) ? floating : open;\n  const addListener = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    // Explicitly specified `x`/`y` coordinates shouldn't add a listener.\n    if (!openCheck || !enabled || x != null || y != null) return;\n    const win = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getWindow)(refs.floating.current);\n    function handleMouseMove(event) {\n      const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n      if (!(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(refs.floating.current, target)) {\n        setReference(event.clientX, event.clientY);\n      } else {\n        win.removeEventListener('mousemove', handleMouseMove);\n        cleanupListenerRef.current = null;\n      }\n    }\n    if (!dataRef.current.openEvent || isMouseBasedEvent(dataRef.current.openEvent)) {\n      win.addEventListener('mousemove', handleMouseMove);\n      const cleanup = () => {\n        win.removeEventListener('mousemove', handleMouseMove);\n        cleanupListenerRef.current = null;\n      };\n      cleanupListenerRef.current = cleanup;\n      return cleanup;\n    }\n    refs.setPositionReference(refs.domReference.current);\n  }, [dataRef, enabled, openCheck, refs, setReference, x, y]);\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentionally specifying `reactive`\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    return addListener();\n  }, [addListener, reactive]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (enabled && !floating) {\n      initialRef.current = false;\n    }\n  }, [enabled, floating]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled && open) {\n      initialRef.current = true;\n    }\n  }, [enabled, open]);\n  index(() => {\n    if (enabled && (x != null || y != null)) {\n      initialRef.current = false;\n      setReference(x, y);\n    }\n  }, [enabled, x, y, setReference]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) return {};\n    function setPointerTypeRef(_ref) {\n      let {\n        pointerType\n      } = _ref;\n      setPointerType(pointerType);\n    }\n    return {\n      reference: {\n        onPointerDown: setPointerTypeRef,\n        onPointerEnter: setPointerTypeRef,\n        onMouseMove: handleReferenceEnterOrMove,\n        onMouseEnter: handleReferenceEnterOrMove\n      }\n    };\n  }, [enabled, handleReferenceEnterOrMove]);\n}\nconst bubbleHandlerKeys = {\n  pointerdown: 'onPointerDown',\n  mousedown: 'onMouseDown',\n  click: 'onClick'\n};\nconst captureHandlerKeys = {\n  pointerdown: 'onPointerDownCapture',\n  mousedown: 'onMouseDownCapture',\n  click: 'onClickCapture'\n};\nconst normalizeProp = normalizable => {\n  var _normalizable$escapeK, _normalizable$outside;\n  return {\n    escapeKey: typeof normalizable === 'boolean' ? normalizable : (_normalizable$escapeK = normalizable == null ? void 0 : normalizable.escapeKey) != null ? _normalizable$escapeK : false,\n    outsidePress: typeof normalizable === 'boolean' ? normalizable : (_normalizable$outside = normalizable == null ? void 0 : normalizable.outsidePress) != null ? _normalizable$outside : true\n  };\n};\n/**\n * Closes the floating element when a dismissal is requested — by default, when\n * the user presses the `escape` key or outside of the floating element.\n * @see https://floating-ui.com/docs/useDismiss\n */\nfunction useDismiss(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    nodeId,\n    elements: {\n      reference,\n      domReference,\n      floating\n    },\n    dataRef\n  } = context;\n  const {\n    enabled = true,\n    escapeKey = true,\n    outsidePress: unstable_outsidePress = true,\n    outsidePressEvent = 'pointerdown',\n    referencePress = false,\n    referencePressEvent = 'pointerdown',\n    ancestorScroll = false,\n    bubbles,\n    capture\n  } = props;\n  const tree = useFloatingTree();\n  const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === 'function' ? unstable_outsidePress : () => false);\n  const outsidePress = typeof unstable_outsidePress === 'function' ? outsidePressFn : unstable_outsidePress;\n  const insideReactTreeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const endedOrStartedInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const {\n    escapeKey: escapeKeyBubbles,\n    outsidePress: outsidePressBubbles\n  } = normalizeProp(bubbles);\n  const {\n    escapeKey: escapeKeyCapture,\n    outsidePress: outsidePressCapture\n  } = normalizeProp(capture);\n  const closeOnEscapeKeyDown = useEffectEvent(event => {\n    if (!open || !enabled || !escapeKey || event.key !== 'Escape') {\n      return;\n    }\n    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n    if (!escapeKeyBubbles) {\n      event.stopPropagation();\n      if (children.length > 0) {\n        let shouldDismiss = true;\n        children.forEach(child => {\n          var _child$context;\n          if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {\n            shouldDismiss = false;\n            return;\n          }\n        });\n        if (!shouldDismiss) {\n          return;\n        }\n      }\n    }\n    onOpenChange(false, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isReactEvent)(event) ? event.nativeEvent : event, 'escape-key');\n  });\n  const closeOnEscapeKeyDownCapture = useEffectEvent(event => {\n    var _getTarget2;\n    const callback = () => {\n      var _getTarget;\n      closeOnEscapeKeyDown(event);\n      (_getTarget = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event)) == null || _getTarget.removeEventListener('keydown', callback);\n    };\n    (_getTarget2 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event)) == null || _getTarget2.addEventListener('keydown', callback);\n  });\n  const closeOnPressOutside = useEffectEvent(event => {\n    // Given developers can stop the propagation of the synthetic event,\n    // we can only be confident with a positive value.\n    const insideReactTree = insideReactTreeRef.current;\n    insideReactTreeRef.current = false;\n\n    // When click outside is lazy (`click` event), handle dragging.\n    // Don't close if:\n    // - The click started inside the floating element.\n    // - The click ended inside the floating element.\n    const endedOrStartedInside = endedOrStartedInsideRef.current;\n    endedOrStartedInsideRef.current = false;\n    if (outsidePressEvent === 'click' && endedOrStartedInside) {\n      return;\n    }\n    if (insideReactTree) {\n      return;\n    }\n    if (typeof outsidePress === 'function' && !outsidePress(event)) {\n      return;\n    }\n    const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n    const inertSelector = \"[\" + createAttribute('inert') + \"]\";\n    const markers = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating).querySelectorAll(inertSelector);\n    let targetRootAncestor = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(target) ? target : null;\n    while (targetRootAncestor && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isLastTraversableNode)(targetRootAncestor)) {\n      const nextParent = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getParentNode)(targetRootAncestor);\n      if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isLastTraversableNode)(nextParent) || !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(nextParent)) {\n        break;\n      }\n      targetRootAncestor = nextParent;\n    }\n\n    // Check if the click occurred on a third-party element injected after the\n    // floating element rendered.\n    if (markers.length && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(target) && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isRootElement)(target) &&\n    // Clicked on a direct ancestor (e.g. FloatingOverlay).\n    !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(target, floating) &&\n    // If the target root element contains none of the markers, then the\n    // element was injected after the floating element rendered.\n    Array.from(markers).every(marker => !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(targetRootAncestor, marker))) {\n      return;\n    }\n\n    // Check if the click occurred on the scrollbar\n    if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(target) && floating) {\n      // In Firefox, `target.scrollWidth > target.clientWidth` for inline\n      // elements.\n      const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;\n      const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;\n      let xCond = canScrollY && event.offsetX > target.clientWidth;\n\n      // In some browsers it is possible to change the <body> (or window)\n      // scrollbar to the left side, but is very rare and is difficult to\n      // check for. Plus, for modal dialogs with backdrops, it is more\n      // important that the backdrop is checked but not so much the window.\n      if (canScrollY) {\n        const isRTL = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getComputedStyle)(target).direction === 'rtl';\n        if (isRTL) {\n          xCond = event.offsetX <= target.offsetWidth - target.clientWidth;\n        }\n      }\n      if (xCond || canScrollX && event.offsetY > target.clientHeight) {\n        return;\n      }\n    }\n    const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some(node => {\n      var _node$context;\n      return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isEventTargetWithin)(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);\n    });\n    if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isEventTargetWithin)(event, floating) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isEventTargetWithin)(event, domReference) || targetIsInsideChildren) {\n      return;\n    }\n    const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n    if (children.length > 0) {\n      let shouldDismiss = true;\n      children.forEach(child => {\n        var _child$context2;\n        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {\n          shouldDismiss = false;\n          return;\n        }\n      });\n      if (!shouldDismiss) {\n        return;\n      }\n    }\n    onOpenChange(false, event, 'outside-press');\n  });\n  const closeOnPressOutsideCapture = useEffectEvent(event => {\n    var _getTarget4;\n    const callback = () => {\n      var _getTarget3;\n      closeOnPressOutside(event);\n      (_getTarget3 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);\n    };\n    (_getTarget4 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);\n  });\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!open || !enabled) {\n      return;\n    }\n    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;\n    dataRef.current.__outsidePressBubbles = outsidePressBubbles;\n    function onScroll(event) {\n      onOpenChange(false, event, 'ancestor-scroll');\n    }\n    const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating);\n    escapeKey && doc.addEventListener('keydown', escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n    outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n    let ancestors = [];\n    if (ancestorScroll) {\n      if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(domReference)) {\n        ancestors = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors)(domReference);\n      }\n      if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(floating)) {\n        ancestors = ancestors.concat((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors)(floating));\n      }\n      if (!(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(reference) && reference && reference.contextElement) {\n        ancestors = ancestors.concat((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors)(reference.contextElement));\n      }\n    }\n\n    // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n    ancestors = ancestors.filter(ancestor => {\n      var _doc$defaultView;\n      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);\n    });\n    ancestors.forEach(ancestor => {\n      ancestor.addEventListener('scroll', onScroll, {\n        passive: true\n      });\n    });\n    return () => {\n      escapeKey && doc.removeEventListener('keydown', escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n      outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n      ancestors.forEach(ancestor => {\n        ancestor.removeEventListener('scroll', onScroll);\n      });\n    };\n  }, [dataRef, floating, domReference, reference, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]);\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    insideReactTreeRef.current = false;\n  }, [outsidePress, outsidePressEvent]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      reference: {\n        onKeyDown: closeOnEscapeKeyDown,\n        [bubbleHandlerKeys[referencePressEvent]]: event => {\n          if (referencePress) {\n            onOpenChange(false, event.nativeEvent, 'reference-press');\n          }\n        }\n      },\n      floating: {\n        onKeyDown: closeOnEscapeKeyDown,\n        onMouseDown() {\n          endedOrStartedInsideRef.current = true;\n        },\n        onMouseUp() {\n          endedOrStartedInsideRef.current = true;\n        },\n        [captureHandlerKeys[outsidePressEvent]]: () => {\n          insideReactTreeRef.current = true;\n        }\n      }\n    };\n  }, [enabled, referencePress, outsidePressEvent, referencePressEvent, onOpenChange, closeOnEscapeKeyDown]);\n}\nlet devMessageSet;\nif (true) {\n  devMessageSet = /*#__PURE__*/new Set();\n}\n\n/**\n * Provides data to position a floating element and context to add interactions.\n * @see https://floating-ui.com/docs/useFloating\n */\nfunction useFloating(options) {\n  var _options$elements2;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    open = false,\n    onOpenChange: unstable_onOpenChange,\n    nodeId\n  } = options;\n  if (true) {\n    var _options$elements;\n    const err = 'Floating UI: Cannot pass a virtual element to the ' + '`elements.reference` option, as it must be a real DOM element. ' + 'Use `refs.setPositionReference` instead.';\n    if ((_options$elements = options.elements) != null && _options$elements.reference && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(options.elements.reference)) {\n      var _devMessageSet;\n      if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(err))) {\n        var _devMessageSet2;\n        (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(err);\n        console.error(err);\n      }\n    }\n  }\n  const [_domReference, setDomReference] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n  const domReference = ((_options$elements2 = options.elements) == null ? void 0 : _options$elements2.reference) || _domReference;\n  const position = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.useFloating)(options);\n  const tree = useFloatingTree();\n  const nested = useFloatingParentNodeId() != null;\n  const onOpenChange = useEffectEvent((open, event, reason) => {\n    if (open) {\n      dataRef.current.openEvent = event;\n    }\n    events.emit('openchange', {\n      open,\n      event,\n      reason,\n      nested\n    });\n    unstable_onOpenChange == null || unstable_onOpenChange(open, event, reason);\n  });\n  const domReferenceRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const dataRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});\n  const events = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => createPubSub())[0];\n  const floatingId = useId();\n  const setPositionReference = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    const positionReference = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(node) ? {\n      getBoundingClientRect: () => node.getBoundingClientRect(),\n      contextElement: node\n    } : node;\n    position.refs.setReference(positionReference);\n  }, [position.refs]);\n  const setReference = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(node) || node === null) {\n      domReferenceRef.current = node;\n      setDomReference(node);\n    }\n\n    // Backwards-compatibility for passing a virtual element to `reference`\n    // after it has set the DOM reference.\n    if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(position.refs.reference.current) || position.refs.reference.current === null ||\n    // Don't allow setting virtual elements using the old technique back to\n    // `null` to support `positionReference` + an unstable `reference`\n    // callback ref.\n    node !== null && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(node)) {\n      position.refs.setReference(node);\n    }\n  }, [position.refs]);\n  const refs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => _objectSpread(_objectSpread({}, position.refs), {}, {\n    setReference,\n    setPositionReference,\n    domReference: domReferenceRef\n  }), [position.refs, setReference, setPositionReference]);\n  const elements = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => _objectSpread(_objectSpread({}, position.elements), {}, {\n    domReference: domReference\n  }), [position.elements, domReference]);\n  const context = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => _objectSpread(_objectSpread({}, position), {}, {\n    refs,\n    elements,\n    dataRef,\n    nodeId,\n    floatingId,\n    events,\n    open,\n    onOpenChange\n  }), [position, nodeId, floatingId, events, open, onOpenChange, refs, elements]);\n  index(() => {\n    const node = tree == null ? void 0 : tree.nodesRef.current.find(node => node.id === nodeId);\n    if (node) {\n      node.context = context;\n    }\n  });\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => _objectSpread(_objectSpread({}, position), {}, {\n    context,\n    refs,\n    elements\n  }), [position, refs, elements, context]);\n}\n\n/**\n * Opens the floating element while the reference element has focus, like CSS\n * `:focus`.\n * @see https://floating-ui.com/docs/useFocus\n */\nfunction useFocus(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    events,\n    refs,\n    elements: {\n      domReference\n    }\n  } = context;\n  const {\n    enabled = true,\n    visibleOnly = true\n  } = props;\n  const blockFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const keyboardModalityRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    const win = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getWindow)(domReference);\n\n    // If the reference was focused and the user left the tab/window, and the\n    // floating element was not open, the focus should be blocked when they\n    // return to the tab/window.\n    function onBlur() {\n      if (!open && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(domReference) && domReference === (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(domReference))) {\n        blockFocusRef.current = true;\n      }\n    }\n    function onKeyDown() {\n      keyboardModalityRef.current = true;\n    }\n    win.addEventListener('blur', onBlur);\n    win.addEventListener('keydown', onKeyDown, true);\n    return () => {\n      win.removeEventListener('blur', onBlur);\n      win.removeEventListener('keydown', onKeyDown, true);\n    };\n  }, [domReference, open, enabled]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onOpenChange(_ref) {\n      let {\n        reason\n      } = _ref;\n      if (reason === 'reference-press' || reason === 'escape-key') {\n        blockFocusRef.current = true;\n      }\n    }\n    events.on('openchange', onOpenChange);\n    return () => {\n      events.off('openchange', onOpenChange);\n    };\n  }, [events, enabled]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    return () => {\n      clearTimeout(timeoutRef.current);\n    };\n  }, []);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      reference: {\n        onPointerDown(event) {\n          if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualPointerEvent)(event.nativeEvent)) return;\n          keyboardModalityRef.current = false;\n        },\n        onMouseLeave() {\n          blockFocusRef.current = false;\n        },\n        onFocus(event) {\n          if (blockFocusRef.current) return;\n          const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event.nativeEvent);\n          if (visibleOnly && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(target)) {\n            try {\n              // Mac Safari unreliably matches `:focus-visible` on the reference\n              // if focus was outside the page initially - use the fallback\n              // instead.\n              if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isSafari)() && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMac)()) throw Error();\n              if (!target.matches(':focus-visible')) return;\n            } catch (e) {\n              // Old browsers will throw an error when using `:focus-visible`.\n              if (!keyboardModalityRef.current && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableElement)(target)) {\n                return;\n              }\n            }\n          }\n          onOpenChange(true, event.nativeEvent, 'focus');\n        },\n        onBlur(event) {\n          blockFocusRef.current = false;\n          const relatedTarget = event.relatedTarget;\n\n          // Hit the non-modal focus management portal guard. Focus will be\n          // moved into the floating element immediately after.\n          const movedToFocusGuard = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(relatedTarget) && relatedTarget.hasAttribute(createAttribute('focus-guard')) && relatedTarget.getAttribute('data-type') === 'outside';\n\n          // Wait for the window blur listener to fire.\n          timeoutRef.current = window.setTimeout(() => {\n            const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(domReference ? domReference.ownerDocument : document);\n\n            // Focus left the page, keep it open.\n            if (!relatedTarget && activeEl === domReference) return;\n\n            // When focusing the reference element (e.g. regular click), then\n            // clicking into the floating element, prevent it from hiding.\n            // Note: it must be focusable, e.g. `tabindex=\"-1\"`.\n            // We can not rely on relatedTarget to point to the correct element\n            // as it will only point to the shadow host of the newly focused element\n            // and not the element that actually has received focus if it is located\n            // inside a shadow root.\n            if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(refs.floating.current, activeEl) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(domReference, activeEl) || movedToFocusGuard) {\n              return;\n            }\n            onOpenChange(false, event.nativeEvent, 'focus');\n          });\n        }\n      }\n    };\n  }, [enabled, visibleOnly, domReference, refs, onOpenChange]);\n}\nconst ACTIVE_KEY = 'active';\nconst SELECTED_KEY = 'selected';\nfunction mergeProps(userProps, propsList, elementKey) {\n  const map = new Map();\n  const isItem = elementKey === 'item';\n  let domUserProps = userProps;\n  if (isItem && userProps) {\n    const {\n        [ACTIVE_KEY]: _,\n        [SELECTED_KEY]: __\n      } = userProps,\n      validProps = _objectWithoutProperties(userProps, [ACTIVE_KEY, SELECTED_KEY].map(_toPropertyKey));\n    domUserProps = validProps;\n  }\n  return _objectSpread(_objectSpread(_objectSpread({}, elementKey === 'floating' && {\n    tabIndex: -1\n  }), domUserProps), propsList.map(value => {\n    const propsOrGetProps = value ? value[elementKey] : null;\n    if (typeof propsOrGetProps === 'function') {\n      return userProps ? propsOrGetProps(userProps) : null;\n    }\n    return propsOrGetProps;\n  }).concat(userProps).reduce((acc, props) => {\n    if (!props) {\n      return acc;\n    }\n    Object.entries(props).forEach(_ref => {\n      let [key, value] = _ref;\n      if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {\n        return;\n      }\n      if (key.indexOf('on') === 0) {\n        if (!map.has(key)) {\n          map.set(key, []);\n        }\n        if (typeof value === 'function') {\n          var _map$get;\n          (_map$get = map.get(key)) == null || _map$get.push(value);\n          acc[key] = function () {\n            var _map$get2;\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n            return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map(fn => fn(...args)).find(val => val !== undefined);\n          };\n        }\n      } else {\n        acc[key] = value;\n      }\n    });\n    return acc;\n  }, {}));\n}\n\n/**\n * Merges an array of interaction hooks' props into prop getters, allowing\n * event handler functions to be composed together without overwriting one\n * another.\n * @see https://floating-ui.com/docs/useInteractions\n */\nfunction useInteractions(propsList) {\n  if (propsList === void 0) {\n    propsList = [];\n  }\n  // The dependencies are a dynamic array, so we can't use the linter's\n  // suggestion to add it to the deps array.\n  const deps = propsList;\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n  const getReferenceProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(userProps => mergeProps(userProps, propsList, 'reference'), deps);\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n  const getFloatingProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(userProps => mergeProps(userProps, propsList, 'floating'), deps);\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: intentional\n  const getItemProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(userProps => mergeProps(userProps, propsList, 'item'),\n  // Granularly check for `item` changes, because the `getItemProps` getter\n  // should be as referentially stable as possible since it may be passed as\n  // a prop to many components. All `item` key values must therefore be\n  // memoized.\n  propsList.map(key => key == null ? void 0 : key.item));\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    getReferenceProps,\n    getFloatingProps,\n    getItemProps\n  }), [getReferenceProps, getFloatingProps, getItemProps]);\n}\nlet isPreventScrollSupported = false;\nfunction doSwitch(orientation, vertical, horizontal) {\n  switch (orientation) {\n    case 'vertical':\n      return vertical;\n    case 'horizontal':\n      return horizontal;\n    default:\n      return vertical || horizontal;\n  }\n}\nfunction isMainOrientationKey(key, orientation) {\n  const vertical = key === ARROW_UP || key === ARROW_DOWN;\n  const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isMainOrientationToEndKey(key, orientation, rtl) {\n  const vertical = key === ARROW_DOWN;\n  const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal) || key === 'Enter' || key === ' ' || key === '';\n}\nfunction isCrossOrientationOpenKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  const horizontal = key === ARROW_DOWN;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isCrossOrientationCloseKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n  const horizontal = key === ARROW_UP;\n  return doSwitch(orientation, vertical, horizontal);\n}\n/**\n * Adds arrow key-based navigation of a list of items, either using real DOM\n * focus or virtual focus.\n * @see https://floating-ui.com/docs/useListNavigation\n */\nfunction useListNavigation(context, props) {\n  const {\n    open,\n    onOpenChange,\n    refs,\n    elements: {\n      domReference,\n      floating\n    }\n  } = context;\n  const {\n    listRef,\n    activeIndex,\n    onNavigate: unstable_onNavigate = () => {},\n    enabled = true,\n    selectedIndex = null,\n    allowEscape = false,\n    loop = false,\n    nested = false,\n    rtl = false,\n    virtual = false,\n    focusItemOnOpen = 'auto',\n    focusItemOnHover = true,\n    openOnArrowKeyDown = true,\n    disabledIndices = undefined,\n    orientation = 'vertical',\n    cols = 1,\n    scrollItemIntoView = true,\n    virtualItemRef,\n    itemSizes,\n    dense = false\n  } = props;\n  if (true) {\n    if (allowEscape) {\n      if (!loop) {\n        console.warn(['Floating UI: `useListNavigation` looping must be enabled to allow', 'escaping.'].join(' '));\n      }\n      if (!virtual) {\n        console.warn(['Floating UI: `useListNavigation` must be virtual to allow', 'escaping.'].join(' '));\n      }\n    }\n    if (orientation === 'vertical' && cols > 1) {\n      console.warn(['Floating UI: In grid list navigation mode (`cols` > 1), the', '`orientation` should be either \"horizontal\" or \"both\".'].join(' '));\n    }\n  }\n  const parentId = useFloatingParentNodeId();\n  const tree = useFloatingTree();\n  const onNavigate = useEffectEvent(unstable_onNavigate);\n  const focusItemOnOpenRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(focusItemOnOpen);\n  const indexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(selectedIndex != null ? selectedIndex : -1);\n  const keyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const isPointerModalityRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n  const previousOnNavigateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(onNavigate);\n  const previousMountedRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(!!floating);\n  const forceSyncFocus = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const forceScrollIntoViewRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const disabledIndicesRef = useLatestRef(disabledIndices);\n  const latestOpenRef = useLatestRef(open);\n  const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);\n  const [activeId, setActiveId] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  const [virtualId, setVirtualId] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  const focusItem = useEffectEvent(function (listRef, indexRef, forceScrollIntoView) {\n    if (forceScrollIntoView === void 0) {\n      forceScrollIntoView = false;\n    }\n    const item = listRef.current[indexRef.current];\n    if (!item) return;\n    if (virtual) {\n      setActiveId(item.id);\n      tree == null || tree.events.emit('virtualfocus', item);\n      if (virtualItemRef) {\n        virtualItemRef.current = item;\n      }\n    } else {\n      enqueueFocus(item, {\n        preventScroll: true,\n        // Mac Safari does not move the virtual cursor unless the focus call\n        // is sync. However, for the very first focus call, we need to wait\n        // for the position to be ready in order to prevent unwanted\n        // scrolling. This means the virtual cursor will not move to the first\n        // item when first opening the floating element, but will on\n        // subsequent calls. `preventScroll` is supported in modern Safari,\n        // so we can use that instead.\n        // iOS Safari must be async or the first item will not be focused.\n        sync: (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMac)() && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isSafari)() ? isPreventScrollSupported || forceSyncFocus.current : false\n      });\n    }\n    requestAnimationFrame(() => {\n      const scrollIntoViewOptions = scrollItemIntoViewRef.current;\n      const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);\n      if (shouldScrollIntoView) {\n        // JSDOM doesn't support `.scrollIntoView()` but it's widely supported\n        // by all browsers.\n        item.scrollIntoView == null || item.scrollIntoView(typeof scrollIntoViewOptions === 'boolean' ? {\n          block: 'nearest',\n          inline: 'nearest'\n        } : scrollIntoViewOptions);\n      }\n    });\n  });\n  index(() => {\n    document.createElement('div').focus({\n      get preventScroll() {\n        isPreventScrollSupported = true;\n        return false;\n      }\n    });\n  }, []);\n\n  // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n  // element. Also, reset `activeIndex` upon closing the floating element.\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (open && floating) {\n      if (focusItemOnOpenRef.current && selectedIndex != null) {\n        // Regardless of the pointer modality, we want to ensure the selected\n        // item comes into view when the floating element is opened.\n        forceScrollIntoViewRef.current = true;\n        indexRef.current = selectedIndex;\n        onNavigate(selectedIndex);\n      }\n    } else if (previousMountedRef.current) {\n      // Since the user can specify `onNavigate` conditionally\n      // (onNavigate: open ? setActiveIndex : setSelectedIndex),\n      // we store and call the previous function.\n      indexRef.current = -1;\n      previousOnNavigateRef.current(null);\n    }\n  }, [enabled, open, floating, selectedIndex, onNavigate]);\n\n  // Sync `activeIndex` to be the focused item while the floating element is\n  // open.\n  index(() => {\n    if (!enabled) {\n      return;\n    }\n    if (open && floating) {\n      if (activeIndex == null) {\n        forceSyncFocus.current = false;\n        if (selectedIndex != null) {\n          return;\n        }\n\n        // Reset while the floating element was open (e.g. the list changed).\n        if (previousMountedRef.current) {\n          indexRef.current = -1;\n          focusItem(listRef, indexRef);\n        }\n\n        // Initial sync.\n        if (!previousMountedRef.current && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n          let runs = 0;\n          const waitForListPopulated = () => {\n            if (listRef.current[0] == null) {\n              // Avoid letting the browser paint if possible on the first try,\n              // otherwise use rAF. Don't try more than twice, since something\n              // is wrong otherwise.\n              if (runs < 2) {\n                const scheduler = runs ? requestAnimationFrame : queueMicrotask;\n                scheduler(waitForListPopulated);\n              }\n              runs++;\n            } else {\n              indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);\n              keyRef.current = null;\n              onNavigate(indexRef.current);\n            }\n          };\n          waitForListPopulated();\n        }\n      } else if (!isIndexOutOfBounds(listRef, activeIndex)) {\n        indexRef.current = activeIndex;\n        focusItem(listRef, indexRef, forceScrollIntoViewRef.current);\n        forceScrollIntoViewRef.current = false;\n      }\n    }\n  }, [enabled, open, floating, activeIndex, selectedIndex, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);\n\n  // Ensure the parent floating element has focus when a nested child closes\n  // to allow arrow key navigation to work after the pointer leaves the child.\n  index(() => {\n    var _nodes$find;\n    if (!enabled || floating || !tree || virtual || !previousMountedRef.current) {\n      return;\n    }\n    const nodes = tree.nodesRef.current;\n    const parent = (_nodes$find = nodes.find(node => node.id === parentId)) == null || (_nodes$find = _nodes$find.context) == null ? void 0 : _nodes$find.elements.floating;\n    const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating));\n    const treeContainsActiveEl = nodes.some(node => node.context && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(node.context.elements.floating, activeEl));\n    if (parent && !treeContainsActiveEl && isPointerModalityRef.current) {\n      parent.focus({\n        preventScroll: true\n      });\n    }\n  }, [enabled, floating, tree, parentId, virtual]);\n  index(() => {\n    if (!enabled || !tree || !virtual || parentId) return;\n    function handleVirtualFocus(item) {\n      setVirtualId(item.id);\n      if (virtualItemRef) {\n        virtualItemRef.current = item;\n      }\n    }\n    tree.events.on('virtualfocus', handleVirtualFocus);\n    return () => {\n      tree.events.off('virtualfocus', handleVirtualFocus);\n    };\n  }, [enabled, tree, virtual, parentId, virtualItemRef]);\n  index(() => {\n    previousOnNavigateRef.current = onNavigate;\n    previousMountedRef.current = !!floating;\n  });\n  index(() => {\n    if (!open) {\n      keyRef.current = null;\n    }\n  }, [open]);\n  const hasActiveIndex = activeIndex != null;\n  const item = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    function syncCurrentTarget(currentTarget) {\n      if (!open) return;\n      const index = listRef.current.indexOf(currentTarget);\n      if (index !== -1) {\n        onNavigate(index);\n      }\n    }\n    const props = _objectSpread({\n      onFocus(_ref) {\n        let {\n          currentTarget\n        } = _ref;\n        syncCurrentTarget(currentTarget);\n      },\n      onClick: _ref2 => {\n        let {\n          currentTarget\n        } = _ref2;\n        return currentTarget.focus({\n          preventScroll: true\n        });\n      }\n    }, focusItemOnHover && {\n      onMouseMove(_ref3) {\n        let {\n          currentTarget\n        } = _ref3;\n        syncCurrentTarget(currentTarget);\n      },\n      onPointerLeave(_ref4) {\n        let {\n          pointerType\n        } = _ref4;\n        if (!isPointerModalityRef.current || pointerType === 'touch') {\n          return;\n        }\n        indexRef.current = -1;\n        focusItem(listRef, indexRef);\n        onNavigate(null);\n        if (!virtual) {\n          enqueueFocus(refs.floating.current, {\n            preventScroll: true\n          });\n        }\n      }\n    });\n    return props;\n  }, [open, refs, focusItem, focusItemOnHover, listRef, onNavigate, virtual]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    const disabledIndices = disabledIndicesRef.current;\n    function onKeyDown(event) {\n      isPointerModalityRef.current = false;\n      forceSyncFocus.current = true;\n\n      // If the floating element is animating out, ignore navigation. Otherwise,\n      // the `activeIndex` gets set to 0 despite not being open so the next time\n      // the user ArrowDowns, the first item won't be focused.\n      if (!latestOpenRef.current && event.currentTarget === refs.floating.current) {\n        return;\n      }\n      if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {\n        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n        onOpenChange(false, event.nativeEvent, 'list-navigation');\n        if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(domReference) && !virtual) {\n          domReference.focus();\n        }\n        return;\n      }\n      const currentIndex = indexRef.current;\n      const minIndex = getMinIndex(listRef, disabledIndices);\n      const maxIndex = getMaxIndex(listRef, disabledIndices);\n      if (event.key === 'Home') {\n        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n        indexRef.current = minIndex;\n        onNavigate(indexRef.current);\n      }\n      if (event.key === 'End') {\n        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n        indexRef.current = maxIndex;\n        onNavigate(indexRef.current);\n      }\n\n      // Grid navigation.\n      if (cols > 1) {\n        const sizes = itemSizes || Array.from({\n          length: listRef.current.length\n        }, () => ({\n          width: 1,\n          height: 1\n        }));\n        // To calculate movements on the grid, we use hypothetical cell indices\n        // as if every item was 1x1, then convert back to real indices.\n        const cellMap = buildCellMap(sizes, cols, dense);\n        const minGridIndex = cellMap.findIndex(index => index != null && !(disabledIndices != null && disabledIndices.includes(index)));\n        // last enabled index\n        const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !(disabledIndices != null && disabledIndices.includes(index)) ? cellIndex : foundIndex, -1);\n        indexRef.current = cellMap[getGridNavigatedIndex({\n          current: cellMap.map(itemIndex => itemIndex != null ? listRef.current[itemIndex] : null)\n        }, {\n          event,\n          orientation,\n          loop,\n          cols,\n          // treat undefined (empty grid spaces) as disabled indices so we\n          // don't end up in them\n          disabledIndices: getCellIndices([...(disabledIndices || []), undefined], cellMap),\n          minIndex: minGridIndex,\n          maxIndex: maxGridIndex,\n          prevIndex: getCellIndexOfCorner(indexRef.current, sizes, cellMap, cols,\n          // use a corner matching the edge closest to the direction\n          // we're moving in so we don't end up in the same item. Prefer\n          // top/left over bottom/right.\n          event.key === ARROW_DOWN ? 'bl' : event.key === ARROW_RIGHT ? 'tr' : 'tl'),\n          stopEvent: true\n        })]; // navigated cell will never be nullish\n\n        onNavigate(indexRef.current);\n        if (orientation === 'both') {\n          return;\n        }\n      }\n      if (isMainOrientationKey(event.key, orientation)) {\n        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n\n        // Reset the index if no item is focused.\n        if (open && !virtual && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(event.currentTarget.ownerDocument) === event.currentTarget) {\n          indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n          onNavigate(indexRef.current);\n          return;\n        }\n        if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n          if (loop) {\n            indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              disabledIndices\n            }));\n          }\n        } else {\n          if (loop) {\n            indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            });\n          } else {\n            indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {\n              startingIndex: currentIndex,\n              decrement: true,\n              disabledIndices\n            }));\n          }\n        }\n        if (isIndexOutOfBounds(listRef, indexRef.current)) {\n          onNavigate(null);\n        } else {\n          onNavigate(indexRef.current);\n        }\n      }\n    }\n    function checkVirtualMouse(event) {\n      if (focusItemOnOpen === 'auto' && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualClick)(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    function checkVirtualPointer(event) {\n      // `pointerdown` fires first, reset the state then perform the checks.\n      focusItemOnOpenRef.current = focusItemOnOpen;\n      if (focusItemOnOpen === 'auto' && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualPointerEvent)(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    const ariaActiveDescendantProp = virtual && open && hasActiveIndex && {\n      'aria-activedescendant': virtualId || activeId\n    };\n    const activeItem = listRef.current.find(item => (item == null ? void 0 : item.id) === activeId);\n    return {\n      reference: _objectSpread(_objectSpread({}, ariaActiveDescendantProp), {}, {\n        onKeyDown(event) {\n          isPointerModalityRef.current = false;\n          const isArrowKey = event.key.indexOf('Arrow') === 0;\n          const isCrossOpenKey = isCrossOrientationOpenKey(event.key, orientation, rtl);\n          const isCrossCloseKey = isCrossOrientationCloseKey(event.key, orientation, rtl);\n          const isMainKey = isMainOrientationKey(event.key, orientation);\n          const isNavigationKey = (nested ? isCrossOpenKey : isMainKey) || event.key === 'Enter' || event.key.trim() === '';\n          if (virtual && open) {\n            const rootNode = tree == null ? void 0 : tree.nodesRef.current.find(node => node.parentId == null);\n            const deepestNode = tree && rootNode ? getDeepestNode(tree.nodesRef.current, rootNode.id) : null;\n            if (isArrowKey && deepestNode && virtualItemRef) {\n              const eventObject = new KeyboardEvent('keydown', {\n                key: event.key,\n                bubbles: true\n              });\n              if (isCrossOpenKey || isCrossCloseKey) {\n                var _deepestNode$context, _deepestNode$context2;\n                const isCurrentTarget = ((_deepestNode$context = deepestNode.context) == null ? void 0 : _deepestNode$context.elements.domReference) === event.currentTarget;\n                const dispatchItem = isCrossCloseKey && !isCurrentTarget ? (_deepestNode$context2 = deepestNode.context) == null ? void 0 : _deepestNode$context2.elements.domReference : isCrossOpenKey ? activeItem : null;\n                if (dispatchItem) {\n                  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                  dispatchItem.dispatchEvent(eventObject);\n                  setVirtualId(undefined);\n                }\n              }\n              if (isMainKey && deepestNode.context) {\n                if (deepestNode.context.open && deepestNode.parentId && event.currentTarget !== deepestNode.context.elements.domReference) {\n                  var _deepestNode$context$;\n                  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                  (_deepestNode$context$ = deepestNode.context.elements.domReference) == null || _deepestNode$context$.dispatchEvent(eventObject);\n                  return;\n                }\n              }\n            }\n            return onKeyDown(event);\n          }\n\n          // If a floating element should not open on arrow key down, avoid\n          // setting `activeIndex` while it's closed.\n          if (!open && !openOnArrowKeyDown && isArrowKey) {\n            return;\n          }\n          if (isNavigationKey) {\n            keyRef.current = nested && isMainKey ? null : event.key;\n          }\n          if (nested) {\n            if (isCrossOpenKey) {\n              (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n              if (open) {\n                indexRef.current = getMinIndex(listRef, disabledIndices);\n                onNavigate(indexRef.current);\n              } else {\n                onOpenChange(true, event.nativeEvent, 'list-navigation');\n              }\n            }\n            return;\n          }\n          if (isMainKey) {\n            if (selectedIndex != null) {\n              indexRef.current = selectedIndex;\n            }\n            (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n            if (!open && openOnArrowKeyDown) {\n              onOpenChange(true, event.nativeEvent, 'list-navigation');\n            } else {\n              onKeyDown(event);\n            }\n            if (open) {\n              onNavigate(indexRef.current);\n            }\n          }\n        },\n        onFocus() {\n          if (open) {\n            onNavigate(null);\n          }\n        },\n        onPointerDown: checkVirtualPointer,\n        onMouseDown: checkVirtualMouse,\n        onClick: checkVirtualMouse\n      }),\n      floating: _objectSpread(_objectSpread({\n        'aria-orientation': orientation === 'both' ? undefined : orientation\n      }, !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableCombobox)(domReference) && ariaActiveDescendantProp), {}, {\n        onKeyDown,\n        onPointerMove() {\n          isPointerModalityRef.current = true;\n        }\n      }),\n      item\n    };\n  }, [domReference, refs, activeId, virtualId, disabledIndicesRef, latestOpenRef, listRef, enabled, orientation, rtl, virtual, open, hasActiveIndex, nested, selectedIndex, openOnArrowKeyDown, allowEscape, cols, loop, focusItemOnOpen, onNavigate, onOpenChange, item, tree, virtualItemRef, itemSizes, dense]);\n}\nconst componentRoleToAriaRoleMap = /*#__PURE__*/new Map([['select', 'listbox'], ['combobox', 'listbox'], ['label', false]]);\n\n/**\n * Adds base screen reader props to the reference and floating elements for a\n * given floating element `role`.\n * @see https://floating-ui.com/docs/useRole\n */\nfunction useRole(context, props) {\n  var _componentRoleToAriaR;\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    floatingId\n  } = context;\n  const {\n    enabled = true,\n    role = 'dialog'\n  } = props;\n  const ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role;\n  const referenceId = useId();\n  const parentId = useFloatingParentNodeId();\n  const isNested = parentId != null;\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) return {};\n    const floatingProps = _objectSpread({\n      id: floatingId\n    }, ariaRole && {\n      role: ariaRole\n    });\n    if (ariaRole === 'tooltip' || role === 'label') {\n      return {\n        reference: {\n          [\"aria-\" + (role === 'label' ? 'labelledby' : 'describedby')]: open ? floatingId : undefined\n        },\n        floating: floatingProps\n      };\n    }\n    return {\n      reference: _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({\n        'aria-expanded': open ? 'true' : 'false',\n        'aria-haspopup': ariaRole === 'alertdialog' ? 'dialog' : ariaRole,\n        'aria-controls': open ? floatingId : undefined\n      }, ariaRole === 'listbox' && {\n        role: 'combobox'\n      }), ariaRole === 'menu' && {\n        id: referenceId\n      }), ariaRole === 'menu' && isNested && {\n        role: 'menuitem'\n      }), role === 'select' && {\n        'aria-autocomplete': 'none'\n      }), role === 'combobox' && {\n        'aria-autocomplete': 'list'\n      }),\n      floating: _objectSpread(_objectSpread({}, floatingProps), ariaRole === 'menu' && {\n        'aria-labelledby': referenceId\n      }),\n      item(_ref) {\n        let {\n          active,\n          selected\n        } = _ref;\n        const commonProps = _objectSpread({\n          role: 'option'\n        }, active && {\n          id: floatingId + \"-option\"\n        });\n\n        // For `menu`, we are unable to tell if the item is a `menuitemradio`\n        // or `menuitemcheckbox`. For backwards-compatibility reasons, also\n        // avoid defaulting to `menuitem` as it may overwrite custom role props.\n        switch (role) {\n          case 'select':\n            return _objectSpread(_objectSpread({}, commonProps), {}, {\n              'aria-selected': active && selected\n            });\n          case 'combobox':\n            {\n              return _objectSpread(_objectSpread({}, commonProps), active && {\n                'aria-selected': true\n              });\n            }\n        }\n        return {};\n      }\n    };\n  }, [enabled, role, ariaRole, open, floatingId, referenceId, isNested]);\n}\n\n// Converts a JS style key like `backgroundColor` to a CSS transition-property\n// like `background-color`.\nconst camelCaseToKebabCase = str => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? '-' : '') + $.toLowerCase());\nfunction execWithArgsOrReturn(valueOrFn, args) {\n  return typeof valueOrFn === 'function' ? valueOrFn(args) : valueOrFn;\n}\nfunction useDelayUnmount(open, durationMs) {\n  const [isMounted, setIsMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(open);\n  if (open && !isMounted) {\n    setIsMounted(true);\n  }\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!open) {\n      const timeout = setTimeout(() => setIsMounted(false), durationMs);\n      return () => clearTimeout(timeout);\n    }\n  }, [open, durationMs]);\n  return isMounted;\n}\n/**\n * Provides a status string to apply CSS transitions to a floating element,\n * correctly handling placement-aware transitions.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstatus\n */\nfunction useTransitionStatus(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    elements: {\n      floating\n    }\n  } = context;\n  const {\n    duration = 250\n  } = props;\n  const isNumberDuration = typeof duration === 'number';\n  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n  const [initiated, setInitiated] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n  const [status, setStatus] = react__WEBPACK_IMPORTED_MODULE_0__.useState('unmounted');\n  const isMounted = useDelayUnmount(open, closeDuration);\n\n  // `initiated` check prevents this `setState` call from breaking\n  // <FloatingPortal />. This call is necessary to ensure subsequent opens\n  // after the initial one allows the correct side animation to play when the\n  // placement has changed.\n  index(() => {\n    if (initiated && !isMounted) {\n      setStatus('unmounted');\n    }\n  }, [initiated, isMounted]);\n  index(() => {\n    if (!floating) return;\n    if (open) {\n      setStatus('initial');\n      const frame = requestAnimationFrame(() => {\n        setStatus('open');\n      });\n      return () => {\n        cancelAnimationFrame(frame);\n      };\n    }\n    setInitiated(true);\n    setStatus('close');\n  }, [open, floating]);\n  return {\n    isMounted,\n    status\n  };\n}\n/**\n * Provides styles to apply CSS transitions to a floating element, correctly\n * handling placement-aware transitions. Wrapper around `useTransitionStatus`.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstyles\n */\nfunction useTransitionStyles(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    initial: unstable_initial = {\n      opacity: 0\n    },\n    open: unstable_open,\n    close: unstable_close,\n    common: unstable_common,\n    duration = 250\n  } = props;\n  const placement = context.placement;\n  const side = placement.split('-')[0];\n  const fnArgs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    side,\n    placement\n  }), [side, placement]);\n  const isNumberDuration = typeof duration === 'number';\n  const openDuration = (isNumberDuration ? duration : duration.open) || 0;\n  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n  const [styles, setStyles] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => _objectSpread(_objectSpread({}, execWithArgsOrReturn(unstable_common, fnArgs)), execWithArgsOrReturn(unstable_initial, fnArgs)));\n  const {\n    isMounted,\n    status\n  } = useTransitionStatus(context, {\n    duration\n  });\n  const initialRef = useLatestRef(unstable_initial);\n  const openRef = useLatestRef(unstable_open);\n  const closeRef = useLatestRef(unstable_close);\n  const commonRef = useLatestRef(unstable_common);\n  index(() => {\n    const initialStyles = execWithArgsOrReturn(initialRef.current, fnArgs);\n    const closeStyles = execWithArgsOrReturn(closeRef.current, fnArgs);\n    const commonStyles = execWithArgsOrReturn(commonRef.current, fnArgs);\n    const openStyles = execWithArgsOrReturn(openRef.current, fnArgs) || Object.keys(initialStyles).reduce((acc, key) => {\n      acc[key] = '';\n      return acc;\n    }, {});\n    if (status === 'initial') {\n      setStyles(styles => _objectSpread(_objectSpread({\n        transitionProperty: styles.transitionProperty\n      }, commonStyles), initialStyles));\n    }\n    if (status === 'open') {\n      setStyles(_objectSpread(_objectSpread({\n        transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(','),\n        transitionDuration: openDuration + \"ms\"\n      }, commonStyles), openStyles));\n    }\n    if (status === 'close') {\n      const styles = closeStyles || initialStyles;\n      setStyles(_objectSpread(_objectSpread({\n        transitionProperty: Object.keys(styles).map(camelCaseToKebabCase).join(','),\n        transitionDuration: closeDuration + \"ms\"\n      }, commonStyles), styles));\n    }\n  }, [closeDuration, closeRef, initialRef, openRef, commonRef, openDuration, status, fnArgs]);\n  return {\n    isMounted,\n    styles\n  };\n}\n\n/**\n * Provides a matching callback that can be used to focus an item as the user\n * types, often used in tandem with `useListNavigation()`.\n * @see https://floating-ui.com/docs/useTypeahead\n */\nfunction useTypeahead(context, props) {\n  var _ref;\n  const {\n    open,\n    dataRef\n  } = context;\n  const {\n    listRef,\n    activeIndex,\n    onMatch: unstable_onMatch,\n    onTypingChange: unstable_onTypingChange,\n    enabled = true,\n    findMatch = null,\n    resetMs = 750,\n    ignoreKeys = [],\n    selectedIndex = null\n  } = props;\n  const timeoutIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const stringRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef('');\n  const prevIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef((_ref = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref : -1);\n  const matchIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const onMatch = useEffectEvent(unstable_onMatch);\n  const onTypingChange = useEffectEvent(unstable_onTypingChange);\n  const findMatchRef = useLatestRef(findMatch);\n  const ignoreKeysRef = useLatestRef(ignoreKeys);\n  index(() => {\n    if (open) {\n      clearTimeout(timeoutIdRef.current);\n      matchIndexRef.current = null;\n      stringRef.current = '';\n    }\n  }, [open]);\n  index(() => {\n    // Sync arrow key navigation but not typeahead navigation.\n    if (open && stringRef.current === '') {\n      var _ref2;\n      prevIndexRef.current = (_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1;\n    }\n  }, [open, selectedIndex, activeIndex]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    function setTypingChange(value) {\n      if (value) {\n        if (!dataRef.current.typing) {\n          dataRef.current.typing = value;\n          onTypingChange(value);\n        }\n      } else {\n        if (dataRef.current.typing) {\n          dataRef.current.typing = value;\n          onTypingChange(value);\n        }\n      }\n    }\n    function getMatchingIndex(list, orderedList, string) {\n      const str = findMatchRef.current ? findMatchRef.current(orderedList, string) : orderedList.find(text => (text == null ? void 0 : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0);\n      return str ? list.indexOf(str) : -1;\n    }\n    function onKeyDown(event) {\n      const listContent = listRef.current;\n      if (stringRef.current.length > 0 && stringRef.current[0] !== ' ') {\n        if (getMatchingIndex(listContent, listContent, stringRef.current) === -1) {\n          setTypingChange(false);\n        } else if (event.key === ' ') {\n          (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n        }\n      }\n      if (listContent == null || ignoreKeysRef.current.includes(event.key) ||\n      // Character key.\n      event.key.length !== 1 ||\n      // Modifier key.\n      event.ctrlKey || event.metaKey || event.altKey) {\n        return;\n      }\n      if (open && event.key !== ' ') {\n        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n        setTypingChange(true);\n      }\n\n      // Bail out if the list contains a word like \"llama\" or \"aaron\". TODO:\n      // allow it in this case, too.\n      const allowRapidSuccessionOfFirstLetter = listContent.every(text => {\n        var _text$, _text$2;\n        return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;\n      });\n\n      // Allows the user to cycle through items that start with the same letter\n      // in rapid succession.\n      if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n      }\n      stringRef.current += event.key;\n      clearTimeout(timeoutIdRef.current);\n      timeoutIdRef.current = setTimeout(() => {\n        stringRef.current = '';\n        prevIndexRef.current = matchIndexRef.current;\n        setTypingChange(false);\n      }, resetMs);\n      const prevIndex = prevIndexRef.current;\n      const index = getMatchingIndex(listContent, [...listContent.slice((prevIndex || 0) + 1), ...listContent.slice(0, (prevIndex || 0) + 1)], stringRef.current);\n      if (index !== -1) {\n        onMatch(index);\n        matchIndexRef.current = index;\n      } else if (event.key !== ' ') {\n        stringRef.current = '';\n        setTypingChange(false);\n      }\n    }\n    return {\n      reference: {\n        onKeyDown\n      },\n      floating: {\n        onKeyDown,\n        onKeyUp(event) {\n          if (event.key === ' ') {\n            setTypingChange(false);\n          }\n        }\n      }\n    };\n  }, [enabled, open, dataRef, listRef, resetMs, ignoreKeysRef, findMatchRef, onMatch, onTypingChange]);\n}\nfunction getArgsWithCustomFloatingHeight(state, height) {\n  return _objectSpread(_objectSpread({}, state), {}, {\n    rects: _objectSpread(_objectSpread({}, state.rects), {}, {\n      floating: _objectSpread(_objectSpread({}, state.rects.floating), {}, {\n        height\n      })\n    })\n  });\n}\n/**\n * Positions the floating element such that an inner element inside\n * of it is anchored to the reference element.\n * @see https://floating-ui.com/docs/inner\n */\nconst inner = props => ({\n  name: 'inner',\n  options: props,\n  async fn(state) {\n    const {\n        listRef,\n        overflowRef,\n        onFallbackChange,\n        offset: innerOffset = 0,\n        index = 0,\n        minItemsVisible = 4,\n        referenceOverflowThreshold = 0,\n        scrollRef\n      } = props,\n      detectOverflowOptions = _objectWithoutProperties(props, _excluded6);\n    const {\n      rects,\n      elements: {\n        floating\n      }\n    } = state;\n    const item = listRef.current[index];\n    if (true) {\n      if (!state.placement.startsWith('bottom')) {\n        console.warn(['Floating UI: `placement` side must be \"bottom\" when using the', '`inner` middleware.'].join(' '));\n      }\n    }\n    if (!item) {\n      return {};\n    }\n    const nextArgs = _objectSpread(_objectSpread({}, state), await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.offset)(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state));\n    const el = (scrollRef == null ? void 0 : scrollRef.current) || floating;\n    const overflow = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.detectOverflow)(getArgsWithCustomFloatingHeight(nextArgs, el.scrollHeight), detectOverflowOptions);\n    const refOverflow = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.detectOverflow)(nextArgs, _objectSpread(_objectSpread({}, detectOverflowOptions), {}, {\n      elementContext: 'reference'\n    }));\n    const diffY = Math.max(0, overflow.top);\n    const nextY = nextArgs.y + diffY;\n    const maxHeight = Math.max(0, el.scrollHeight - diffY - Math.max(0, overflow.bottom));\n    el.style.maxHeight = maxHeight + \"px\";\n    el.scrollTop = diffY;\n\n    // There is not enough space, fallback to standard anchored positioning\n    if (onFallbackChange) {\n      if (el.offsetHeight < item.offsetHeight * Math.min(minItemsVisible, listRef.current.length - 1) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold) {\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_5__.flushSync)(() => onFallbackChange(true));\n      } else {\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_5__.flushSync)(() => onFallbackChange(false));\n      }\n    }\n    if (overflowRef) {\n      overflowRef.current = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.detectOverflow)(getArgsWithCustomFloatingHeight(_objectSpread(_objectSpread({}, nextArgs), {}, {\n        y: nextY\n      }), el.offsetHeight), detectOverflowOptions);\n    }\n    return {\n      y: nextY\n    };\n  }\n});\n/**\n * Changes the `inner` middleware's `offset` upon a `wheel` event to\n * expand the floating element's height, revealing more list items.\n * @see https://floating-ui.com/docs/inner\n */\nfunction useInnerOffset(context, props) {\n  const {\n    open,\n    elements\n  } = context;\n  const {\n    enabled = true,\n    overflowRef,\n    scrollRef,\n    onChange: unstable_onChange\n  } = props;\n  const onChange = useEffectEvent(unstable_onChange);\n  const controlledScrollingRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const prevScrollTopRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const initialOverflowRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    function onWheel(e) {\n      if (e.ctrlKey || !el || overflowRef.current == null) {\n        return;\n      }\n      const dY = e.deltaY;\n      const isAtTop = overflowRef.current.top >= -0.5;\n      const isAtBottom = overflowRef.current.bottom >= -0.5;\n      const remainingScroll = el.scrollHeight - el.clientHeight;\n      const sign = dY < 0 ? -1 : 1;\n      const method = dY < 0 ? 'max' : 'min';\n      if (el.scrollHeight <= el.clientHeight) {\n        return;\n      }\n      if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {\n        e.preventDefault();\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_5__.flushSync)(() => {\n          onChange(d => d + Math[method](dY, remainingScroll * sign));\n        });\n      } else if (/firefox/i.test((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getUserAgent)())) {\n        // Needed to propagate scrolling during momentum scrolling phase once\n        // it gets limited by the boundary. UX improvement, not critical.\n        el.scrollTop += dY;\n      }\n    }\n    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n    if (open && el) {\n      el.addEventListener('wheel', onWheel);\n\n      // Wait for the position to be ready.\n      requestAnimationFrame(() => {\n        prevScrollTopRef.current = el.scrollTop;\n        if (overflowRef.current != null) {\n          initialOverflowRef.current = _objectSpread({}, overflowRef.current);\n        }\n      });\n      return () => {\n        prevScrollTopRef.current = null;\n        initialOverflowRef.current = null;\n        el.removeEventListener('wheel', onWheel);\n      };\n    }\n  }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (!enabled) {\n      return {};\n    }\n    return {\n      floating: {\n        onKeyDown() {\n          controlledScrollingRef.current = true;\n        },\n        onWheel() {\n          controlledScrollingRef.current = false;\n        },\n        onPointerMove() {\n          controlledScrollingRef.current = false;\n        },\n        onScroll() {\n          const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n          if (!overflowRef.current || !el || !controlledScrollingRef.current) {\n            return;\n          }\n          if (prevScrollTopRef.current !== null) {\n            const scrollDiff = el.scrollTop - prevScrollTopRef.current;\n            if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {\n              (0,react_dom__WEBPACK_IMPORTED_MODULE_5__.flushSync)(() => onChange(d => d + scrollDiff));\n            }\n          }\n\n          // [Firefox] Wait for the height change to have been applied.\n          requestAnimationFrame(() => {\n            prevScrollTopRef.current = el.scrollTop;\n          });\n        }\n      }\n    };\n  }, [enabled, overflowRef, elements.floating, scrollRef, onChange]);\n}\nfunction isPointInPolygon(point, polygon) {\n  const [x, y] = point;\n  let isInside = false;\n  const length = polygon.length;\n  for (let i = 0, j = length - 1; i < length; j = i++) {\n    const [xi, yi] = polygon[i] || [0, 0];\n    const [xj, yj] = polygon[j] || [0, 0];\n    const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n    if (intersect) {\n      isInside = !isInside;\n    }\n  }\n  return isInside;\n}\nfunction isInside(point, rect) {\n  return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;\n}\n/**\n * Generates a safe polygon area that the user can traverse without closing the\n * floating element once leaving the reference element.\n * @see https://floating-ui.com/docs/useHover#safepolygon\n */\nfunction safePolygon(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    buffer = 0.5,\n    blockPointerEvents = false,\n    requireIntent = true\n  } = options;\n  let timeoutId;\n  let hasLanded = false;\n  let lastX = null;\n  let lastY = null;\n  let lastCursorTime = performance.now();\n  function getCursorSpeed(x, y) {\n    const currentTime = performance.now();\n    const elapsedTime = currentTime - lastCursorTime;\n    if (lastX === null || lastY === null || elapsedTime === 0) {\n      lastX = x;\n      lastY = y;\n      lastCursorTime = currentTime;\n      return null;\n    }\n    const deltaX = x - lastX;\n    const deltaY = y - lastY;\n    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    const speed = distance / elapsedTime; // px / ms\n\n    lastX = x;\n    lastY = y;\n    lastCursorTime = currentTime;\n    return speed;\n  }\n  const fn = _ref => {\n    let {\n      x,\n      y,\n      placement,\n      elements,\n      onClose,\n      nodeId,\n      tree\n    } = _ref;\n    return function onMouseMove(event) {\n      function close() {\n        clearTimeout(timeoutId);\n        onClose();\n      }\n      clearTimeout(timeoutId);\n      if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {\n        return;\n      }\n      const {\n        clientX,\n        clientY\n      } = event;\n      const clientPoint = [clientX, clientY];\n      const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n      const isLeave = event.type === 'mouseleave';\n      const isOverFloatingEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(elements.floating, target);\n      const isOverReferenceEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(elements.domReference, target);\n      const refRect = elements.domReference.getBoundingClientRect();\n      const rect = elements.floating.getBoundingClientRect();\n      const side = placement.split('-')[0];\n      const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n      const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;\n      const isOverReferenceRect = isInside(clientPoint, refRect);\n      const isFloatingWider = rect.width > refRect.width;\n      const isFloatingTaller = rect.height > refRect.height;\n      const left = (isFloatingWider ? refRect : rect).left;\n      const right = (isFloatingWider ? refRect : rect).right;\n      const top = (isFloatingTaller ? refRect : rect).top;\n      const bottom = (isFloatingTaller ? refRect : rect).bottom;\n      if (isOverFloatingEl) {\n        hasLanded = true;\n        if (!isLeave) {\n          return;\n        }\n      }\n      if (isOverReferenceEl) {\n        hasLanded = false;\n      }\n      if (isOverReferenceEl && !isLeave) {\n        hasLanded = true;\n        return;\n      }\n\n      // Prevent overlapping floating element from being stuck in an open-close\n      // loop: https://github.com/floating-ui/floating-ui/issues/1910\n      if (isLeave && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(event.relatedTarget) && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(elements.floating, event.relatedTarget)) {\n        return;\n      }\n\n      // If any nested child is open, abort.\n      if (tree && getChildren(tree.nodesRef.current, nodeId).some(_ref2 => {\n        let {\n          context\n        } = _ref2;\n        return context == null ? void 0 : context.open;\n      })) {\n        return;\n      }\n\n      // If the pointer is leaving from the opposite side, the \"buffer\" logic\n      // creates a point where the floating element remains open, but should be\n      // ignored.\n      // A constant of 1 handles floating point rounding errors.\n      if (side === 'top' && y >= refRect.bottom - 1 || side === 'bottom' && y <= refRect.top + 1 || side === 'left' && x >= refRect.right - 1 || side === 'right' && x <= refRect.left + 1) {\n        return close();\n      }\n\n      // Ignore when the cursor is within the rectangular trough between the\n      // two elements. Since the triangle is created from the cursor point,\n      // which can start beyond the ref element's edge, traversing back and\n      // forth from the ref to the floating element can cause it to close. This\n      // ensures it always remains open in that case.\n      let rectPoly = [];\n      switch (side) {\n        case 'top':\n          rectPoly = [[left, refRect.top + 1], [left, rect.bottom - 1], [right, rect.bottom - 1], [right, refRect.top + 1]];\n          break;\n        case 'bottom':\n          rectPoly = [[left, rect.top + 1], [left, refRect.bottom - 1], [right, refRect.bottom - 1], [right, rect.top + 1]];\n          break;\n        case 'left':\n          rectPoly = [[rect.right - 1, bottom], [rect.right - 1, top], [refRect.left + 1, top], [refRect.left + 1, bottom]];\n          break;\n        case 'right':\n          rectPoly = [[refRect.right - 1, bottom], [refRect.right - 1, top], [rect.left + 1, top], [rect.left + 1, bottom]];\n          break;\n      }\n      function getPolygon(_ref3) {\n        let [x, y] = _ref3;\n        switch (side) {\n          case 'top':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'bottom':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'left':\n            {\n              const cursorPointOne = [x + buffer + 1, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x + buffer + 1, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];\n              return [...commonPoints, cursorPointOne, cursorPointTwo];\n            }\n          case 'right':\n            {\n              const cursorPointOne = [x - buffer, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x - buffer, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n        }\n      }\n      if (isPointInPolygon([clientX, clientY], rectPoly)) {\n        return;\n      }\n      if (hasLanded && !isOverReferenceRect) {\n        return close();\n      }\n      if (!isLeave && requireIntent) {\n        const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);\n        const cursorSpeedThreshold = 0.1;\n        if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {\n          return close();\n        }\n      }\n      if (!isPointInPolygon([clientX, clientY], getPolygon([x, y]))) {\n        close();\n      } else if (!hasLanded && requireIntent) {\n        timeoutId = window.setTimeout(close, 40);\n      }\n    };\n  };\n  fn.__options = {\n    blockPointerEvents\n  };\n  return fn;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L2Rpc3QvZmxvYXRpbmctdWkucmVhY3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQzRCO0FBQytPO0FBQy9QO0FBQ21GO0FBQ2tFO0FBQzlDO0FBQzlHO0FBQ2dCOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNnRCxZQUFZQSxDQUFDQyxJQUFJLEVBQUU7RUFDMUI7RUFDQSxPQUFPakQsMENBQWEsQ0FBQyxNQUFNO0lBQ3pCLElBQUlpRCxJQUFJLENBQUNFLEtBQUssQ0FBQ0MsR0FBRyxJQUFJQSxHQUFHLElBQUksSUFBSSxDQUFDLEVBQUU7TUFDbEMsT0FBTyxJQUFJO0lBQ2I7SUFDQSxPQUFPQyxLQUFLLElBQUk7TUFDZEosSUFBSSxDQUFDSyxPQUFPLENBQUNGLEdBQUcsSUFBSTtRQUNsQixJQUFJLE9BQU9BLEdBQUcsS0FBSyxVQUFVLEVBQUU7VUFDN0JBLEdBQUcsQ0FBQ0MsS0FBSyxDQUFDO1FBQ1osQ0FBQyxNQUFNLElBQUlELEdBQUcsSUFBSSxJQUFJLEVBQUU7VUFDdEJBLEdBQUcsQ0FBQ0csT0FBTyxHQUFHRixLQUFLO1FBQ3JCO01BQ0YsQ0FBQyxDQUFDO0lBQ0osQ0FBQztFQUNILENBQUMsRUFBRUosSUFBSSxDQUFDO0FBQ1Y7O0FBRUE7QUFDQSxNQUFNTyxrQkFBa0IsR0FBR3hELHlMQUFLLENBQUMsYUFBYSxvQkFBb0IsQ0FBQ3lELFFBQVEsQ0FBQyxDQUFDLENBQUM7QUFDOUUsTUFBTUMsc0JBQXNCLEdBQUdGLGtCQUFrQixLQUFLRyxFQUFFLElBQUlBLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDakUsU0FBU0MsY0FBY0EsQ0FBQ0MsUUFBUSxFQUFFO0VBQ2hDLE1BQU1ULEdBQUcsR0FBR3BELHlDQUFZLENBQUMsTUFBTTtJQUM3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SUQsV0FBVyxLQUFLLElBQUksSUFBSUEsV0FBVyxHQUFHQyxvQkFBb0IsRUFBRTtVQUM5RCxPQUFPcGxCLEtBQUssQ0FBQyxDQUFDO1FBQ2hCO01BQ0Y7TUFDQSxJQUFJLENBQUMwaUIsZ0JBQWdCLENBQUMsQ0FBQzlrQixPQUFPLEVBQUVDLE9BQU8sQ0FBQyxFQUFFa25CLFVBQVUsQ0FBQyxDQUFDL3NCLENBQUMsRUFBRUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQzdEOEgsS0FBSyxDQUFDLENBQUM7TUFDVCxDQUFDLE1BQU0sSUFBSSxDQUFDdWpCLFNBQVMsSUFBSUQsYUFBYSxFQUFFO1FBQ3RDNWQsU0FBUyxHQUFHdkYsTUFBTSxDQUFDakQsVUFBVSxDQUFDOEMsS0FBSyxFQUFFLEVBQUUsQ0FBQztNQUMxQztJQUNGLENBQUM7RUFDSCxDQUFDO0VBQ0R4VyxFQUFFLENBQUM0VSxTQUFTLEdBQUc7SUFDYkM7RUFDRixDQUFDO0VBQ0QsT0FBTzdVLEVBQUU7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL3EtZ2VuaWUvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L2Rpc3QvZmxvYXRpbmctdWkucmVhY3QubWpzPzY2Y2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHN0b3BFdmVudCwgZ2V0RG9jdW1lbnQsIGlzTW91c2VMaWtlUG9pbnRlclR5cGUsIGNvbnRhaW5zLCBhY3RpdmVFbGVtZW50LCBpc1NhZmFyaSwgaXNUeXBlYWJsZUNvbWJvYm94LCBpc1ZpcnR1YWxDbGljaywgaXNWaXJ0dWFsUG9pbnRlckV2ZW50LCBnZXRUYXJnZXQsIGdldFBsYXRmb3JtLCBpc1R5cGVhYmxlRWxlbWVudCwgaXNSZWFjdEV2ZW50LCBpc1Jvb3RFbGVtZW50LCBpc0V2ZW50VGFyZ2V0V2l0aGluLCBpc01hYywgZ2V0VXNlckFnZW50IH0gZnJvbSAnQGZsb2F0aW5nLXVpL3JlYWN0L3V0aWxzJztcbmltcG9ydCB7IGZsb29yIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzJztcbmltcG9ydCB7IHBsYXRmb3JtLCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgdXNlRmxvYXRpbmcgYXMgdXNlRmxvYXRpbmckMSwgb2Zmc2V0LCBkZXRlY3RPdmVyZmxvdyB9IGZyb20gJ0BmbG9hdGluZy11aS9yZWFjdC1kb20nO1xuZXhwb3J0IHsgYXJyb3csIGF1dG9QbGFjZW1lbnQsIGF1dG9VcGRhdGUsIGNvbXB1dGVQb3NpdGlvbiwgZGV0ZWN0T3ZlcmZsb3csIGZsaXAsIGdldE92ZXJmbG93QW5jZXN0b3JzLCBoaWRlLCBpbmxpbmUsIGxpbWl0U2hpZnQsIG9mZnNldCwgcGxhdGZvcm0sIHNoaWZ0LCBzaXplIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGdldE5vZGVOYW1lLCBnZXRXaW5kb3csIGlzTGFzdFRyYXZlcnNhYmxlTm9kZSwgZ2V0UGFyZW50Tm9kZSwgZ2V0Q29tcHV0ZWRTdHlsZSB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscy9kb20nO1xuaW1wb3J0IHsgdGFiYmFibGUgfSBmcm9tICd0YWJiYWJsZSc7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwsIGZsdXNoU3luYyB9IGZyb20gJ3JlYWN0LWRvbSc7XG5cbi8qKlxuICogTWVyZ2VzIGFuIGFycmF5IG9mIHJlZnMgaW50byBhIHNpbmdsZSBtZW1vaXplZCBjYWxsYmFjayByZWYgb3IgYG51bGxgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3JlYWN0LXV0aWxzI3VzZW1lcmdlcmVmc1xuICovXG5mdW5jdGlvbiB1c2VNZXJnZVJlZnMocmVmcykge1xuICAvLyBiaW9tZS1pZ25vcmUgbGludC9jb3JyZWN0bmVzcy91c2VFeGhhdXN0aXZlRGVwZW5kZW5jaWVzOiBpbnRlbnRpb25hbFxuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHJlZnMuZXZlcnkocmVmID0+IHJlZiA9PSBudWxsKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSA9PiB7XG4gICAgICByZWZzLmZvckVhY2gocmVmID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZWYodmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSwgcmVmcyk7XG59XG5cbi8vIGB0b1N0cmluZygpYCBwcmV2ZW50cyBidW5kbGVycyBmcm9tIHRyeWluZyB0byBgaW1wb3J0IHsgdXNlSW5zZXJ0aW9uRWZmZWN0IH0gZnJvbSAncmVhY3QnYFxuY29uc3QgdXNlSW5zZXJ0aW9uRWZmZWN0ID0gUmVhY3RbLyojX19QVVJFX18qLyd1c2VJbnNlcnRpb25FZmZlY3QnLnRvU3RyaW5nKCldO1xuY29uc3QgdXNlU2FmZUluc2VydGlvbkVmZmVjdCA9IHVzZUluc2VydGlvbkVmZmVjdCB8fCAoZm4gPT4gZm4oKSk7XG5mdW5jdGlvbiB1c2VFZmZlY3RFdmVudChjYWxsYmFjaykge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYoKCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgYW4gZXZlbnQgaGFuZGxlciB3aGlsZSByZW5kZXJpbmcuJyk7XG4gICAgfVxuICB9KTtcbiAgdXNlU2FmZUluc2VydGlvbkVmZmVjdCgoKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSBjYWxsYmFjaztcbiAgfSk7XG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICByZXR1cm4gcmVmLmN1cnJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi5jdXJyZW50KC4uLmFyZ3MpO1xuICB9LCBbXSk7XG59XG5cbmNvbnN0IEFSUk9XX1VQID0gJ0Fycm93VXAnO1xuY29uc3QgQVJST1dfRE9XTiA9ICdBcnJvd0Rvd24nO1xuY29uc3QgQVJST1dfTEVGVCA9ICdBcnJvd0xlZnQnO1xuY29uc3QgQVJST1dfUklHSFQgPSAnQXJyb3dSaWdodCc7XG5mdW5jdGlvbiBpc0RpZmZlcmVudFJvdyhpbmRleCwgY29scywgcHJldlJvdykge1xuICByZXR1cm4gTWF0aC5mbG9vcihpbmRleCAvIGNvbHMpICE9PSBwcmV2Um93O1xufVxuZnVuY3Rpb24gaXNJbmRleE91dE9mQm91bmRzKGxpc3RSZWYsIGluZGV4KSB7XG4gIHJldHVybiBpbmRleCA8IDAgfHwgaW5kZXggPj0gbGlzdFJlZi5jdXJyZW50Lmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGdldE1pbkluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlcykge1xuICByZXR1cm4gZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgIGRpc2FibGVkSW5kaWNlc1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldE1heEluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlcykge1xuICByZXR1cm4gZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICBzdGFydGluZ0luZGV4OiBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoLFxuICAgIGRpc2FibGVkSW5kaWNlc1xuICB9KTtcbn1cbmZ1bmN0aW9uIGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIF90ZW1wKSB7XG4gIGxldCB7XG4gICAgc3RhcnRpbmdJbmRleCA9IC0xLFxuICAgIGRlY3JlbWVudCA9IGZhbHNlLFxuICAgIGRpc2FibGVkSW5kaWNlcyxcbiAgICBhbW91bnQgPSAxXG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgY29uc3QgbGlzdCA9IGxpc3RSZWYuY3VycmVudDtcbiAgY29uc3QgaXNEaXNhYmxlZEluZGV4ID0gZGlzYWJsZWRJbmRpY2VzID8gaW5kZXggPT4gZGlzYWJsZWRJbmRpY2VzLmluY2x1ZGVzKGluZGV4KSA6IGluZGV4ID0+IHtcbiAgICBjb25zdCBlbGVtZW50ID0gbGlzdFtpbmRleF07XG4gICAgcmV0dXJuIGVsZW1lbnQgPT0gbnVsbCB8fCBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcpID09PSAndHJ1ZSc7XG4gIH07XG4gIGxldCBpbmRleCA9IHN0YXJ0aW5nSW5kZXg7XG4gIGRvIHtcbiAgICBpbmRleCArPSBkZWNyZW1lbnQgPyAtYW1vdW50IDogYW1vdW50O1xuICB9IHdoaWxlIChpbmRleCA+PSAwICYmIGluZGV4IDw9IGxpc3QubGVuZ3RoIC0gMSAmJiBpc0Rpc2FibGVkSW5kZXgoaW5kZXgpKTtcbiAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gZ2V0R3JpZE5hdmlnYXRlZEluZGV4KGVsZW1lbnRzUmVmLCBfcmVmKSB7XG4gIGxldCB7XG4gICAgZXZlbnQsXG4gICAgb3JpZW50YXRpb24sXG4gICAgbG9vcCxcbiAgICBjb2xzLFxuICAgIGRpc2FibGVkSW5kaWNlcyxcbiAgICBtaW5JbmRleCxcbiAgICBtYXhJbmRleCxcbiAgICBwcmV2SW5kZXgsXG4gICAgc3RvcEV2ZW50OiBzdG9wID0gZmFsc2VcbiAgfSA9IF9yZWY7XG4gIGxldCBuZXh0SW5kZXggPSBwcmV2SW5kZXg7XG4gIGlmIChldmVudC5rZXkgPT09IEFSUk9XX1VQKSB7XG4gICAgc3RvcCAmJiBzdG9wRXZlbnQoZXZlbnQpO1xuICAgIGlmIChwcmV2SW5kZXggPT09IC0xKSB7XG4gICAgICBuZXh0SW5kZXggPSBtYXhJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgc3RhcnRpbmdJbmRleDogbmV4dEluZGV4LFxuICAgICAgICBhbW91bnQ6IGNvbHMsXG4gICAgICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICB9KTtcbiAgICAgIGlmIChsb29wICYmIChwcmV2SW5kZXggLSBjb2xzIDwgbWluSW5kZXggfHwgbmV4dEluZGV4IDwgMCkpIHtcbiAgICAgICAgY29uc3QgY29sID0gcHJldkluZGV4ICUgY29scztcbiAgICAgICAgY29uc3QgbWF4Q29sID0gbWF4SW5kZXggJSBjb2xzO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBtYXhJbmRleCAtIChtYXhDb2wgLSBjb2wpO1xuICAgICAgICBpZiAobWF4Q29sID09PSBjb2wpIHtcbiAgICAgICAgICBuZXh0SW5kZXggPSBtYXhJbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0SW5kZXggPSBtYXhDb2wgPiBjb2wgPyBvZmZzZXQgOiBvZmZzZXQgLSBjb2xzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0luZGV4T3V0T2ZCb3VuZHMoZWxlbWVudHNSZWYsIG5leHRJbmRleCkpIHtcbiAgICAgIG5leHRJbmRleCA9IHByZXZJbmRleDtcbiAgICB9XG4gIH1cbiAgaWYgKGV2ZW50LmtleSA9PT0gQVJST1dfRE9XTikge1xuICAgIHN0b3AgJiYgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICBpZiAocHJldkluZGV4ID09PSAtMSkge1xuICAgICAgbmV4dEluZGV4ID0gbWluSW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCxcbiAgICAgICAgYW1vdW50OiBjb2xzLFxuICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgIH0pO1xuICAgICAgaWYgKGxvb3AgJiYgcHJldkluZGV4ICsgY29scyA+IG1heEluZGV4KSB7XG4gICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4ICUgY29scyAtIGNvbHMsXG4gICAgICAgICAgYW1vdW50OiBjb2xzLFxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzSW5kZXhPdXRPZkJvdW5kcyhlbGVtZW50c1JlZiwgbmV4dEluZGV4KSkge1xuICAgICAgbmV4dEluZGV4ID0gcHJldkluZGV4O1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbWFpbnMgb24gdGhlIHNhbWUgcm93L2NvbHVtbi5cbiAgaWYgKG9yaWVudGF0aW9uID09PSAnYm90aCcpIHtcbiAgICBjb25zdCBwcmV2Um93ID0gZmxvb3IocHJldkluZGV4IC8gY29scyk7XG4gICAgaWYgKGV2ZW50LmtleSA9PT0gQVJST1dfUklHSFQpIHtcbiAgICAgIHN0b3AgJiYgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgIGlmIChwcmV2SW5kZXggJSBjb2xzICE9PSBjb2xzIC0gMSkge1xuICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChsb29wICYmIGlzRGlmZmVyZW50Um93KG5leHRJbmRleCwgY29scywgcHJldlJvdykpIHtcbiAgICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4IC0gcHJldkluZGV4ICUgY29scyAtIDEsXG4gICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsb29wKSB7XG4gICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4IC0gcHJldkluZGV4ICUgY29scyAtIDEsXG4gICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGlmZmVyZW50Um93KG5leHRJbmRleCwgY29scywgcHJldlJvdykpIHtcbiAgICAgICAgbmV4dEluZGV4ID0gcHJldkluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXZlbnQua2V5ID09PSBBUlJPV19MRUZUKSB7XG4gICAgICBzdG9wICYmIHN0b3BFdmVudChldmVudCk7XG4gICAgICBpZiAocHJldkluZGV4ICUgY29scyAhPT0gMCkge1xuICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXMsXG4gICAgICAgICAgZGVjcmVtZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobG9vcCAmJiBpc0RpZmZlcmVudFJvdyhuZXh0SW5kZXgsIGNvbHMsIHByZXZSb3cpKSB7XG4gICAgICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCArIChjb2xzIC0gcHJldkluZGV4ICUgY29scyksXG4gICAgICAgICAgICBkZWNyZW1lbnQ6IHRydWUsXG4gICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsb29wKSB7XG4gICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4ICsgKGNvbHMgLSBwcmV2SW5kZXggJSBjb2xzKSxcbiAgICAgICAgICBkZWNyZW1lbnQ6IHRydWUsXG4gICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGlmZmVyZW50Um93KG5leHRJbmRleCwgY29scywgcHJldlJvdykpIHtcbiAgICAgICAgbmV4dEluZGV4ID0gcHJldkluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsYXN0Um93ID0gZmxvb3IobWF4SW5kZXggLyBjb2xzKSA9PT0gcHJldlJvdztcbiAgICBpZiAoaXNJbmRleE91dE9mQm91bmRzKGVsZW1lbnRzUmVmLCBuZXh0SW5kZXgpKSB7XG4gICAgICBpZiAobG9vcCAmJiBsYXN0Um93KSB7XG4gICAgICAgIG5leHRJbmRleCA9IGV2ZW50LmtleSA9PT0gQVJST1dfTEVGVCA/IG1heEluZGV4IDogZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXggLSBwcmV2SW5kZXggJSBjb2xzIC0gMSxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0SW5kZXggPSBwcmV2SW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXh0SW5kZXg7XG59XG5cbi8qKiBGb3IgZWFjaCBjZWxsIGluZGV4LCBnZXRzIHRoZSBpdGVtIGluZGV4IHRoYXQgb2NjdXBpZXMgdGhhdCBjZWxsICovXG5mdW5jdGlvbiBidWlsZENlbGxNYXAoc2l6ZXMsIGNvbHMsIGRlbnNlKSB7XG4gIGNvbnN0IGNlbGxNYXAgPSBbXTtcbiAgbGV0IHN0YXJ0SW5kZXggPSAwO1xuICBzaXplcy5mb3JFYWNoKChfcmVmMiwgaW5kZXgpID0+IHtcbiAgICBsZXQge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gX3JlZjI7XG4gICAgaWYgKHdpZHRoID4gY29scykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbRmxvYXRpbmcgVUldOiBJbnZhbGlkIGdyaWQgLSBpdGVtIHdpZHRoIGF0IGluZGV4IFwiICsgaW5kZXggKyBcIiBpcyBncmVhdGVyIHRoYW4gZ3JpZCBjb2x1bW5zXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgaXRlbVBsYWNlZCA9IGZhbHNlO1xuICAgIGlmIChkZW5zZSkge1xuICAgICAgc3RhcnRJbmRleCA9IDA7XG4gICAgfVxuICAgIHdoaWxlICghaXRlbVBsYWNlZCkge1xuICAgICAgY29uc3QgdGFyZ2V0Q2VsbHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGhlaWdodDsgaisrKSB7XG4gICAgICAgICAgdGFyZ2V0Q2VsbHMucHVzaChzdGFydEluZGV4ICsgaSArIGogKiBjb2xzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0SW5kZXggJSBjb2xzICsgd2lkdGggPD0gY29scyAmJiB0YXJnZXRDZWxscy5ldmVyeShjZWxsID0+IGNlbGxNYXBbY2VsbF0gPT0gbnVsbCkpIHtcbiAgICAgICAgdGFyZ2V0Q2VsbHMuZm9yRWFjaChjZWxsID0+IHtcbiAgICAgICAgICBjZWxsTWFwW2NlbGxdID0gaW5kZXg7XG4gICAgICAgIH0pO1xuICAgICAgICBpdGVtUGxhY2VkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0SW5kZXgrKztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIGNvbnZlcnQgaW50byBhIG5vbi1zcGFyc2UgYXJyYXlcbiAgcmV0dXJuIFsuLi5jZWxsTWFwXTtcbn1cblxuLyoqIEdldHMgY2VsbCBpbmRleCBvZiBhbiBpdGVtJ3MgY29ybmVyIG9yIC0xIHdoZW4gaW5kZXggaXMgLTEuICovXG5mdW5jdGlvbiBnZXRDZWxsSW5kZXhPZkNvcm5lcihpbmRleCwgc2l6ZXMsIGNlbGxNYXAsIGNvbHMsIGNvcm5lcikge1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gLTE7XG4gIGNvbnN0IGZpcnN0Q2VsbEluZGV4ID0gY2VsbE1hcC5pbmRleE9mKGluZGV4KTtcbiAgc3dpdGNoIChjb3JuZXIpIHtcbiAgICBjYXNlICd0bCc6XG4gICAgICByZXR1cm4gZmlyc3RDZWxsSW5kZXg7XG4gICAgY2FzZSAndHInOlxuICAgICAgcmV0dXJuIGZpcnN0Q2VsbEluZGV4ICsgc2l6ZXNbaW5kZXhdLndpZHRoIC0gMTtcbiAgICBjYXNlICdibCc6XG4gICAgICByZXR1cm4gZmlyc3RDZWxsSW5kZXggKyAoc2l6ZXNbaW5kZXhdLmhlaWdodCAtIDEpICogY29scztcbiAgICBjYXNlICdicic6XG4gICAgICByZXR1cm4gY2VsbE1hcC5sYXN0SW5kZXhPZihpbmRleCk7XG4gIH1cbn1cblxuLyoqIEdldHMgYWxsIGNlbGwgaW5kaWNlcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIHNwZWNpZmllZCBpbmRpY2VzICovXG5mdW5jdGlvbiBnZXRDZWxsSW5kaWNlcyhpbmRpY2VzLCBjZWxsTWFwKSB7XG4gIHJldHVybiBjZWxsTWFwLmZsYXRNYXAoKGluZGV4LCBjZWxsSW5kZXgpID0+IGluZGljZXMuaW5jbHVkZXMoaW5kZXgpID8gW2NlbGxJbmRleF0gOiBbXSk7XG59XG5cbmxldCByYWZJZCA9IDA7XG5mdW5jdGlvbiBlbnF1ZXVlRm9jdXMoZWwsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgcHJldmVudFNjcm9sbCA9IGZhbHNlLFxuICAgIGNhbmNlbFByZXZpb3VzID0gdHJ1ZSxcbiAgICBzeW5jID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNhbmNlbFByZXZpb3VzICYmIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZklkKTtcbiAgY29uc3QgZXhlYyA9ICgpID0+IGVsID09IG51bGwgPyB2b2lkIDAgOiBlbC5mb2N1cyh7XG4gICAgcHJldmVudFNjcm9sbFxuICB9KTtcbiAgaWYgKHN5bmMpIHtcbiAgICBleGVjKCk7XG4gIH0gZWxzZSB7XG4gICAgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZXhlYyk7XG4gIH1cbn1cblxudmFyIGluZGV4ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxuZnVuY3Rpb24gc29ydEJ5RG9jdW1lbnRQb3NpdGlvbihhLCBiKSB7XG4gIGNvbnN0IHBvc2l0aW9uID0gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKTtcbiAgaWYgKHBvc2l0aW9uICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkcgfHwgcG9zaXRpb24gJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAocG9zaXRpb24gJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyB8fCBwb3NpdGlvbiAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTlMpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGFyZU1hcHNFcXVhbChtYXAxLCBtYXAyKSB7XG4gIGlmIChtYXAxLnNpemUgIT09IG1hcDIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXAxLmVudHJpZXMoKSkge1xuICAgIGlmICh2YWx1ZSAhPT0gbWFwMi5nZXQoa2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IEZsb2F0aW5nTGlzdENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIHJlZ2lzdGVyOiAoKSA9PiB7fSxcbiAgdW5yZWdpc3RlcjogKCkgPT4ge30sXG4gIG1hcDogLyojX19QVVJFX18qL25ldyBNYXAoKSxcbiAgZWxlbWVudHNSZWY6IHtcbiAgICBjdXJyZW50OiBbXVxuICB9XG59KTtcbi8qKlxuICogUHJvdmlkZXMgY29udGV4dCBmb3IgYSBsaXN0IG9mIGl0ZW1zIHdpdGhpbiB0aGUgZmxvYXRpbmcgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ0xpc3RcbiAqL1xuZnVuY3Rpb24gRmxvYXRpbmdMaXN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlbixcbiAgICBlbGVtZW50c1JlZixcbiAgICBsYWJlbHNSZWZcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IFttYXAsIHNldE1hcF0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgTWFwKCkpO1xuICBjb25zdCByZWdpc3RlciA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIHNldE1hcChwcmV2TWFwID0+IG5ldyBNYXAocHJldk1hcCkuc2V0KG5vZGUsIG51bGwpKTtcbiAgfSwgW10pO1xuICBjb25zdCB1bnJlZ2lzdGVyID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgc2V0TWFwKHByZXZNYXAgPT4ge1xuICAgICAgY29uc3QgbWFwID0gbmV3IE1hcChwcmV2TWFwKTtcbiAgICAgIG1hcC5kZWxldGUobm9kZSk7XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBjb25zdCBuZXdNYXAgPSBuZXcgTWFwKG1hcCk7XG4gICAgY29uc3Qgbm9kZXMgPSBBcnJheS5mcm9tKG5ld01hcC5rZXlzKCkpLnNvcnQoc29ydEJ5RG9jdW1lbnRQb3NpdGlvbik7XG4gICAgbm9kZXMuZm9yRWFjaCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICAgIG5ld01hcC5zZXQobm9kZSwgaW5kZXgpO1xuICAgIH0pO1xuICAgIGlmICghYXJlTWFwc0VxdWFsKG1hcCwgbmV3TWFwKSkge1xuICAgICAgc2V0TWFwKG5ld01hcCk7XG4gICAgfVxuICB9LCBbbWFwXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGbG9hdGluZ0xpc3RDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIHJlZ2lzdGVyLFxuICAgICAgdW5yZWdpc3RlcixcbiAgICAgIG1hcCxcbiAgICAgIGVsZW1lbnRzUmVmLFxuICAgICAgbGFiZWxzUmVmXG4gICAgfSksIFtyZWdpc3RlciwgdW5yZWdpc3RlciwgbWFwLCBlbGVtZW50c1JlZiwgbGFiZWxzUmVmXSlcbiAgfSwgY2hpbGRyZW4pO1xufVxuLyoqXG4gKiBVc2VkIHRvIHJlZ2lzdGVyIGEgbGlzdCBpdGVtIGFuZCBpdHMgaW5kZXggKERPTSBwb3NpdGlvbikgaW4gdGhlXG4gKiBgRmxvYXRpbmdMaXN0YC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ0xpc3QjdXNlbGlzdGl0ZW1cbiAqL1xuZnVuY3Rpb24gdXNlTGlzdEl0ZW0oX3RlbXApIHtcbiAgbGV0IHtcbiAgICBsYWJlbFxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGNvbnN0IFtpbmRleCQxLCBzZXRJbmRleF0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgY29tcG9uZW50UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCB7XG4gICAgcmVnaXN0ZXIsXG4gICAgdW5yZWdpc3RlcixcbiAgICBtYXAsXG4gICAgZWxlbWVudHNSZWYsXG4gICAgbGFiZWxzUmVmXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KEZsb2F0aW5nTGlzdENvbnRleHQpO1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBjb21wb25lbnRSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgaWYgKGluZGV4JDEgIT09IG51bGwpIHtcbiAgICAgIGVsZW1lbnRzUmVmLmN1cnJlbnRbaW5kZXgkMV0gPSBub2RlO1xuICAgICAgaWYgKGxhYmVsc1JlZikge1xuICAgICAgICB2YXIgX25vZGUkdGV4dENvbnRlbnQ7XG4gICAgICAgIGNvbnN0IGlzTGFiZWxEZWZpbmVkID0gbGFiZWwgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgbGFiZWxzUmVmLmN1cnJlbnRbaW5kZXgkMV0gPSBpc0xhYmVsRGVmaW5lZCA/IGxhYmVsIDogKF9ub2RlJHRleHRDb250ZW50ID0gbm9kZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZS50ZXh0Q29udGVudCkgIT0gbnVsbCA/IF9ub2RlJHRleHRDb250ZW50IDogbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtpbmRleCQxLCBlbGVtZW50c1JlZiwgbGFiZWxzUmVmLCBsYWJlbF0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IGNvbXBvbmVudFJlZi5jdXJyZW50O1xuICAgIGlmIChub2RlKSB7XG4gICAgICByZWdpc3Rlcihub2RlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHVucmVnaXN0ZXIobm9kZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW3JlZ2lzdGVyLCB1bnJlZ2lzdGVyXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBjb25zdCBpbmRleCA9IGNvbXBvbmVudFJlZi5jdXJyZW50ID8gbWFwLmdldChjb21wb25lbnRSZWYuY3VycmVudCkgOiBudWxsO1xuICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICBzZXRJbmRleChpbmRleCk7XG4gICAgfVxuICB9LCBbbWFwXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcmVmLFxuICAgIGluZGV4OiBpbmRleCQxID09IG51bGwgPyAtMSA6IGluZGV4JDFcbiAgfSksIFtpbmRleCQxLCByZWZdKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVySnN4KHJlbmRlciwgY29tcHV0ZWRQcm9wcykge1xuICBpZiAodHlwZW9mIHJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiByZW5kZXIoY29tcHV0ZWRQcm9wcyk7XG4gIH1cbiAgaWYgKHJlbmRlcikge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY2xvbmVFbGVtZW50KHJlbmRlciwgY29tcHV0ZWRQcm9wcyk7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIGNvbXB1dGVkUHJvcHMpO1xufVxuY29uc3QgQ29tcG9zaXRlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgYWN0aXZlSW5kZXg6IDAsXG4gIG9uTmF2aWdhdGU6ICgpID0+IHt9XG59KTtcbmNvbnN0IGhvcml6b250YWxLZXlzID0gW0FSUk9XX0xFRlQsIEFSUk9XX1JJR0hUXTtcbmNvbnN0IHZlcnRpY2FsS2V5cyA9IFtBUlJPV19VUCwgQVJST1dfRE9XTl07XG5jb25zdCBhbGxLZXlzID0gWy4uLmhvcml6b250YWxLZXlzLCAuLi52ZXJ0aWNhbEtleXNdO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzaW5nbGUgdGFiIHN0b3Agd2hvc2UgaXRlbXMgYXJlIG5hdmlnYXRlZCBieSBhcnJvdyBrZXlzLCB3aGljaFxuICogcHJvdmlkZXMgbGlzdCBuYXZpZ2F0aW9uIG91dHNpZGUgb2YgZmxvYXRpbmcgZWxlbWVudCBjb250ZXh0cy5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCB0byBlbmFibGUgbmF2aWdhdGlvbiBvZiBhIGxpc3Qgb2YgaXRlbXMgdGhhdCBhcmVu4oCZdCBwYXJ0IG9mIGFcbiAqIGZsb2F0aW5nIGVsZW1lbnQuIEEgbWVudWJhciBpcyBhbiBleGFtcGxlIG9mIGEgY29tcG9zaXRlLCB3aXRoIGVhY2ggcmVmZXJlbmNlXG4gKiBlbGVtZW50IGJlaW5nIGFuIGl0ZW0uXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvQ29tcG9zaXRlXG4gKi9cbmNvbnN0IENvbXBvc2l0ZSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIENvbXBvc2l0ZShfcmVmLCBmb3J3YXJkZWRSZWYpIHtcbiAgbGV0IHtcbiAgICByZW5kZXIsXG4gICAgb3JpZW50YXRpb24gPSAnYm90aCcsXG4gICAgbG9vcCA9IHRydWUsXG4gICAgY29scyA9IDEsXG4gICAgZGlzYWJsZWRJbmRpY2VzID0gW10sXG4gICAgYWN0aXZlSW5kZXg6IGV4dGVybmFsQWN0aXZlSW5kZXgsXG4gICAgb25OYXZpZ2F0ZTogZXh0ZXJuYWxTZXRBY3RpdmVJbmRleCxcbiAgICBpdGVtU2l6ZXMsXG4gICAgZGVuc2UgPSBmYWxzZSxcbiAgICAuLi5wcm9wc1xuICB9ID0gX3JlZjtcbiAgY29uc3QgW2ludGVybmFsQWN0aXZlSW5kZXgsIGludGVybmFsU2V0QWN0aXZlSW5kZXhdID0gUmVhY3QudXNlU3RhdGUoMCk7XG4gIGNvbnN0IGFjdGl2ZUluZGV4ID0gZXh0ZXJuYWxBY3RpdmVJbmRleCAhPSBudWxsID8gZXh0ZXJuYWxBY3RpdmVJbmRleCA6IGludGVybmFsQWN0aXZlSW5kZXg7XG4gIGNvbnN0IG9uTmF2aWdhdGUgPSB1c2VFZmZlY3RFdmVudChleHRlcm5hbFNldEFjdGl2ZUluZGV4ICE9IG51bGwgPyBleHRlcm5hbFNldEFjdGl2ZUluZGV4IDogaW50ZXJuYWxTZXRBY3RpdmVJbmRleCk7XG4gIGNvbnN0IGVsZW1lbnRzUmVmID0gUmVhY3QudXNlUmVmKFtdKTtcbiAgY29uc3QgcmVuZGVyRWxlbWVudFByb3BzID0gcmVuZGVyICYmIHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicgPyByZW5kZXIucHJvcHMgOiB7fTtcbiAgY29uc3QgY29udGV4dFZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIGFjdGl2ZUluZGV4LFxuICAgIG9uTmF2aWdhdGVcbiAgfSksIFthY3RpdmVJbmRleCwgb25OYXZpZ2F0ZV0pO1xuICBjb25zdCBpc0dyaWQgPSBjb2xzID4gMTtcbiAgZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgIGlmICghYWxsS2V5cy5pbmNsdWRlcyhldmVudC5rZXkpKSByZXR1cm47XG4gICAgbGV0IG5leHRJbmRleCA9IGFjdGl2ZUluZGV4O1xuICAgIGlmIChpc0dyaWQpIHtcbiAgICAgIGNvbnN0IHNpemVzID0gaXRlbVNpemVzIHx8IEFycmF5LmZyb20oe1xuICAgICAgICBsZW5ndGg6IGVsZW1lbnRzUmVmLmN1cnJlbnQubGVuZ3RoXG4gICAgICB9LCAoKSA9PiAoe1xuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgaGVpZ2h0OiAxXG4gICAgICB9KSk7XG4gICAgICAvLyBUbyBjYWxjdWxhdGUgbW92ZW1lbnRzIG9uIHRoZSBncmlkLCB3ZSB1c2UgaHlwb3RoZXRpY2FsIGNlbGwgaW5kaWNlc1xuICAgICAgLy8gYXMgaWYgZXZlcnkgaXRlbSB3YXMgMXgxLCB0aGVuIGNvbnZlcnQgYmFjayB0byByZWFsIGluZGljZXMuXG4gICAgICBjb25zdCBjZWxsTWFwID0gYnVpbGRDZWxsTWFwKHNpemVzLCBjb2xzLCBkZW5zZSk7XG4gICAgICBjb25zdCBtaW5HcmlkSW5kZXggPSBjZWxsTWFwLmZpbmRJbmRleChpbmRleCA9PiBpbmRleCAhPSBudWxsICYmICFkaXNhYmxlZEluZGljZXMuaW5jbHVkZXMoaW5kZXgpKTtcbiAgICAgIC8vIGxhc3QgZW5hYmxlZCBpbmRleFxuICAgICAgY29uc3QgbWF4R3JpZEluZGV4ID0gY2VsbE1hcC5yZWR1Y2UoKGZvdW5kSW5kZXgsIGluZGV4LCBjZWxsSW5kZXgpID0+IGluZGV4ICE9IG51bGwgJiYgIShkaXNhYmxlZEluZGljZXMgIT0gbnVsbCAmJiBkaXNhYmxlZEluZGljZXMuaW5jbHVkZXMoaW5kZXgpKSA/IGNlbGxJbmRleCA6IGZvdW5kSW5kZXgsIC0xKTtcbiAgICAgIG5leHRJbmRleCA9IGNlbGxNYXBbZ2V0R3JpZE5hdmlnYXRlZEluZGV4KHtcbiAgICAgICAgY3VycmVudDogY2VsbE1hcC5tYXAoaXRlbUluZGV4ID0+IGl0ZW1JbmRleCA/IGVsZW1lbnRzUmVmLmN1cnJlbnRbaXRlbUluZGV4XSA6IG51bGwpXG4gICAgICB9LCB7XG4gICAgICAgIGV2ZW50LFxuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgbG9vcCxcbiAgICAgICAgY29scyxcbiAgICAgICAgLy8gdHJlYXQgdW5kZWZpbmVkIChlbXB0eSBncmlkIHNwYWNlcykgYXMgZGlzYWJsZWQgaW5kaWNlcyBzbyB3ZVxuICAgICAgICAvLyBkb24ndCBlbmQgdXAgaW4gdGhlbVxuICAgICAgICBkaXNhYmxlZEluZGljZXM6IGdldENlbGxJbmRpY2VzKFsuLi5kaXNhYmxlZEluZGljZXMsIHVuZGVmaW5lZF0sIGNlbGxNYXApLFxuICAgICAgICBtaW5JbmRleDogbWluR3JpZEluZGV4LFxuICAgICAgICBtYXhJbmRleDogbWF4R3JpZEluZGV4LFxuICAgICAgICBwcmV2SW5kZXg6IGdldENlbGxJbmRleE9mQ29ybmVyKGFjdGl2ZUluZGV4LCBzaXplcywgY2VsbE1hcCwgY29scyxcbiAgICAgICAgLy8gdXNlIGEgY29ybmVyIG1hdGNoaW5nIHRoZSBlZGdlIGNsb3Nlc3QgdG8gdGhlIGRpcmVjdGlvbiB3ZSdyZVxuICAgICAgICAvLyBtb3ZpbmcgaW4gc28gd2UgZG9uJ3QgZW5kIHVwIGluIHRoZSBzYW1lIGl0ZW0uIFByZWZlclxuICAgICAgICAvLyB0b3AvbGVmdCBvdmVyIGJvdHRvbS9yaWdodC5cbiAgICAgICAgZXZlbnQua2V5ID09PSBBUlJPV19ET1dOID8gJ2JsJyA6IGV2ZW50LmtleSA9PT0gQVJST1dfUklHSFQgPyAndHInIDogJ3RsJylcbiAgICAgIH0pXTsgLy8gbmF2aWdhdGVkIGNlbGwgd2lsbCBuZXZlciBiZSBudWxsaXNoXG4gICAgfVxuICAgIGNvbnN0IG1pbkluZGV4ID0gZ2V0TWluSW5kZXgoZWxlbWVudHNSZWYsIGRpc2FibGVkSW5kaWNlcyk7XG4gICAgY29uc3QgbWF4SW5kZXggPSBnZXRNYXhJbmRleChlbGVtZW50c1JlZiwgZGlzYWJsZWRJbmRpY2VzKTtcbiAgICBjb25zdCB0b0VuZEtleXMgPSB7XG4gICAgICBob3Jpem9udGFsOiBbQVJST1dfUklHSFRdLFxuICAgICAgdmVydGljYWw6IFtBUlJPV19ET1dOXSxcbiAgICAgIGJvdGg6IFtBUlJPV19SSUdIVCwgQVJST1dfRE9XTl1cbiAgICB9W29yaWVudGF0aW9uXTtcbiAgICBjb25zdCB0b1N0YXJ0S2V5cyA9IHtcbiAgICAgIGhvcml6b250YWw6IFtBUlJPV19MRUZUXSxcbiAgICAgIHZlcnRpY2FsOiBbQVJST1dfVVBdLFxuICAgICAgYm90aDogW0FSUk9XX0xFRlQsIEFSUk9XX1VQXVxuICAgIH1bb3JpZW50YXRpb25dO1xuICAgIGNvbnN0IHByZXZlbnRlZEtleXMgPSBpc0dyaWQgPyBhbGxLZXlzIDoge1xuICAgICAgaG9yaXpvbnRhbDogaG9yaXpvbnRhbEtleXMsXG4gICAgICB2ZXJ0aWNhbDogdmVydGljYWxLZXlzLFxuICAgICAgYm90aDogYWxsS2V5c1xuICAgIH1bb3JpZW50YXRpb25dO1xuICAgIGlmIChuZXh0SW5kZXggPT09IGFjdGl2ZUluZGV4ICYmIFsuLi50b0VuZEtleXMsIC4uLnRvU3RhcnRLZXlzXS5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgICBpZiAobG9vcCAmJiBuZXh0SW5kZXggPT09IG1heEluZGV4ICYmIHRvRW5kS2V5cy5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgICAgIG5leHRJbmRleCA9IG1pbkluZGV4O1xuICAgICAgfSBlbHNlIGlmIChsb29wICYmIG5leHRJbmRleCA9PT0gbWluSW5kZXggJiYgdG9TdGFydEtleXMuaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICBuZXh0SW5kZXggPSBtYXhJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogbmV4dEluZGV4LFxuICAgICAgICAgIGRlY3JlbWVudDogdG9TdGFydEtleXMuaW5jbHVkZXMoZXZlbnQua2V5KSxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXh0SW5kZXggIT09IGFjdGl2ZUluZGV4ICYmICFpc0luZGV4T3V0T2ZCb3VuZHMoZWxlbWVudHNSZWYsIG5leHRJbmRleCkpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgaWYgKHByZXZlbnRlZEtleXMuaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgb25OYXZpZ2F0ZShuZXh0SW5kZXgpO1xuXG4gICAgICAvLyBXYWl0IGZvciBGb2N1c01hbmFnZXIgYHJldHVybkZvY3VzYCB0byBleGVjdXRlLlxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBlbnF1ZXVlRm9jdXMoZWxlbWVudHNSZWYuY3VycmVudFtuZXh0SW5kZXhdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBjb21wdXRlZFByb3BzID0ge1xuICAgIC4uLnByb3BzLFxuICAgIC4uLnJlbmRlckVsZW1lbnRQcm9wcyxcbiAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICAnYXJpYS1vcmllbnRhdGlvbic6IG9yaWVudGF0aW9uID09PSAnYm90aCcgPyB1bmRlZmluZWQgOiBvcmllbnRhdGlvbixcbiAgICBvbktleURvd24oZSkge1xuICAgICAgcHJvcHMub25LZXlEb3duID09IG51bGwgfHwgcHJvcHMub25LZXlEb3duKGUpO1xuICAgICAgcmVuZGVyRWxlbWVudFByb3BzLm9uS2V5RG93biA9PSBudWxsIHx8IHJlbmRlckVsZW1lbnRQcm9wcy5vbktleURvd24oZSk7XG4gICAgICBoYW5kbGVLZXlEb3duKGUpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvc2l0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFZhbHVlXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZsb2F0aW5nTGlzdCwge1xuICAgIGVsZW1lbnRzUmVmOiBlbGVtZW50c1JlZlxuICB9LCByZW5kZXJKc3gocmVuZGVyLCBjb21wdXRlZFByb3BzKSkpO1xufSk7XG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9Db21wb3NpdGVcbiAqL1xuY29uc3QgQ29tcG9zaXRlSXRlbSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIENvbXBvc2l0ZUl0ZW0oX3JlZjIsIGZvcndhcmRlZFJlZikge1xuICBsZXQge1xuICAgIHJlbmRlcixcbiAgICAuLi5wcm9wc1xuICB9ID0gX3JlZjI7XG4gIGNvbnN0IHJlbmRlckVsZW1lbnRQcm9wcyA9IHJlbmRlciAmJiB0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nID8gcmVuZGVyLnByb3BzIDoge307XG4gIGNvbnN0IHtcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvbk5hdmlnYXRlXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KENvbXBvc2l0ZUNvbnRleHQpO1xuICBjb25zdCB7XG4gICAgcmVmLFxuICAgIGluZGV4XG4gIH0gPSB1c2VMaXN0SXRlbSgpO1xuICBjb25zdCBtZXJnZWRSZWYgPSB1c2VNZXJnZVJlZnMoW3JlZiwgZm9yd2FyZGVkUmVmLCByZW5kZXJFbGVtZW50UHJvcHMucmVmXSk7XG4gIGNvbnN0IGlzQWN0aXZlID0gYWN0aXZlSW5kZXggPT09IGluZGV4O1xuICBjb25zdCBjb21wdXRlZFByb3BzID0ge1xuICAgIC4uLnByb3BzLFxuICAgIC4uLnJlbmRlckVsZW1lbnRQcm9wcyxcbiAgICByZWY6IG1lcmdlZFJlZixcbiAgICB0YWJJbmRleDogaXNBY3RpdmUgPyAwIDogLTEsXG4gICAgJ2RhdGEtYWN0aXZlJzogaXNBY3RpdmUgPyAnJyA6IHVuZGVmaW5lZCxcbiAgICBvbkZvY3VzKGUpIHtcbiAgICAgIHByb3BzLm9uRm9jdXMgPT0gbnVsbCB8fCBwcm9wcy5vbkZvY3VzKGUpO1xuICAgICAgcmVuZGVyRWxlbWVudFByb3BzLm9uRm9jdXMgPT0gbnVsbCB8fCByZW5kZXJFbGVtZW50UHJvcHMub25Gb2N1cyhlKTtcbiAgICAgIG9uTmF2aWdhdGUoaW5kZXgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHJlbmRlckpzeChyZW5kZXIsIGNvbXB1dGVkUHJvcHMpO1xufSk7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5sZXQgc2VydmVySGFuZG9mZkNvbXBsZXRlID0gZmFsc2U7XG5sZXQgY291bnQgPSAwO1xuY29uc3QgZ2VuSWQgPSAoKSA9PiBcImZsb2F0aW5nLXVpLVwiICsgY291bnQrKztcbmZ1bmN0aW9uIHVzZUZsb2F0aW5nSWQoKSB7XG4gIGNvbnN0IFtpZCwgc2V0SWRdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gc2VydmVySGFuZG9mZkNvbXBsZXRlID8gZ2VuSWQoKSA6IHVuZGVmaW5lZCk7XG5cbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvY29ycmVjdG5lc3MvdXNlRXhoYXVzdGl2ZURlcGVuZGVuY2llczogaW50ZW50aW9uYWxcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChpZCA9PSBudWxsKSB7XG4gICAgICBzZXRJZChnZW5JZCgpKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXNlcnZlckhhbmRvZmZDb21wbGV0ZSkge1xuICAgICAgc2VydmVySGFuZG9mZkNvbXBsZXRlID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgcmV0dXJuIGlkO1xufVxuXG4vLyBgdG9TdHJpbmcoKWAgcHJldmVudHMgYnVuZGxlcnMgZnJvbSB0cnlpbmcgdG8gYGltcG9ydCB7IHVzZUlkIH0gZnJvbSAncmVhY3QnYFxuY29uc3QgdXNlUmVhY3RJZCA9IFJlYWN0Wy8qI19fUFVSRV9fKi8ndXNlSWQnLnRvU3RyaW5nKCldO1xuXG4vKipcbiAqIFVzZXMgUmVhY3QgMTgncyBidWlsdC1pbiBgdXNlSWQoKWAgd2hlbiBhdmFpbGFibGUsIG9yIGZhbGxzIGJhY2sgdG8gYVxuICogc2xpZ2h0bHkgbGVzcyBwZXJmb3JtYW50IChyZXF1aXJpbmcgYSBkb3VibGUgcmVuZGVyKSBpbXBsZW1lbnRhdGlvbiBmb3JcbiAqIGVhcmxpZXIgUmVhY3QgdmVyc2lvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvcmVhY3QtdXRpbHMjdXNlaWRcbiAqL1xuY29uc3QgdXNlSWQgPSB1c2VSZWFjdElkIHx8IHVzZUZsb2F0aW5nSWQ7XG5cbi8qKlxuICogUmVuZGVycyBhIHBvaW50aW5nIGFycm93IHRyaWFuZ2xlLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nQXJyb3dcbiAqL1xuY29uc3QgRmxvYXRpbmdBcnJvdyA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEZsb2F0aW5nQXJyb3coX3JlZiwgcmVmKSB7XG4gIGxldCB7XG4gICAgY29udGV4dDoge1xuICAgICAgcGxhY2VtZW50LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgZmxvYXRpbmdcbiAgICAgIH0sXG4gICAgICBtaWRkbGV3YXJlRGF0YToge1xuICAgICAgICBhcnJvd1xuICAgICAgfVxuICAgIH0sXG4gICAgd2lkdGggPSAxNCxcbiAgICBoZWlnaHQgPSA3LFxuICAgIHRpcFJhZGl1cyA9IDAsXG4gICAgc3Ryb2tlV2lkdGggPSAwLFxuICAgIHN0YXRpY09mZnNldCxcbiAgICBzdHJva2UsXG4gICAgZCxcbiAgICBzdHlsZToge1xuICAgICAgdHJhbnNmb3JtLFxuICAgICAgLi4ucmVzdFN0eWxlXG4gICAgfSA9IHt9LFxuICAgIC4uLnJlc3RcbiAgfSA9IF9yZWY7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIXJlZikge1xuICAgICAgY29uc29sZS53YXJuKCdGbG9hdGluZyBVSTogVGhlIGByZWZgIHByb3AgaXMgcmVxdWlyZWQgZm9yIHRoZSBgRmxvYXRpbmdBcnJvd2AnLCAnY29tcG9uZW50LicpO1xuICAgIH1cbiAgfVxuICBjb25zdCBjbGlwUGF0aElkID0gdXNlSWQoKTtcbiAgaWYgKCFmbG9hdGluZykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gU3Ryb2tlcyBtdXN0IGJlIGRvdWJsZSB0aGUgYm9yZGVyIHdpZHRoLCB0aGlzIGVuc3VyZXMgdGhlIHN0cm9rZSdzIHdpZHRoXG4gIC8vIHdvcmtzIGFzIHlvdSdkIGV4cGVjdC5cbiAgc3Ryb2tlV2lkdGggKj0gMjtcbiAgY29uc3QgaGFsZlN0cm9rZVdpZHRoID0gc3Ryb2tlV2lkdGggLyAyO1xuICBjb25zdCBzdmdYID0gd2lkdGggLyAyICogKHRpcFJhZGl1cyAvIC04ICsgMSk7XG4gIGNvbnN0IHN2Z1kgPSBoZWlnaHQgLyAyICogdGlwUmFkaXVzIC8gNDtcbiAgY29uc3QgW3NpZGUsIGFsaWdubWVudF0gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKTtcbiAgY29uc3QgaXNSVEwgPSBwbGF0Zm9ybS5pc1JUTChmbG9hdGluZyk7XG4gIGNvbnN0IGlzQ3VzdG9tU2hhcGUgPSAhIWQ7XG4gIGNvbnN0IGlzVmVydGljYWxTaWRlID0gc2lkZSA9PT0gJ3RvcCcgfHwgc2lkZSA9PT0gJ2JvdHRvbSc7XG4gIGNvbnN0IHlPZmZzZXRQcm9wID0gc3RhdGljT2Zmc2V0ICYmIGFsaWdubWVudCA9PT0gJ2VuZCcgPyAnYm90dG9tJyA6ICd0b3AnO1xuICBsZXQgeE9mZnNldFByb3AgPSBzdGF0aWNPZmZzZXQgJiYgYWxpZ25tZW50ID09PSAnZW5kJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gIGlmIChzdGF0aWNPZmZzZXQgJiYgaXNSVEwpIHtcbiAgICB4T2Zmc2V0UHJvcCA9IGFsaWdubWVudCA9PT0gJ2VuZCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICB9XG4gIGNvbnN0IGFycm93WCA9IChhcnJvdyA9PSBudWxsID8gdm9pZCAwIDogYXJyb3cueCkgIT0gbnVsbCA/IHN0YXRpY09mZnNldCB8fCBhcnJvdy54IDogJyc7XG4gIGNvbnN0IGFycm93WSA9IChhcnJvdyA9PSBudWxsID8gdm9pZCAwIDogYXJyb3cueSkgIT0gbnVsbCA/IHN0YXRpY09mZnNldCB8fCBhcnJvdy55IDogJyc7XG4gIGNvbnN0IGRWYWx1ZSA9IGQgfHxcbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3R5bGUvdXNlVGVtcGxhdGU6IHJlYWRhYmlsaXR5XG4gICdNMCwwJyArIChcIiBIXCIgKyB3aWR0aCkgKyAoXCIgTFwiICsgKHdpZHRoIC0gc3ZnWCkgKyBcIixcIiArIChoZWlnaHQgLSBzdmdZKSkgKyAoXCIgUVwiICsgd2lkdGggLyAyICsgXCIsXCIgKyBoZWlnaHQgKyBcIiBcIiArIHN2Z1ggKyBcIixcIiArIChoZWlnaHQgLSBzdmdZKSkgKyAnIFonO1xuICBjb25zdCByb3RhdGlvbiA9IHtcbiAgICB0b3A6IGlzQ3VzdG9tU2hhcGUgPyAncm90YXRlKDE4MGRlZyknIDogJycsXG4gICAgbGVmdDogaXNDdXN0b21TaGFwZSA/ICdyb3RhdGUoOTBkZWcpJyA6ICdyb3RhdGUoLTkwZGVnKScsXG4gICAgYm90dG9tOiBpc0N1c3RvbVNoYXBlID8gJycgOiAncm90YXRlKDE4MGRlZyknLFxuICAgIHJpZ2h0OiBpc0N1c3RvbVNoYXBlID8gJ3JvdGF0ZSgtOTBkZWcpJyA6ICdyb3RhdGUoOTBkZWcpJ1xuICB9W3NpZGVdO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgcmVmOiByZWYsXG4gICAgd2lkdGg6IGlzQ3VzdG9tU2hhcGUgPyB3aWR0aCA6IHdpZHRoICsgc3Ryb2tlV2lkdGgsXG4gICAgaGVpZ2h0OiB3aWR0aCxcbiAgICB2aWV3Qm94OiBcIjAgMCBcIiArIHdpZHRoICsgXCIgXCIgKyAoaGVpZ2h0ID4gd2lkdGggPyBoZWlnaHQgOiB3aWR0aCksXG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgW3hPZmZzZXRQcm9wXTogYXJyb3dYLFxuICAgICAgW3lPZmZzZXRQcm9wXTogYXJyb3dZLFxuICAgICAgW3NpZGVdOiBpc1ZlcnRpY2FsU2lkZSB8fCBpc0N1c3RvbVNoYXBlID8gJzEwMCUnIDogXCJjYWxjKDEwMCUgLSBcIiArIHN0cm9rZVdpZHRoIC8gMiArIFwicHgpXCIsXG4gICAgICB0cmFuc2Zvcm06IFwiXCIgKyByb3RhdGlvbiArICh0cmFuc2Zvcm0gIT0gbnVsbCA/IHRyYW5zZm9ybSA6ICcnKSxcbiAgICAgIC4uLnJlc3RTdHlsZVxuICAgIH1cbiAgfSksIHN0cm9rZVdpZHRoID4gMCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGNsaXBQYXRoOiBcInVybCgjXCIgKyBjbGlwUGF0aElkICsgXCIpXCIsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgc3Ryb2tlOiBzdHJva2VcbiAgICAvLyBBY2NvdW50IGZvciB0aGUgc3Ryb2tlIG9uIHRoZSBmaWxsIHBhdGggcmVuZGVyZWQgYmVsb3cuXG4gICAgLFxuICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCArIChkID8gMCA6IDEpLFxuICAgIGQ6IGRWYWx1ZVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBzdHJva2U6IHN0cm9rZVdpZHRoICYmICFkID8gcmVzdC5maWxsIDogJ25vbmUnLFxuICAgIGQ6IGRWYWx1ZVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjbGlwUGF0aFwiLCB7XG4gICAgaWQ6IGNsaXBQYXRoSWRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHtcbiAgICB4OiAtaGFsZlN0cm9rZVdpZHRoLFxuICAgIHk6IGhhbGZTdHJva2VXaWR0aCAqIChpc0N1c3RvbVNoYXBlID8gLTEgOiAxKSxcbiAgICB3aWR0aDogd2lkdGggKyBzdHJva2VXaWR0aCxcbiAgICBoZWlnaHQ6IHdpZHRoXG4gIH0pKSk7XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlUHViU3ViKCkge1xuICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gIHJldHVybiB7XG4gICAgZW1pdChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIF9tYXAkZ2V0O1xuICAgICAgKF9tYXAkZ2V0ID0gbWFwLmdldChldmVudCkpID09IG51bGwgfHwgX21hcCRnZXQuZm9yRWFjaChoYW5kbGVyID0+IGhhbmRsZXIoZGF0YSkpO1xuICAgIH0sXG4gICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICBtYXAuc2V0KGV2ZW50LCBbLi4uKG1hcC5nZXQoZXZlbnQpIHx8IFtdKSwgbGlzdGVuZXJdKTtcbiAgICB9LFxuICAgIG9mZihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBfbWFwJGdldDI7XG4gICAgICBtYXAuc2V0KGV2ZW50LCAoKF9tYXAkZ2V0MiA9IG1hcC5nZXQoZXZlbnQpKSA9PSBudWxsID8gdm9pZCAwIDogX21hcCRnZXQyLmZpbHRlcihsID0+IGwgIT09IGxpc3RlbmVyKSkgfHwgW10pO1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgRmxvYXRpbmdOb2RlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgRmxvYXRpbmdUcmVlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhcmVudCBub2RlIGlkIGZvciBuZXN0ZWQgZmxvYXRpbmcgZWxlbWVudHMsIGlmIGF2YWlsYWJsZS5cbiAqIFJldHVybnMgYG51bGxgIGZvciB0b3AtbGV2ZWwgZmxvYXRpbmcgZWxlbWVudHMuXG4gKi9cbmNvbnN0IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkID0gKCkgPT4ge1xuICB2YXIgX1JlYWN0JHVzZUNvbnRleHQ7XG4gIHJldHVybiAoKF9SZWFjdCR1c2VDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChGbG9hdGluZ05vZGVDb250ZXh0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9SZWFjdCR1c2VDb250ZXh0LmlkKSB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuZWFyZXN0IGZsb2F0aW5nIHRyZWUgY29udGV4dCwgaWYgYXZhaWxhYmxlLlxuICovXG5jb25zdCB1c2VGbG9hdGluZ1RyZWUgPSAoKSA9PiBSZWFjdC51c2VDb250ZXh0KEZsb2F0aW5nVHJlZUNvbnRleHQpO1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhIG5vZGUgaW50byB0aGUgYEZsb2F0aW5nVHJlZWAsIHJldHVybmluZyBpdHMgaWQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdUcmVlXG4gKi9cbmZ1bmN0aW9uIHVzZUZsb2F0aW5nTm9kZUlkKGN1c3RvbVBhcmVudElkKSB7XG4gIGNvbnN0IGlkID0gdXNlSWQoKTtcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCByZWFjdFBhcmVudElkID0gdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQoKTtcbiAgY29uc3QgcGFyZW50SWQgPSBjdXN0b21QYXJlbnRJZCB8fCByZWFjdFBhcmVudElkO1xuICBpbmRleCgoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIGlkLFxuICAgICAgcGFyZW50SWRcbiAgICB9O1xuICAgIHRyZWUgPT0gbnVsbCB8fCB0cmVlLmFkZE5vZGUobm9kZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRyZWUgPT0gbnVsbCB8fCB0cmVlLnJlbW92ZU5vZGUobm9kZSk7XG4gICAgfTtcbiAgfSwgW3RyZWUsIGlkLCBwYXJlbnRJZF0pO1xuICByZXR1cm4gaWQ7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgcGFyZW50IG5vZGUgY29udGV4dCBmb3IgbmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nVHJlZVxuICovXG5mdW5jdGlvbiBGbG9hdGluZ05vZGUoX3JlZikge1xuICBsZXQge1xuICAgIGNoaWxkcmVuLFxuICAgIGlkXG4gIH0gPSBfcmVmO1xuICBjb25zdCBwYXJlbnRJZCA9IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkKCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGbG9hdGluZ05vZGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIGlkLFxuICAgICAgcGFyZW50SWRcbiAgICB9KSwgW2lkLCBwYXJlbnRJZF0pXG4gIH0sIGNoaWxkcmVuKTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBjb250ZXh0IGZvciBuZXN0ZWQgZmxvYXRpbmcgZWxlbWVudHMgd2hlbiB0aGV5IGFyZSBub3QgY2hpbGRyZW4gb2ZcbiAqIGVhY2ggb3RoZXIgb24gdGhlIERPTS5cbiAqIFRoaXMgaXMgbm90IG5lY2Vzc2FyeSBpbiBhbGwgY2FzZXMsIGV4Y2VwdCB3aGVuIHRoZXJlIG11c3QgYmUgZXhwbGljaXQgY29tbXVuaWNhdGlvbiBiZXR3ZWVuIHBhcmVudCBhbmQgY2hpbGQgZmxvYXRpbmcgZWxlbWVudHMuIEl0IGlzIG5lY2Vzc2FyeSBmb3I6XG4gKiAtIFRoZSBgYnViYmxlc2Agb3B0aW9uIGluIHRoZSBgdXNlRGlzbWlzcygpYCBIb29rXG4gKiAtIE5lc3RlZCB2aXJ0dWFsIGxpc3QgbmF2aWdhdGlvblxuICogLSBOZXN0ZWQgZmxvYXRpbmcgZWxlbWVudHMgdGhhdCBlYWNoIG9wZW4gb24gaG92ZXJcbiAqIC0gQ3VzdG9tIGNvbW11bmljYXRpb24gYmV0d2VlbiBwYXJlbnQgYW5kIGNoaWxkIGZsb2F0aW5nIGVsZW1lbnRzXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdUcmVlXG4gKi9cbmZ1bmN0aW9uIEZsb2F0aW5nVHJlZShfcmVmMikge1xuICBsZXQge1xuICAgIGNoaWxkcmVuXG4gIH0gPSBfcmVmMjtcbiAgY29uc3Qgbm9kZXNSZWYgPSBSZWFjdC51c2VSZWYoW10pO1xuICBjb25zdCBhZGROb2RlID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgbm9kZXNSZWYuY3VycmVudCA9IFsuLi5ub2Rlc1JlZi5jdXJyZW50LCBub2RlXTtcbiAgfSwgW10pO1xuICBjb25zdCByZW1vdmVOb2RlID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgbm9kZXNSZWYuY3VycmVudCA9IG5vZGVzUmVmLmN1cnJlbnQuZmlsdGVyKG4gPT4gbiAhPT0gbm9kZSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgZXZlbnRzID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gY3JlYXRlUHViU3ViKCkpWzBdO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRpbmdUcmVlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICBub2Rlc1JlZixcbiAgICAgIGFkZE5vZGUsXG4gICAgICByZW1vdmVOb2RlLFxuICAgICAgZXZlbnRzXG4gICAgfSksIFthZGROb2RlLCByZW1vdmVOb2RlLCBldmVudHNdKVxuICB9LCBjaGlsZHJlbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUF0dHJpYnV0ZShuYW1lKSB7XG4gIHJldHVybiBcImRhdGEtZmxvYXRpbmctdWktXCIgKyBuYW1lO1xufVxuXG5mdW5jdGlvbiB1c2VMYXRlc3RSZWYodmFsdWUpIHtcbiAgY29uc3QgcmVmID0gdXNlUmVmKHZhbHVlKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVmO1xufVxuXG5jb25zdCBzYWZlUG9seWdvbklkZW50aWZpZXIgPSAvKiNfX1BVUkVfXyovY3JlYXRlQXR0cmlidXRlKCdzYWZlLXBvbHlnb24nKTtcbmZ1bmN0aW9uIGdldERlbGF5KHZhbHVlLCBwcm9wLCBwb2ludGVyVHlwZSkge1xuICBpZiAocG9pbnRlclR5cGUgJiYgIWlzTW91c2VMaWtlUG9pbnRlclR5cGUocG9pbnRlclR5cGUpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZVtwcm9wXTtcbn1cbi8qKlxuICogT3BlbnMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgd2hpbGUgaG92ZXJpbmcgb3ZlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnQsIGxpa2VcbiAqIENTUyBgOmhvdmVyYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VIb3ZlclxuICovXG5mdW5jdGlvbiB1c2VIb3Zlcihjb250ZXh0LCBwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGRhdGFSZWYsXG4gICAgZXZlbnRzLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBkb21SZWZlcmVuY2UsXG4gICAgICBmbG9hdGluZ1xuICAgIH0sXG4gICAgcmVmc1xuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIGRlbGF5ID0gMCxcbiAgICBoYW5kbGVDbG9zZSA9IG51bGwsXG4gICAgbW91c2VPbmx5ID0gZmFsc2UsXG4gICAgcmVzdE1zID0gMCxcbiAgICBtb3ZlID0gdHJ1ZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgY29uc3QgcGFyZW50SWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpO1xuICBjb25zdCBoYW5kbGVDbG9zZVJlZiA9IHVzZUxhdGVzdFJlZihoYW5kbGVDbG9zZSk7XG4gIGNvbnN0IGRlbGF5UmVmID0gdXNlTGF0ZXN0UmVmKGRlbGF5KTtcbiAgY29uc3QgcG9pbnRlclR5cGVSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3QgdGltZW91dFJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBoYW5kbGVyUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IHJlc3RUaW1lb3V0UmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IGJsb2NrTW91c2VNb3ZlUmVmID0gUmVhY3QudXNlUmVmKHRydWUpO1xuICBjb25zdCBwZXJmb3JtZWRQb2ludGVyRXZlbnRzTXV0YXRpb25SZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCB1bmJpbmRNb3VzZU1vdmVSZWYgPSBSZWFjdC51c2VSZWYoKCkgPT4ge30pO1xuICBjb25zdCBpc0hvdmVyT3BlbiA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICB2YXIgX2RhdGFSZWYkY3VycmVudCRvcGVuO1xuICAgIGNvbnN0IHR5cGUgPSAoX2RhdGFSZWYkY3VycmVudCRvcGVuID0gZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhUmVmJGN1cnJlbnQkb3Blbi50eXBlO1xuICAgIHJldHVybiAodHlwZSA9PSBudWxsID8gdm9pZCAwIDogdHlwZS5pbmNsdWRlcygnbW91c2UnKSkgJiYgdHlwZSAhPT0gJ21vdXNlZG93bic7XG4gIH0sIFtkYXRhUmVmXSk7XG5cbiAgLy8gV2hlbiBjbG9zaW5nIGJlZm9yZSBvcGVuaW5nLCBjbGVhciB0aGUgZGVsYXkgdGltZW91dHMgdG8gY2FuY2VsIGl0XG4gIC8vIGZyb20gc2hvd2luZy5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25PcGVuQ2hhbmdlKF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIG9wZW5cbiAgICAgIH0gPSBfcmVmO1xuICAgICAgaWYgKCFvcGVuKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgICBjbGVhclRpbWVvdXQocmVzdFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICAgIGJsb2NrTW91c2VNb3ZlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBldmVudHMub24oJ29wZW5jaGFuZ2UnLCBvbk9wZW5DaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBldmVudHMub2ZmKCdvcGVuY2hhbmdlJywgb25PcGVuQ2hhbmdlKTtcbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgZXZlbnRzXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkIHx8ICFoYW5kbGVDbG9zZVJlZi5jdXJyZW50IHx8ICFvcGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTGVhdmUoZXZlbnQpIHtcbiAgICAgIGlmIChpc0hvdmVyT3BlbigpKSB7XG4gICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQsICdob3ZlcicpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnQoZmxvYXRpbmcpLmRvY3VtZW50RWxlbWVudDtcbiAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvbkxlYXZlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaHRtbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25MZWF2ZSk7XG4gICAgfTtcbiAgfSwgW2Zsb2F0aW5nLCBvcGVuLCBvbk9wZW5DaGFuZ2UsIGVuYWJsZWQsIGhhbmRsZUNsb3NlUmVmLCBpc0hvdmVyT3Blbl0pO1xuICBjb25zdCBjbG9zZVdpdGhEZWxheSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCwgcnVuRWxzZUJyYW5jaCwgcmVhc29uKSB7XG4gICAgaWYgKHJ1bkVsc2VCcmFuY2ggPT09IHZvaWQgMCkge1xuICAgICAgcnVuRWxzZUJyYW5jaCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChyZWFzb24gPT09IHZvaWQgMCkge1xuICAgICAgcmVhc29uID0gJ2hvdmVyJztcbiAgICB9XG4gICAgY29uc3QgY2xvc2VEZWxheSA9IGdldERlbGF5KGRlbGF5UmVmLmN1cnJlbnQsICdjbG9zZScsIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQpO1xuICAgIGlmIChjbG9zZURlbGF5ICYmICFoYW5kbGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgdGltZW91dFJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50LCByZWFzb24pLCBjbG9zZURlbGF5KTtcbiAgICB9IGVsc2UgaWYgKHJ1bkVsc2VCcmFuY2gpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCwgcmVhc29uKTtcbiAgICB9XG4gIH0sIFtkZWxheVJlZiwgb25PcGVuQ2hhbmdlXSk7XG4gIGNvbnN0IGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHVuYmluZE1vdXNlTW92ZVJlZi5jdXJyZW50KCk7XG4gICAgaGFuZGxlclJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICB9LCBbXSk7XG4gIGNvbnN0IGNsZWFyUG9pbnRlckV2ZW50cyA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAocGVyZm9ybWVkUG9pbnRlckV2ZW50c011dGF0aW9uUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IGJvZHkgPSBnZXREb2N1bWVudChyZWZzLmZsb2F0aW5nLmN1cnJlbnQpLmJvZHk7XG4gICAgICBib2R5LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICAgIGJvZHkucmVtb3ZlQXR0cmlidXRlKHNhZmVQb2x5Z29uSWRlbnRpZmllcik7XG4gICAgICBwZXJmb3JtZWRQb2ludGVyRXZlbnRzTXV0YXRpb25SZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH1cbiAgfSwgW3JlZnNdKTtcblxuICAvLyBSZWdpc3RlcmluZyB0aGUgbW91c2UgZXZlbnRzIG9uIHRoZSByZWZlcmVuY2UgZGlyZWN0bHkgdG8gYnlwYXNzIFJlYWN0J3NcbiAgLy8gZGVsZWdhdGlvbiBzeXN0ZW0uIElmIHRoZSBjdXJzb3Igd2FzIG9uIGEgZGlzYWJsZWQgZWxlbWVudCBhbmQgdGhlbiBlbnRlcmVkXG4gIC8vIHRoZSByZWZlcmVuY2UgKG5vIGdhcCksIGBtb3VzZWVudGVyYCBkb2Vzbid0IGZpcmUgaW4gdGhlIGRlbGVnYXRpb24gc3lzdGVtLlxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0NsaWNrTGlrZU9wZW5FdmVudCgpIHtcbiAgICAgIHJldHVybiBkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50ID8gWydjbGljaycsICdtb3VzZWRvd24nXS5pbmNsdWRlcyhkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50LnR5cGUpIDogZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VFbnRlcihldmVudCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICBibG9ja01vdXNlTW92ZVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBpZiAobW91c2VPbmx5ICYmICFpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQpIHx8IHJlc3RNcyA+IDAgJiYgZ2V0RGVsYXkoZGVsYXlSZWYuY3VycmVudCwgJ29wZW4nKSA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvcGVuRGVsYXkgPSBnZXREZWxheShkZWxheVJlZi5jdXJyZW50LCAnb3BlbicsIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQpO1xuICAgICAgaWYgKG9wZW5EZWxheSkge1xuICAgICAgICB0aW1lb3V0UmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQsICdob3ZlcicpO1xuICAgICAgICB9LCBvcGVuRGVsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50LCAnaG92ZXInKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25Nb3VzZUxlYXZlKGV2ZW50KSB7XG4gICAgICBpZiAoaXNDbGlja0xpa2VPcGVuRXZlbnQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB1bmJpbmRNb3VzZU1vdmVSZWYuY3VycmVudCgpO1xuICAgICAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQoZmxvYXRpbmcpO1xuICAgICAgY2xlYXJUaW1lb3V0KHJlc3RUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgaWYgKGhhbmRsZUNsb3NlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgLy8gUHJldmVudCBjbGVhcmluZyBgb25TY3JvbGxNb3VzZUxlYXZlYCB0aW1lb3V0LlxuICAgICAgICBpZiAoIW9wZW4pIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVyUmVmLmN1cnJlbnQgPSBoYW5kbGVDbG9zZVJlZi5jdXJyZW50KHtcbiAgICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICAgIHRyZWUsXG4gICAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICB5OiBldmVudC5jbGllbnRZLFxuICAgICAgICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgICAgICBjbGVhclBvaW50ZXJFdmVudHMoKTtcbiAgICAgICAgICAgIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyKCk7XG4gICAgICAgICAgICBjbG9zZVdpdGhEZWxheShldmVudCwgdHJ1ZSwgJ3NhZmUtcG9seWdvbicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVyKTtcbiAgICAgICAgdW5iaW5kTW91c2VNb3ZlUmVmLmN1cnJlbnQgPSAoKSA9PiB7XG4gICAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEFsbG93IGludGVyYWN0aXZpdHkgd2l0aG91dCBgc2FmZVBvbHlnb25gIG9uIHRvdWNoIGRldmljZXMuIFdpdGggYVxuICAgICAgLy8gcG9pbnRlciwgYSBzaG9ydCBjbG9zZSBkZWxheSBpcyBhbiBhbHRlcm5hdGl2ZSwgc28gaXQgc2hvdWxkIHdvcmtcbiAgICAgIC8vIGNvbnNpc3RlbnRseS5cbiAgICAgIGNvbnN0IHNob3VsZENsb3NlID0gcG9pbnRlclR5cGVSZWYuY3VycmVudCA9PT0gJ3RvdWNoJyA/ICFjb250YWlucyhmbG9hdGluZywgZXZlbnQucmVsYXRlZFRhcmdldCkgOiB0cnVlO1xuICAgICAgaWYgKHNob3VsZENsb3NlKSB7XG4gICAgICAgIGNsb3NlV2l0aERlbGF5KGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgY2xvc2VzIGFmdGVyIHNjcm9sbGluZyBldmVuIGlmIHRoZSBwb2ludGVyXG4gICAgLy8gZGlkIG5vdCBtb3ZlLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9kaXNjdXNzaW9ucy8xNjkyXG4gICAgZnVuY3Rpb24gb25TY3JvbGxNb3VzZUxlYXZlKGV2ZW50KSB7XG4gICAgICBpZiAoaXNDbGlja0xpa2VPcGVuRXZlbnQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBoYW5kbGVDbG9zZVJlZi5jdXJyZW50ID09IG51bGwgfHwgaGFuZGxlQ2xvc2VSZWYuY3VycmVudCh7XG4gICAgICAgIC4uLmNvbnRleHQsXG4gICAgICAgIHRyZWUsXG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgIHk6IGV2ZW50LmNsaWVudFksXG4gICAgICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgICAgY2xlYXJQb2ludGVyRXZlbnRzKCk7XG4gICAgICAgICAgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIoKTtcbiAgICAgICAgICBjbG9zZVdpdGhEZWxheShldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGlzRWxlbWVudChkb21SZWZlcmVuY2UpKSB7XG4gICAgICBjb25zdCByZWYgPSBkb21SZWZlcmVuY2U7XG4gICAgICBvcGVuICYmIHJlZi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25TY3JvbGxNb3VzZUxlYXZlKTtcbiAgICAgIGZsb2F0aW5nID09IG51bGwgfHwgZmxvYXRpbmcuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uU2Nyb2xsTW91c2VMZWF2ZSk7XG4gICAgICBtb3ZlICYmIHJlZi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlRW50ZXIsIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWYuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIG9uTW91c2VFbnRlcik7XG4gICAgICByZWYuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uTW91c2VMZWF2ZSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBvcGVuICYmIHJlZi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25TY3JvbGxNb3VzZUxlYXZlKTtcbiAgICAgICAgZmxvYXRpbmcgPT0gbnVsbCB8fCBmbG9hdGluZy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25TY3JvbGxNb3VzZUxlYXZlKTtcbiAgICAgICAgbW92ZSAmJiByZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZUVudGVyKTtcbiAgICAgICAgcmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBvbk1vdXNlRW50ZXIpO1xuICAgICAgICByZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uTW91c2VMZWF2ZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2RvbVJlZmVyZW5jZSwgZmxvYXRpbmcsIGVuYWJsZWQsIGNvbnRleHQsIG1vdXNlT25seSwgcmVzdE1zLCBtb3ZlLCBjbG9zZVdpdGhEZWxheSwgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIsIGNsZWFyUG9pbnRlckV2ZW50cywgb25PcGVuQ2hhbmdlLCBvcGVuLCB0cmVlLCBkZWxheVJlZiwgaGFuZGxlQ2xvc2VSZWYsIGRhdGFSZWZdKTtcblxuICAvLyBCbG9jayBwb2ludGVyLWV2ZW50cyBvZiBldmVyeSBlbGVtZW50IG90aGVyIHRoYW4gdGhlIHJlZmVyZW5jZSBhbmQgZmxvYXRpbmdcbiAgLy8gd2hpbGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgb3BlbiBhbmQgaGFzIGEgYGhhbmRsZUNsb3NlYCBoYW5kbGVyLiBBbHNvXG4gIC8vIGhhbmRsZXMgbmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzE3MjJcbiAgaW5kZXgoKCkgPT4ge1xuICAgIHZhciBfaGFuZGxlQ2xvc2VSZWYkY3VycmU7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcGVuICYmIChfaGFuZGxlQ2xvc2VSZWYkY3VycmUgPSBoYW5kbGVDbG9zZVJlZi5jdXJyZW50KSAhPSBudWxsICYmIF9oYW5kbGVDbG9zZVJlZiRjdXJyZS5fX29wdGlvbnMuYmxvY2tQb2ludGVyRXZlbnRzICYmIGlzSG92ZXJPcGVuKCkpIHtcbiAgICAgIGNvbnN0IGJvZHkgPSBnZXREb2N1bWVudChmbG9hdGluZykuYm9keTtcbiAgICAgIGJvZHkuc2V0QXR0cmlidXRlKHNhZmVQb2x5Z29uSWRlbnRpZmllciwgJycpO1xuICAgICAgYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgcGVyZm9ybWVkUG9pbnRlckV2ZW50c011dGF0aW9uUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgaWYgKGlzRWxlbWVudChkb21SZWZlcmVuY2UpICYmIGZsb2F0aW5nKSB7XG4gICAgICAgIHZhciBfdHJlZSRub2Rlc1JlZiRjdXJyZW47XG4gICAgICAgIGNvbnN0IHJlZiA9IGRvbVJlZmVyZW5jZTtcbiAgICAgICAgY29uc3QgcGFyZW50RmxvYXRpbmcgPSB0cmVlID09IG51bGwgfHwgKF90cmVlJG5vZGVzUmVmJGN1cnJlbiA9IHRyZWUubm9kZXNSZWYuY3VycmVudC5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gcGFyZW50SWQpKSA9PSBudWxsIHx8IChfdHJlZSRub2Rlc1JlZiRjdXJyZW4gPSBfdHJlZSRub2Rlc1JlZiRjdXJyZW4uY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90cmVlJG5vZGVzUmVmJGN1cnJlbi5lbGVtZW50cy5mbG9hdGluZztcbiAgICAgICAgaWYgKHBhcmVudEZsb2F0aW5nKSB7XG4gICAgICAgICAgcGFyZW50RmxvYXRpbmcuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJlZi5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xuICAgICAgICBmbG9hdGluZy5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIHJlZi5zdHlsZS5wb2ludGVyRXZlbnRzID0gJyc7XG4gICAgICAgICAgZmxvYXRpbmcuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2VuYWJsZWQsIG9wZW4sIHBhcmVudElkLCBmbG9hdGluZywgZG9tUmVmZXJlbmNlLCB0cmVlLCBoYW5kbGVDbG9zZVJlZiwgaXNIb3Zlck9wZW5dKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmICghb3Blbikge1xuICAgICAgcG9pbnRlclR5cGVSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyKCk7XG4gICAgICBjbGVhclBvaW50ZXJFdmVudHMoKTtcbiAgICB9XG4gIH0sIFtvcGVuLCBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlciwgY2xlYXJQb2ludGVyRXZlbnRzXSk7XG5cbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvY29ycmVjdG5lc3MvdXNlRXhoYXVzdGl2ZURlcGVuZGVuY2llczogaW50ZW50aW9uYWxcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIoKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgY2xlYXJUaW1lb3V0KHJlc3RUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgY2xlYXJQb2ludGVyRXZlbnRzKCk7XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIGRvbVJlZmVyZW5jZSwgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIsIGNsZWFyUG9pbnRlckV2ZW50c10pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFBvaW50ZXJSZWYoZXZlbnQpIHtcbiAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSBldmVudC5wb2ludGVyVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICBvblBvaW50ZXJEb3duOiBzZXRQb2ludGVyUmVmLFxuICAgICAgICBvblBvaW50ZXJFbnRlcjogc2V0UG9pbnRlclJlZixcbiAgICAgICAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgICBpZiAob3BlbiB8fCByZXN0TXMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHJlc3RUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgICAgIHJlc3RUaW1lb3V0UmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghYmxvY2tNb3VzZU1vdmVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQubmF0aXZlRXZlbnQsICdob3ZlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlc3RNcyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmbG9hdGluZzoge1xuICAgICAgICBvbk1vdXNlRW50ZXIoKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VMZWF2ZShldmVudCkge1xuICAgICAgICAgIGNsb3NlV2l0aERlbGF5KGV2ZW50Lm5hdGl2ZUV2ZW50LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgcmVzdE1zLCBvcGVuLCBvbk9wZW5DaGFuZ2UsIGNsb3NlV2l0aERlbGF5XSk7XG59XG5cbmNvbnN0IEZsb2F0aW5nRGVsYXlHcm91cENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIGRlbGF5OiAwLFxuICBpbml0aWFsRGVsYXk6IDAsXG4gIHRpbWVvdXRNczogMCxcbiAgY3VycmVudElkOiBudWxsLFxuICBzZXRDdXJyZW50SWQ6ICgpID0+IHt9LFxuICBzZXRTdGF0ZTogKCkgPT4ge30sXG4gIGlzSW5zdGFudFBoYXNlOiBmYWxzZVxufSk7XG5jb25zdCB1c2VEZWxheUdyb3VwQ29udGV4dCA9ICgpID0+IFJlYWN0LnVzZUNvbnRleHQoRmxvYXRpbmdEZWxheUdyb3VwQ29udGV4dCk7XG4vKipcbiAqIFByb3ZpZGVzIGNvbnRleHQgZm9yIGEgZ3JvdXAgb2YgZmxvYXRpbmcgZWxlbWVudHMgdGhhdCBzaG91bGQgc2hhcmUgYVxuICogYGRlbGF5YC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ0RlbGF5R3JvdXBcbiAqL1xuY29uc3QgRmxvYXRpbmdEZWxheUdyb3VwID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW4sXG4gICAgZGVsYXksXG4gICAgdGltZW91dE1zID0gMFxuICB9ID0gX3JlZjtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VSZWR1Y2VyKChwcmV2LCBuZXh0KSA9PiAoe1xuICAgIC4uLnByZXYsXG4gICAgLi4ubmV4dFxuICB9KSwge1xuICAgIGRlbGF5LFxuICAgIHRpbWVvdXRNcyxcbiAgICBpbml0aWFsRGVsYXk6IGRlbGF5LFxuICAgIGN1cnJlbnRJZDogbnVsbCxcbiAgICBpc0luc3RhbnRQaGFzZTogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IGluaXRpYWxDdXJyZW50SWRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHNldEN1cnJlbnRJZCA9IFJlYWN0LnVzZUNhbGxiYWNrKGN1cnJlbnRJZCA9PiB7XG4gICAgc2V0U3RhdGUoe1xuICAgICAgY3VycmVudElkXG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChzdGF0ZS5jdXJyZW50SWQpIHtcbiAgICAgIGlmIChpbml0aWFsQ3VycmVudElkUmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgaW5pdGlhbEN1cnJlbnRJZFJlZi5jdXJyZW50ID0gc3RhdGUuY3VycmVudElkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGlzSW5zdGFudFBoYXNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGlzSW5zdGFudFBoYXNlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBpbml0aWFsQ3VycmVudElkUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgW3N0YXRlLmN1cnJlbnRJZF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRpbmdEZWxheUdyb3VwQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHNldFN0YXRlLFxuICAgICAgc2V0Q3VycmVudElkXG4gICAgfSksIFtzdGF0ZSwgc2V0Q3VycmVudElkXSlcbiAgfSwgY2hpbGRyZW4pO1xufTtcbi8qKlxuICogRW5hYmxlcyBncm91cGluZyB3aGVuIGNhbGxlZCBpbnNpZGUgYSBjb21wb25lbnQgdGhhdCdzIGEgY2hpbGQgb2YgYVxuICogYEZsb2F0aW5nRGVsYXlHcm91cGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdEZWxheUdyb3VwXG4gKi9cbmNvbnN0IHVzZURlbGF5R3JvdXAgPSAoX3JlZjIsIF9yZWYzKSA9PiB7XG4gIGxldCB7XG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2VcbiAgfSA9IF9yZWYyO1xuICBsZXQge1xuICAgIGlkXG4gIH0gPSBfcmVmMztcbiAgY29uc3Qge1xuICAgIGN1cnJlbnRJZCxcbiAgICBzZXRDdXJyZW50SWQsXG4gICAgaW5pdGlhbERlbGF5LFxuICAgIHNldFN0YXRlLFxuICAgIHRpbWVvdXRNc1xuICB9ID0gdXNlRGVsYXlHcm91cENvbnRleHQoKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChjdXJyZW50SWQpIHtcbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgZGVsYXk6IHtcbiAgICAgICAgICBvcGVuOiAxLFxuICAgICAgICAgIGNsb3NlOiBnZXREZWxheShpbml0aWFsRGVsYXksICdjbG9zZScpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGN1cnJlbnRJZCAhPT0gaWQpIHtcbiAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtpZCwgb25PcGVuQ2hhbmdlLCBzZXRTdGF0ZSwgY3VycmVudElkLCBpbml0aWFsRGVsYXldKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIHVuc2V0KCkge1xuICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlKTtcbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgZGVsYXk6IGluaXRpYWxEZWxheSxcbiAgICAgICAgY3VycmVudElkOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFvcGVuICYmIGN1cnJlbnRJZCA9PT0gaWQpIHtcbiAgICAgIGlmICh0aW1lb3V0TXMpIHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KHVuc2V0LCB0aW1lb3V0TXMpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHVuc2V0KCk7XG4gICAgfVxuICB9LCBbb3Blbiwgc2V0U3RhdGUsIGN1cnJlbnRJZCwgaWQsIG9uT3BlbkNoYW5nZSwgaW5pdGlhbERlbGF5LCB0aW1lb3V0TXNdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChvcGVuKSB7XG4gICAgICBzZXRDdXJyZW50SWQoaWQpO1xuICAgIH1cbiAgfSwgW29wZW4sIHNldEN1cnJlbnRJZCwgaWRdKTtcbn07XG5cbmZ1bmN0aW9uIGdldEFuY2VzdG9ycyhub2RlcywgaWQpIHtcbiAgdmFyIF9ub2RlcyRmaW5kO1xuICBsZXQgYWxsQW5jZXN0b3JzID0gW107XG4gIGxldCBjdXJyZW50UGFyZW50SWQgPSAoX25vZGVzJGZpbmQgPSBub2Rlcy5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX25vZGVzJGZpbmQucGFyZW50SWQ7XG4gIHdoaWxlIChjdXJyZW50UGFyZW50SWQpIHtcbiAgICBjb25zdCBjdXJyZW50Tm9kZSA9IG5vZGVzLmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBjdXJyZW50UGFyZW50SWQpO1xuICAgIGN1cnJlbnRQYXJlbnRJZCA9IGN1cnJlbnROb2RlID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50Tm9kZS5wYXJlbnRJZDtcbiAgICBpZiAoY3VycmVudE5vZGUpIHtcbiAgICAgIGFsbEFuY2VzdG9ycyA9IGFsbEFuY2VzdG9ycy5jb25jYXQoY3VycmVudE5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWxsQW5jZXN0b3JzO1xufVxuXG5mdW5jdGlvbiBnZXRDaGlsZHJlbihub2RlcywgaWQpIHtcbiAgbGV0IGFsbENoaWxkcmVuID0gbm9kZXMuZmlsdGVyKG5vZGUgPT4ge1xuICAgIHZhciBfbm9kZSRjb250ZXh0O1xuICAgIHJldHVybiBub2RlLnBhcmVudElkID09PSBpZCAmJiAoKF9ub2RlJGNvbnRleHQgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0Lm9wZW4pO1xuICB9KTtcbiAgbGV0IGN1cnJlbnRDaGlsZHJlbiA9IGFsbENoaWxkcmVuO1xuICB3aGlsZSAoY3VycmVudENoaWxkcmVuLmxlbmd0aCkge1xuICAgIGN1cnJlbnRDaGlsZHJlbiA9IG5vZGVzLmZpbHRlcihub2RlID0+IHtcbiAgICAgIHZhciBfY3VycmVudENoaWxkcmVuO1xuICAgICAgcmV0dXJuIChfY3VycmVudENoaWxkcmVuID0gY3VycmVudENoaWxkcmVuKSA9PSBudWxsID8gdm9pZCAwIDogX2N1cnJlbnRDaGlsZHJlbi5zb21lKG4gPT4ge1xuICAgICAgICB2YXIgX25vZGUkY29udGV4dDI7XG4gICAgICAgIHJldHVybiBub2RlLnBhcmVudElkID09PSBuLmlkICYmICgoX25vZGUkY29udGV4dDIgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0Mi5vcGVuKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGFsbENoaWxkcmVuID0gYWxsQ2hpbGRyZW4uY29uY2F0KGN1cnJlbnRDaGlsZHJlbik7XG4gIH1cbiAgcmV0dXJuIGFsbENoaWxkcmVuO1xufVxuZnVuY3Rpb24gZ2V0RGVlcGVzdE5vZGUobm9kZXMsIGlkKSB7XG4gIGxldCBkZWVwZXN0Tm9kZUlkO1xuICBsZXQgbWF4RGVwdGggPSAtMTtcbiAgZnVuY3Rpb24gZmluZERlZXBlc3Qobm9kZUlkLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA+IG1heERlcHRoKSB7XG4gICAgICBkZWVwZXN0Tm9kZUlkID0gbm9kZUlkO1xuICAgICAgbWF4RGVwdGggPSBkZXB0aDtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbihub2Rlcywgbm9kZUlkKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGZpbmREZWVwZXN0KGNoaWxkLmlkLCBkZXB0aCArIDEpO1xuICAgIH0pO1xuICB9XG4gIGZpbmREZWVwZXN0KGlkLCAwKTtcbiAgcmV0dXJuIG5vZGVzLmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBkZWVwZXN0Tm9kZUlkKTtcbn1cblxuLy8gTW9kaWZpZWQgdG8gYWRkIGNvbmRpdGlvbmFsIGBhcmlhLWhpZGRlbmAgc3VwcG9ydDpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVLYXNoZXkvYXJpYS1oaWRkZW4vYmxvYi85MjIwYzhmNGE0ZmQzNWY2M2JlZTU1MTBhOWY0MWEzNzI2NDM4MmQ0L3NyYy9pbmRleC50c1xubGV0IGNvdW50ZXJNYXAgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbmxldCB1bmNvbnRyb2xsZWRFbGVtZW50c1NldCA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha1NldCgpO1xubGV0IG1hcmtlck1hcCA9IHt9O1xubGV0IGxvY2tDb3VudCA9IDA7XG5jb25zdCBzdXBwb3J0c0luZXJ0ID0gKCkgPT4gdHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAnaW5lcnQnIGluIEhUTUxFbGVtZW50LnByb3RvdHlwZTtcbmNvbnN0IHVud3JhcEhvc3QgPSBub2RlID0+IG5vZGUgJiYgKG5vZGUuaG9zdCB8fCB1bndyYXBIb3N0KG5vZGUucGFyZW50Tm9kZSkpO1xuY29uc3QgY29ycmVjdEVsZW1lbnRzID0gKHBhcmVudCwgdGFyZ2V0cykgPT4gdGFyZ2V0cy5tYXAodGFyZ2V0ID0+IHtcbiAgaWYgKHBhcmVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBjb25zdCBjb3JyZWN0ZWRUYXJnZXQgPSB1bndyYXBIb3N0KHRhcmdldCk7XG4gIGlmIChwYXJlbnQuY29udGFpbnMoY29ycmVjdGVkVGFyZ2V0KSkge1xuICAgIHJldHVybiBjb3JyZWN0ZWRUYXJnZXQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59KS5maWx0ZXIoeCA9PiB4ICE9IG51bGwpO1xuZnVuY3Rpb24gYXBwbHlBdHRyaWJ1dGVUb090aGVycyh1bmNvcnJlY3RlZEF2b2lkRWxlbWVudHMsIGJvZHksIGFyaWFIaWRkZW4sIGluZXJ0KSB7XG4gIGNvbnN0IG1hcmtlck5hbWUgPSAnZGF0YS1mbG9hdGluZy11aS1pbmVydCc7XG4gIGNvbnN0IGNvbnRyb2xBdHRyaWJ1dGUgPSBpbmVydCA/ICdpbmVydCcgOiBhcmlhSGlkZGVuID8gJ2FyaWEtaGlkZGVuJyA6IG51bGw7XG4gIGNvbnN0IGF2b2lkRWxlbWVudHMgPSBjb3JyZWN0RWxlbWVudHMoYm9keSwgdW5jb3JyZWN0ZWRBdm9pZEVsZW1lbnRzKTtcbiAgY29uc3QgZWxlbWVudHNUb0tlZXAgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IGVsZW1lbnRzVG9TdG9wID0gbmV3IFNldChhdm9pZEVsZW1lbnRzKTtcbiAgY29uc3QgaGlkZGVuRWxlbWVudHMgPSBbXTtcbiAgaWYgKCFtYXJrZXJNYXBbbWFya2VyTmFtZV0pIHtcbiAgICBtYXJrZXJNYXBbbWFya2VyTmFtZV0gPSBuZXcgV2Vha01hcCgpO1xuICB9XG4gIGNvbnN0IG1hcmtlckNvdW50ZXIgPSBtYXJrZXJNYXBbbWFya2VyTmFtZV07XG4gIGF2b2lkRWxlbWVudHMuZm9yRWFjaChrZWVwKTtcbiAgZGVlcChib2R5KTtcbiAgZWxlbWVudHNUb0tlZXAuY2xlYXIoKTtcbiAgZnVuY3Rpb24ga2VlcChlbCkge1xuICAgIGlmICghZWwgfHwgZWxlbWVudHNUb0tlZXAuaGFzKGVsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbGVtZW50c1RvS2VlcC5hZGQoZWwpO1xuICAgIGVsLnBhcmVudE5vZGUgJiYga2VlcChlbC5wYXJlbnROb2RlKTtcbiAgfVxuICBmdW5jdGlvbiBkZWVwKHBhcmVudCkge1xuICAgIGlmICghcGFyZW50IHx8IGVsZW1lbnRzVG9TdG9wLmhhcyhwYXJlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwocGFyZW50LmNoaWxkcmVuLCBub2RlID0+IHtcbiAgICAgIGlmIChlbGVtZW50c1RvS2VlcC5oYXMobm9kZSkpIHtcbiAgICAgICAgZGVlcChub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGF0dHIgPSBjb250cm9sQXR0cmlidXRlID8gbm9kZS5nZXRBdHRyaWJ1dGUoY29udHJvbEF0dHJpYnV0ZSkgOiBudWxsO1xuICAgICAgICBjb25zdCBhbHJlYWR5SGlkZGVuID0gYXR0ciAhPT0gbnVsbCAmJiBhdHRyICE9PSAnZmFsc2UnO1xuICAgICAgICBjb25zdCBjb3VudGVyVmFsdWUgPSAoY291bnRlck1hcC5nZXQobm9kZSkgfHwgMCkgKyAxO1xuICAgICAgICBjb25zdCBtYXJrZXJWYWx1ZSA9IChtYXJrZXJDb3VudGVyLmdldChub2RlKSB8fCAwKSArIDE7XG4gICAgICAgIGNvdW50ZXJNYXAuc2V0KG5vZGUsIGNvdW50ZXJWYWx1ZSk7XG4gICAgICAgIG1hcmtlckNvdW50ZXIuc2V0KG5vZGUsIG1hcmtlclZhbHVlKTtcbiAgICAgICAgaGlkZGVuRWxlbWVudHMucHVzaChub2RlKTtcbiAgICAgICAgaWYgKGNvdW50ZXJWYWx1ZSA9PT0gMSAmJiBhbHJlYWR5SGlkZGVuKSB7XG4gICAgICAgICAgdW5jb250cm9sbGVkRWxlbWVudHNTZXQuYWRkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZXJWYWx1ZSA9PT0gMSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG1hcmtlck5hbWUsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFscmVhZHlIaWRkZW4gJiYgY29udHJvbEF0dHJpYnV0ZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGNvbnRyb2xBdHRyaWJ1dGUsICd0cnVlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBsb2NrQ291bnQrKztcbiAgcmV0dXJuICgpID0+IHtcbiAgICBoaWRkZW5FbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgY291bnRlclZhbHVlID0gKGNvdW50ZXJNYXAuZ2V0KGVsZW1lbnQpIHx8IDApIC0gMTtcbiAgICAgIGNvbnN0IG1hcmtlclZhbHVlID0gKG1hcmtlckNvdW50ZXIuZ2V0KGVsZW1lbnQpIHx8IDApIC0gMTtcbiAgICAgIGNvdW50ZXJNYXAuc2V0KGVsZW1lbnQsIGNvdW50ZXJWYWx1ZSk7XG4gICAgICBtYXJrZXJDb3VudGVyLnNldChlbGVtZW50LCBtYXJrZXJWYWx1ZSk7XG4gICAgICBpZiAoIWNvdW50ZXJWYWx1ZSkge1xuICAgICAgICBpZiAoIXVuY29udHJvbGxlZEVsZW1lbnRzU2V0LmhhcyhlbGVtZW50KSAmJiBjb250cm9sQXR0cmlidXRlKSB7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoY29udHJvbEF0dHJpYnV0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdW5jb250cm9sbGVkRWxlbWVudHNTZXQuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXJrZXJWYWx1ZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShtYXJrZXJOYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsb2NrQ291bnQtLTtcbiAgICBpZiAoIWxvY2tDb3VudCkge1xuICAgICAgY291bnRlck1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICBjb3VudGVyTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgIHVuY29udHJvbGxlZEVsZW1lbnRzU2V0ID0gbmV3IFdlYWtTZXQoKTtcbiAgICAgIG1hcmtlck1hcCA9IHt9O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIG1hcmtPdGhlcnMoYXZvaWRFbGVtZW50cywgYXJpYUhpZGRlbiwgaW5lcnQpIHtcbiAgaWYgKGFyaWFIaWRkZW4gPT09IHZvaWQgMCkge1xuICAgIGFyaWFIaWRkZW4gPSBmYWxzZTtcbiAgfVxuICBpZiAoaW5lcnQgPT09IHZvaWQgMCkge1xuICAgIGluZXJ0ID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgYm9keSA9IGdldERvY3VtZW50KGF2b2lkRWxlbWVudHNbMF0pLmJvZHk7XG4gIHJldHVybiBhcHBseUF0dHJpYnV0ZVRvT3RoZXJzKGF2b2lkRWxlbWVudHMuY29uY2F0KEFycmF5LmZyb20oYm9keS5xdWVyeVNlbGVjdG9yQWxsKCdbYXJpYS1saXZlXScpKSksIGJvZHksIGFyaWFIaWRkZW4sIGluZXJ0KTtcbn1cblxuY29uc3QgZ2V0VGFiYmFibGVPcHRpb25zID0gKCkgPT4gKHtcbiAgZ2V0U2hhZG93Um9vdDogdHJ1ZSxcbiAgZGlzcGxheUNoZWNrOlxuICAvLyBKU0RPTSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBgdGFiYmFibGVgIGxpYnJhcnkuIFRvIHNvbHZlIHRoaXMgd2UgY2FuXG4gIC8vIGNoZWNrIGlmIGBSZXNpemVPYnNlcnZlcmAgaXMgYSByZWFsIGZ1bmN0aW9uIChub3QgcG9seWZpbGxlZCksIHdoaWNoXG4gIC8vIGRldGVybWluZXMgaWYgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgaXMgSlNET00tbGlrZS5cbiAgdHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSAnZnVuY3Rpb24nICYmIFJlc2l6ZU9ic2VydmVyLnRvU3RyaW5nKCkuaW5jbHVkZXMoJ1tuYXRpdmUgY29kZV0nKSA/ICdmdWxsJyA6ICdub25lJ1xufSk7XG5mdW5jdGlvbiBnZXRUYWJiYWJsZUluKGNvbnRhaW5lciwgZGlyZWN0aW9uKSB7XG4gIGNvbnN0IGFsbFRhYmJhYmxlID0gdGFiYmFibGUoY29udGFpbmVyLCBnZXRUYWJiYWJsZU9wdGlvbnMoKSk7XG4gIGlmIChkaXJlY3Rpb24gPT09ICdwcmV2Jykge1xuICAgIGFsbFRhYmJhYmxlLnJldmVyc2UoKTtcbiAgfVxuICBjb25zdCBhY3RpdmVJbmRleCA9IGFsbFRhYmJhYmxlLmluZGV4T2YoYWN0aXZlRWxlbWVudChnZXREb2N1bWVudChjb250YWluZXIpKSk7XG4gIGNvbnN0IG5leHRUYWJiYWJsZUVsZW1lbnRzID0gYWxsVGFiYmFibGUuc2xpY2UoYWN0aXZlSW5kZXggKyAxKTtcbiAgcmV0dXJuIG5leHRUYWJiYWJsZUVsZW1lbnRzWzBdO1xufVxuZnVuY3Rpb24gZ2V0TmV4dFRhYmJhYmxlKCkge1xuICByZXR1cm4gZ2V0VGFiYmFibGVJbihkb2N1bWVudC5ib2R5LCAnbmV4dCcpO1xufVxuZnVuY3Rpb24gZ2V0UHJldmlvdXNUYWJiYWJsZSgpIHtcbiAgcmV0dXJuIGdldFRhYmJhYmxlSW4oZG9jdW1lbnQuYm9keSwgJ3ByZXYnKTtcbn1cbmZ1bmN0aW9uIGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBjb250YWluZXIpIHtcbiAgY29uc3QgY29udGFpbmVyRWxlbWVudCA9IGNvbnRhaW5lciB8fCBldmVudC5jdXJyZW50VGFyZ2V0O1xuICBjb25zdCByZWxhdGVkVGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgcmV0dXJuICFyZWxhdGVkVGFyZ2V0IHx8ICFjb250YWlucyhjb250YWluZXJFbGVtZW50LCByZWxhdGVkVGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGRpc2FibGVGb2N1c0luc2lkZShjb250YWluZXIpIHtcbiAgY29uc3QgdGFiYmFibGVFbGVtZW50cyA9IHRhYmJhYmxlKGNvbnRhaW5lciwgZ2V0VGFiYmFibGVPcHRpb25zKCkpO1xuICB0YWJiYWJsZUVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgZWxlbWVudC5kYXRhc2V0LnRhYmluZGV4ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgfHwgJyc7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZW5hYmxlRm9jdXNJbnNpZGUoY29udGFpbmVyKSB7XG4gIGNvbnN0IGVsZW1lbnRzID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXRhYmluZGV4XScpO1xuICBlbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgIGNvbnN0IHRhYmluZGV4ID0gZWxlbWVudC5kYXRhc2V0LnRhYmluZGV4O1xuICAgIC8vIGJpb21lLWlnbm9yZSBsaW50L3BlcmZvcm1hbmNlL25vRGVsZXRlOiBwdXJpdHlcbiAgICBkZWxldGUgZWxlbWVudC5kYXRhc2V0LnRhYmluZGV4O1xuICAgIGlmICh0YWJpbmRleCkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgdGFiaW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBTZWUgRGllZ28gSGF6J3MgU2FuZGJveCBmb3IgbWFraW5nIHRoaXMgbG9naWMgd29yayB3ZWxsIG9uIFNhZmFyaS9pT1M6XG4vLyBodHRwczovL2NvZGVzYW5kYm94LmlvL3MvdGFiYmFibGUtcG9ydGFsLWY0dG5nP2ZpbGU9L3NyYy9Gb2N1c1RyYXAudHN4XG5cbmNvbnN0IEhJRERFTl9TVFlMRVMgPSB7XG4gIGJvcmRlcjogMCxcbiAgY2xpcDogJ3JlY3QoMCAwIDAgMCknLFxuICBoZWlnaHQ6ICcxcHgnLFxuICBtYXJnaW46ICctMXB4JyxcbiAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICBwYWRkaW5nOiAwLFxuICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgd2hpdGVTcGFjZTogJ25vd3JhcCcsXG4gIHdpZHRoOiAnMXB4JyxcbiAgdG9wOiAwLFxuICBsZWZ0OiAwXG59O1xubGV0IHRpbWVvdXRJZDtcbmZ1bmN0aW9uIHNldEFjdGl2ZUVsZW1lbnRPblRhYihldmVudCkge1xuICBpZiAoZXZlbnQua2V5ID09PSAnVGFiJykge1xuICAgIGV2ZW50LnRhcmdldDtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgfVxufVxuY29uc3QgRm9jdXNHdWFyZCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEZvY3VzR3VhcmQocHJvcHMsIHJlZikge1xuICBjb25zdCBbcm9sZSwgc2V0Um9sZV0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKGlzU2FmYXJpKCkpIHtcbiAgICAgIC8vIFVubGlrZSBvdGhlciBzY3JlZW4gcmVhZGVycyBzdWNoIGFzIE5WREEgYW5kIEpBV1MsIHRoZSB2aXJ0dWFsIGN1cnNvclxuICAgICAgLy8gb24gVm9pY2VPdmVyIGRvZXMgdHJpZ2dlciB0aGUgb25Gb2N1cyBldmVudCwgc28gd2UgY2FuIHVzZSB0aGUgZm9jdXNcbiAgICAgIC8vIHRyYXAgZWxlbWVudC4gT24gU2FmYXJpLCBvbmx5IGJ1dHRvbnMgdHJpZ2dlciB0aGUgb25Gb2N1cyBldmVudC5cbiAgICAgIC8vIE5COiBcImdyb3VwXCIgcm9sZSBpbiB0aGUgU2FuZGJveCBubyBsb25nZXIgYXBwZWFycyB0byB3b3JrLCBtdXN0IGJlIGFcbiAgICAgIC8vIGJ1dHRvbiByb2xlLlxuICAgICAgc2V0Um9sZSgnYnV0dG9uJyk7XG4gICAgfVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBzZXRBY3RpdmVFbGVtZW50T25UYWIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgc2V0QWN0aXZlRWxlbWVudE9uVGFiKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIGNvbnN0IHJlc3RQcm9wcyA9IHtcbiAgICByZWYsXG4gICAgdGFiSW5kZXg6IDAsXG4gICAgLy8gUm9sZSBpcyBvbmx5IGZvciBWb2ljZU92ZXJcbiAgICByb2xlLFxuICAgICdhcmlhLWhpZGRlbic6IHJvbGUgPyB1bmRlZmluZWQgOiB0cnVlLFxuICAgIFtjcmVhdGVBdHRyaWJ1dGUoJ2ZvY3VzLWd1YXJkJyldOiAnJyxcbiAgICBzdHlsZTogSElEREVOX1NUWUxFU1xuICB9O1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIF9leHRlbmRzKHt9LCBwcm9wcywgcmVzdFByb3BzKSk7XG59KTtcblxuY29uc3QgUG9ydGFsQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgYXR0ciA9IC8qI19fUFVSRV9fKi9jcmVhdGVBdHRyaWJ1dGUoJ3BvcnRhbCcpO1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ1BvcnRhbCN1c2VmbG9hdGluZ3BvcnRhbG5vZGVcbiAqL1xuZnVuY3Rpb24gdXNlRmxvYXRpbmdQb3J0YWxOb2RlKF90ZW1wKSB7XG4gIGxldCB7XG4gICAgaWQsXG4gICAgcm9vdFxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGNvbnN0IFtwb3J0YWxOb2RlLCBzZXRQb3J0YWxOb2RlXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCB1bmlxdWVJZCA9IHVzZUlkKCk7XG4gIGNvbnN0IHBvcnRhbENvbnRleHQgPSB1c2VQb3J0YWxDb250ZXh0KCk7XG4gIGNvbnN0IHBvcnRhbE5vZGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGluZGV4KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcG9ydGFsTm9kZSA9PSBudWxsIHx8IHBvcnRhbE5vZGUucmVtb3ZlKCk7XG4gICAgICAvLyBBbGxvdyB0aGUgc3Vic2VxdWVudCBsYXlvdXQgZWZmZWN0cyB0byBjcmVhdGUgYSBuZXcgbm9kZSBvbiB1cGRhdGVzLlxuICAgICAgLy8gVGhlIHBvcnRhbCBub2RlIHdpbGwgc3RpbGwgYmUgY2xlYW5lZCB1cCBvbiB1bm1vdW50LlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8yNDU0XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHBvcnRhbE5vZGVSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9O1xuICB9LCBbcG9ydGFsTm9kZV0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKHBvcnRhbE5vZGVSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIGNvbnN0IGV4aXN0aW5nSWRSb290ID0gaWQgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgOiBudWxsO1xuICAgIGlmICghZXhpc3RpbmdJZFJvb3QpIHJldHVybjtcbiAgICBjb25zdCBzdWJSb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgc3ViUm9vdC5pZCA9IHVuaXF1ZUlkO1xuICAgIHN1YlJvb3Quc2V0QXR0cmlidXRlKGF0dHIsICcnKTtcbiAgICBleGlzdGluZ0lkUm9vdC5hcHBlbmRDaGlsZChzdWJSb290KTtcbiAgICBwb3J0YWxOb2RlUmVmLmN1cnJlbnQgPSBzdWJSb290O1xuICAgIHNldFBvcnRhbE5vZGUoc3ViUm9vdCk7XG4gIH0sIFtpZCwgdW5pcXVlSWRdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChwb3J0YWxOb2RlUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBsZXQgY29udGFpbmVyID0gcm9vdCB8fCAocG9ydGFsQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcG9ydGFsQ29udGV4dC5wb3J0YWxOb2RlKTtcbiAgICBpZiAoY29udGFpbmVyICYmICFpc0VsZW1lbnQoY29udGFpbmVyKSkgY29udGFpbmVyID0gY29udGFpbmVyLmN1cnJlbnQ7XG4gICAgY29udGFpbmVyID0gY29udGFpbmVyIHx8IGRvY3VtZW50LmJvZHk7XG4gICAgbGV0IGlkV3JhcHBlciA9IG51bGw7XG4gICAgaWYgKGlkKSB7XG4gICAgICBpZFdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGlkV3JhcHBlci5pZCA9IGlkO1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGlkV3JhcHBlcik7XG4gICAgfVxuICAgIGNvbnN0IHN1YlJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBzdWJSb290LmlkID0gdW5pcXVlSWQ7XG4gICAgc3ViUm9vdC5zZXRBdHRyaWJ1dGUoYXR0ciwgJycpO1xuICAgIGNvbnRhaW5lciA9IGlkV3JhcHBlciB8fCBjb250YWluZXI7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHN1YlJvb3QpO1xuICAgIHBvcnRhbE5vZGVSZWYuY3VycmVudCA9IHN1YlJvb3Q7XG4gICAgc2V0UG9ydGFsTm9kZShzdWJSb290KTtcbiAgfSwgW2lkLCByb290LCB1bmlxdWVJZCwgcG9ydGFsQ29udGV4dF0pO1xuICByZXR1cm4gcG9ydGFsTm9kZTtcbn1cbi8qKlxuICogUG9ydGFscyB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbnRvIGEgZ2l2ZW4gY29udGFpbmVyIGVsZW1lbnQg4oCUIGJ5IGRlZmF1bHQsXG4gKiBvdXRzaWRlIG9mIHRoZSBhcHAgcm9vdCBhbmQgaW50byB0aGUgYm9keS5cbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIGVuc3VyZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBjYW4gYXBwZWFyIG91dHNpZGUgYW55XG4gKiBwb3RlbnRpYWwgcGFyZW50IGNvbnRhaW5lcnMgdGhhdCBjYXVzZSBjbGlwcGluZyAoc3VjaCBhcyBgb3ZlcmZsb3c6IGhpZGRlbmApLFxuICogd2hpbGUgcmV0YWluaW5nIGl0cyBsb2NhdGlvbiBpbiB0aGUgUmVhY3QgdHJlZS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ1BvcnRhbFxuICovXG5mdW5jdGlvbiBGbG9hdGluZ1BvcnRhbChfcmVmKSB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW4sXG4gICAgaWQsXG4gICAgcm9vdCA9IG51bGwsXG4gICAgcHJlc2VydmVUYWJPcmRlciA9IHRydWVcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHBvcnRhbE5vZGUgPSB1c2VGbG9hdGluZ1BvcnRhbE5vZGUoe1xuICAgIGlkLFxuICAgIHJvb3RcbiAgfSk7XG4gIGNvbnN0IFtmb2N1c01hbmFnZXJTdGF0ZSwgc2V0Rm9jdXNNYW5hZ2VyU3RhdGVdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IGJlZm9yZU91dHNpZGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGFmdGVyT3V0c2lkZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgYmVmb3JlSW5zaWRlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBhZnRlckluc2lkZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3Qgc2hvdWxkUmVuZGVyR3VhcmRzID1cbiAgLy8gVGhlIEZvY3VzTWFuYWdlciBhbmQgdGhlcmVmb3JlIGZsb2F0aW5nIGVsZW1lbnQgYXJlIGN1cnJlbnRseSBvcGVuL1xuICAvLyByZW5kZXJlZC5cbiAgISFmb2N1c01hbmFnZXJTdGF0ZSAmJlxuICAvLyBHdWFyZHMgYXJlIG9ubHkgZm9yIG5vbi1tb2RhbCBmb2N1cyBtYW5hZ2VtZW50LlxuICAhZm9jdXNNYW5hZ2VyU3RhdGUubW9kYWwgJiZcbiAgLy8gRG9uJ3QgcmVuZGVyIGlmIHVubW91bnQgaXMgdHJhbnNpdGlvbmluZy5cbiAgZm9jdXNNYW5hZ2VyU3RhdGUub3BlbiAmJiBwcmVzZXJ2ZVRhYk9yZGVyICYmICEhKHJvb3QgfHwgcG9ydGFsTm9kZSk7XG5cbiAgLy8gaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3RhYmJhYmxlLXBvcnRhbC1mNHRuZz9maWxlPS9zcmMvVGFiYmFibGVQb3J0YWwudHN4XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFwb3J0YWxOb2RlIHx8ICFwcmVzZXJ2ZVRhYk9yZGVyIHx8IGZvY3VzTWFuYWdlclN0YXRlICE9IG51bGwgJiYgZm9jdXNNYW5hZ2VyU3RhdGUubW9kYWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgZWxlbWVudHMgaW5zaWRlIHRoZSBwb3J0YWwgZWxlbWVudCBhcmUgdGFiYmFibGUgb25seSB3aGVuIHRoZVxuICAgIC8vIHBvcnRhbCBoYXMgYWxyZWFkeSBiZWVuIGZvY3VzZWQsIGVpdGhlciBieSB0YWJiaW5nIGludG8gYSBmb2N1cyB0cmFwXG4gICAgLy8gZWxlbWVudCBvdXRzaWRlIG9yIHVzaW5nIHRoZSBtb3VzZS5cbiAgICBmdW5jdGlvbiBvbkZvY3VzKGV2ZW50KSB7XG4gICAgICBpZiAocG9ydGFsTm9kZSAmJiBpc091dHNpZGVFdmVudChldmVudCkpIHtcbiAgICAgICAgY29uc3QgZm9jdXNpbmcgPSBldmVudC50eXBlID09PSAnZm9jdXNpbic7XG4gICAgICAgIGNvbnN0IG1hbmFnZUZvY3VzID0gZm9jdXNpbmcgPyBlbmFibGVGb2N1c0luc2lkZSA6IGRpc2FibGVGb2N1c0luc2lkZTtcbiAgICAgICAgbWFuYWdlRm9jdXMocG9ydGFsTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIExpc3RlbiB0byB0aGUgZXZlbnQgb24gdGhlIGNhcHR1cmUgcGhhc2Ugc28gdGhleSBydW4gYmVmb3JlIHRoZSBmb2N1c1xuICAgIC8vIHRyYXAgZWxlbWVudHMgb25Gb2N1cyBwcm9wIGlzIGNhbGxlZC5cbiAgICBwb3J0YWxOb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBvbkZvY3VzLCB0cnVlKTtcbiAgICBwb3J0YWxOb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0Jywgb25Gb2N1cywgdHJ1ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBvcnRhbE5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIG9uRm9jdXMsIHRydWUpO1xuICAgICAgcG9ydGFsTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIG9uRm9jdXMsIHRydWUpO1xuICAgIH07XG4gIH0sIFtwb3J0YWxOb2RlLCBwcmVzZXJ2ZVRhYk9yZGVyLCBmb2N1c01hbmFnZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogZm9jdXNNYW5hZ2VyU3RhdGUubW9kYWxdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBvcnRhbENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgcHJlc2VydmVUYWJPcmRlcixcbiAgICAgIGJlZm9yZU91dHNpZGVSZWYsXG4gICAgICBhZnRlck91dHNpZGVSZWYsXG4gICAgICBiZWZvcmVJbnNpZGVSZWYsXG4gICAgICBhZnRlckluc2lkZVJlZixcbiAgICAgIHBvcnRhbE5vZGUsXG4gICAgICBzZXRGb2N1c01hbmFnZXJTdGF0ZVxuICAgIH0pLCBbcHJlc2VydmVUYWJPcmRlciwgcG9ydGFsTm9kZV0pXG4gIH0sIHNob3VsZFJlbmRlckd1YXJkcyAmJiBwb3J0YWxOb2RlICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvY3VzR3VhcmQsIHtcbiAgICBcImRhdGEtdHlwZVwiOiBcIm91dHNpZGVcIixcbiAgICByZWY6IGJlZm9yZU91dHNpZGVSZWYsXG4gICAgb25Gb2N1czogZXZlbnQgPT4ge1xuICAgICAgaWYgKGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBwb3J0YWxOb2RlKSkge1xuICAgICAgICB2YXIgX2JlZm9yZUluc2lkZVJlZiRjdXJyO1xuICAgICAgICAoX2JlZm9yZUluc2lkZVJlZiRjdXJyID0gYmVmb3JlSW5zaWRlUmVmLmN1cnJlbnQpID09IG51bGwgfHwgX2JlZm9yZUluc2lkZVJlZiRjdXJyLmZvY3VzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwcmV2VGFiYmFibGUgPSBnZXRQcmV2aW91c1RhYmJhYmxlKCkgfHwgKGZvY3VzTWFuYWdlclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBmb2N1c01hbmFnZXJTdGF0ZS5yZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50KTtcbiAgICAgICAgcHJldlRhYmJhYmxlID09IG51bGwgfHwgcHJldlRhYmJhYmxlLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9KSwgc2hvdWxkUmVuZGVyR3VhcmRzICYmIHBvcnRhbE5vZGUgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBcImFyaWEtb3duc1wiOiBwb3J0YWxOb2RlLmlkLFxuICAgIHN0eWxlOiBISURERU5fU1RZTEVTXG4gIH0pLCBwb3J0YWxOb2RlICYmIC8qI19fUFVSRV9fKi9jcmVhdGVQb3J0YWwoY2hpbGRyZW4sIHBvcnRhbE5vZGUpLCBzaG91bGRSZW5kZXJHdWFyZHMgJiYgcG9ydGFsTm9kZSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb2N1c0d1YXJkLCB7XG4gICAgXCJkYXRhLXR5cGVcIjogXCJvdXRzaWRlXCIsXG4gICAgcmVmOiBhZnRlck91dHNpZGVSZWYsXG4gICAgb25Gb2N1czogZXZlbnQgPT4ge1xuICAgICAgaWYgKGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBwb3J0YWxOb2RlKSkge1xuICAgICAgICB2YXIgX2FmdGVySW5zaWRlUmVmJGN1cnJlO1xuICAgICAgICAoX2FmdGVySW5zaWRlUmVmJGN1cnJlID0gYWZ0ZXJJbnNpZGVSZWYuY3VycmVudCkgPT0gbnVsbCB8fCBfYWZ0ZXJJbnNpZGVSZWYkY3VycmUuZm9jdXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5leHRUYWJiYWJsZSA9IGdldE5leHRUYWJiYWJsZSgpIHx8IChmb2N1c01hbmFnZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogZm9jdXNNYW5hZ2VyU3RhdGUucmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCk7XG4gICAgICAgIG5leHRUYWJiYWJsZSA9PSBudWxsIHx8IG5leHRUYWJiYWJsZS5mb2N1cygpO1xuICAgICAgICAoZm9jdXNNYW5hZ2VyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGZvY3VzTWFuYWdlclN0YXRlLmNsb3NlT25Gb2N1c091dCkgJiYgKGZvY3VzTWFuYWdlclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBmb2N1c01hbmFnZXJTdGF0ZS5vbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50KSk7XG4gICAgICB9XG4gICAgfVxuICB9KSk7XG59XG5jb25zdCB1c2VQb3J0YWxDb250ZXh0ID0gKCkgPT4gUmVhY3QudXNlQ29udGV4dChQb3J0YWxDb250ZXh0KTtcblxuY29uc3QgTElTVF9MSU1JVCA9IDIwO1xubGV0IHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMgPSBbXTtcbmZ1bmN0aW9uIGFkZFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudChlbGVtZW50KSB7XG4gIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMgPSBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzLmZpbHRlcihlbCA9PiBlbC5pc0Nvbm5lY3RlZCk7XG4gIGlmIChlbGVtZW50ICYmIGdldE5vZGVOYW1lKGVsZW1lbnQpICE9PSAnYm9keScpIHtcbiAgICBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgaWYgKHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMubGVuZ3RoID4gTElTVF9MSU1JVCkge1xuICAgICAgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50cyA9IHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMuc2xpY2UoLUxJU1RfTElNSVQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0UHJldmlvdXNseUZvY3VzZWRFbGVtZW50KCkge1xuICByZXR1cm4gcHJldmlvdXNseUZvY3VzZWRFbGVtZW50cy5zbGljZSgpLnJldmVyc2UoKS5maW5kKGVsID0+IGVsLmlzQ29ubmVjdGVkKTtcbn1cbmNvbnN0IFZpc3VhbGx5SGlkZGVuRGlzbWlzcyA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFZpc3VhbGx5SGlkZGVuRGlzbWlzcyhwcm9wcywgcmVmKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgIHJlZjogcmVmLFxuICAgIHRhYkluZGV4OiAtMSxcbiAgICBzdHlsZTogSElEREVOX1NUWUxFU1xuICB9KSk7XG59KTtcbi8qKlxuICogUHJvdmlkZXMgZm9jdXMgbWFuYWdlbWVudCBmb3IgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdGb2N1c01hbmFnZXJcbiAqL1xuZnVuY3Rpb24gRmxvYXRpbmdGb2N1c01hbmFnZXIocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGNvbnRleHQsXG4gICAgY2hpbGRyZW4sXG4gICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICBvcmRlciA9IFsnY29udGVudCddLFxuICAgIGd1YXJkczogX2d1YXJkcyA9IHRydWUsXG4gICAgaW5pdGlhbEZvY3VzID0gMCxcbiAgICByZXR1cm5Gb2N1cyA9IHRydWUsXG4gICAgbW9kYWwgPSB0cnVlLFxuICAgIHZpc3VhbGx5SGlkZGVuRGlzbWlzcyA9IGZhbHNlLFxuICAgIGNsb3NlT25Gb2N1c091dCA9IHRydWVcbiAgfSA9IHByb3BzO1xuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICByZWZzLFxuICAgIG5vZGVJZCxcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgZXZlbnRzLFxuICAgIGRhdGFSZWYsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGRvbVJlZmVyZW5jZSxcbiAgICAgIGZsb2F0aW5nXG4gICAgfVxuICB9ID0gY29udGV4dDtcbiAgY29uc3QgaWdub3JlSW5pdGlhbEZvY3VzID0gdHlwZW9mIGluaXRpYWxGb2N1cyA9PT0gJ251bWJlcicgJiYgaW5pdGlhbEZvY3VzIDwgMDtcbiAgLy8gSWYgdGhlIHJlZmVyZW5jZSBpcyBhIGNvbWJvYm94IGFuZCBpcyB0eXBlYWJsZSAoZS5nLiBpbnB1dC90ZXh0YXJlYSksXG4gIC8vIHRoZXJlIGFyZSBkaWZmZXJlbnQgZm9jdXMgc2VtYW50aWNzLiBUaGUgZ3VhcmRzIHNob3VsZCBub3QgYmUgcmVuZGVyZWQsIGJ1dFxuICAvLyBhcmlhLWhpZGRlbiBzaG91bGQgYmUgYXBwbGllZCB0byBhbGwgbm9kZXMgc3RpbGwuIEZ1cnRoZXIsIHRoZSB2aXN1YWxseVxuICAvLyBoaWRkZW4gZGlzbWlzcyBidXR0b24gc2hvdWxkIG9ubHkgYXBwZWFyIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QsIG5vdCB0aGVcbiAgLy8gc3RhcnQuXG4gIGNvbnN0IGlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCA9IGlzVHlwZWFibGVDb21ib2JveChkb21SZWZlcmVuY2UpICYmIGlnbm9yZUluaXRpYWxGb2N1cztcblxuICAvLyBGb3JjZSB0aGUgZ3VhcmRzIHRvIGJlIHJlbmRlcmVkIGlmIHRoZSBgaW5lcnRgIGF0dHJpYnV0ZSBpcyBub3Qgc3VwcG9ydGVkLlxuICBjb25zdCBndWFyZHMgPSBzdXBwb3J0c0luZXJ0KCkgPyBfZ3VhcmRzIDogdHJ1ZTtcbiAgY29uc3Qgb3JkZXJSZWYgPSB1c2VMYXRlc3RSZWYob3JkZXIpO1xuICBjb25zdCBpbml0aWFsRm9jdXNSZWYgPSB1c2VMYXRlc3RSZWYoaW5pdGlhbEZvY3VzKTtcbiAgY29uc3QgcmV0dXJuRm9jdXNSZWYgPSB1c2VMYXRlc3RSZWYocmV0dXJuRm9jdXMpO1xuICBjb25zdCB0cmVlID0gdXNlRmxvYXRpbmdUcmVlKCk7XG4gIGNvbnN0IHBvcnRhbENvbnRleHQgPSB1c2VQb3J0YWxDb250ZXh0KCk7XG4gIGNvbnN0IHN0YXJ0RGlzbWlzc0J1dHRvblJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZW5kRGlzbWlzc0J1dHRvblJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgcHJldmVudFJldHVybkZvY3VzUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgaXNQb2ludGVyRG93blJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGlzSW5zaWRlUG9ydGFsID0gcG9ydGFsQ29udGV4dCAhPSBudWxsO1xuICBjb25zdCBnZXRUYWJiYWJsZUNvbnRlbnQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgaWYgKGNvbnRhaW5lciA9PT0gdm9pZCAwKSB7XG4gICAgICBjb250YWluZXIgPSBmbG9hdGluZztcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lciA/IHRhYmJhYmxlKGNvbnRhaW5lciwgZ2V0VGFiYmFibGVPcHRpb25zKCkpIDogW107XG4gIH0sIFtmbG9hdGluZ10pO1xuICBjb25zdCBnZXRUYWJiYWJsZUVsZW1lbnRzID0gUmVhY3QudXNlQ2FsbGJhY2soY29udGFpbmVyID0+IHtcbiAgICBjb25zdCBjb250ZW50ID0gZ2V0VGFiYmFibGVDb250ZW50KGNvbnRhaW5lcik7XG4gICAgcmV0dXJuIG9yZGVyUmVmLmN1cnJlbnQubWFwKHR5cGUgPT4ge1xuICAgICAgaWYgKGRvbVJlZmVyZW5jZSAmJiB0eXBlID09PSAncmVmZXJlbmNlJykge1xuICAgICAgICByZXR1cm4gZG9tUmVmZXJlbmNlO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nICYmIHR5cGUgPT09ICdmbG9hdGluZycpIHtcbiAgICAgICAgcmV0dXJuIGZsb2F0aW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuZmlsdGVyKEJvb2xlYW4pLmZsYXQoKTtcbiAgfSwgW2RvbVJlZmVyZW5jZSwgZmxvYXRpbmcsIG9yZGVyUmVmLCBnZXRUYWJiYWJsZUNvbnRlbnRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgIW1vZGFsKSByZXR1cm47XG4gICAgZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSAnVGFiJykge1xuICAgICAgICAvLyBUaGUgZm9jdXMgZ3VhcmRzIGhhdmUgbm90aGluZyB0byBmb2N1cywgc28gd2UgbmVlZCB0byBzdG9wIHRoZSBldmVudC5cbiAgICAgICAgaWYgKGNvbnRhaW5zKGZsb2F0aW5nLCBhY3RpdmVFbGVtZW50KGdldERvY3VtZW50KGZsb2F0aW5nKSkpICYmIGdldFRhYmJhYmxlQ29udGVudCgpLmxlbmd0aCA9PT0gMCAmJiAhaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94KSB7XG4gICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbHMgPSBnZXRUYWJiYWJsZUVsZW1lbnRzKCk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChldmVudCk7XG4gICAgICAgIGlmIChvcmRlclJlZi5jdXJyZW50WzBdID09PSAncmVmZXJlbmNlJyAmJiB0YXJnZXQgPT09IGRvbVJlZmVyZW5jZSkge1xuICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICBlbnF1ZXVlRm9jdXMoZWxzW2Vscy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVucXVldWVGb2N1cyhlbHNbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkZXJSZWYuY3VycmVudFsxXSA9PT0gJ2Zsb2F0aW5nJyAmJiB0YXJnZXQgPT09IGZsb2F0aW5nICYmIGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICBlbnF1ZXVlRm9jdXMoZWxzWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkb2MgPSBnZXREb2N1bWVudChmbG9hdGluZyk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uS2V5RG93bik7XG4gICAgfTtcbiAgfSwgW2Rpc2FibGVkLCBkb21SZWZlcmVuY2UsIGZsb2F0aW5nLCBtb2RhbCwgb3JkZXJSZWYsIGlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCwgZ2V0VGFiYmFibGVDb250ZW50LCBnZXRUYWJiYWJsZUVsZW1lbnRzXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkIHx8ICFjbG9zZU9uRm9jdXNPdXQpIHJldHVybjtcblxuICAgIC8vIEluIFNhZmFyaSwgYnV0dG9ucyBsb3NlIGZvY3VzIHdoZW4gcHJlc3NpbmcgdGhlbS5cbiAgICBmdW5jdGlvbiBoYW5kbGVQb2ludGVyRG93bigpIHtcbiAgICAgIGlzUG9pbnRlckRvd25SZWYuY3VycmVudCA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaXNQb2ludGVyRG93blJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlRm9jdXNPdXRzaWRlKGV2ZW50KSB7XG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgbW92ZWRUb1VucmVsYXRlZE5vZGUgPSAhKGNvbnRhaW5zKGRvbVJlZmVyZW5jZSwgcmVsYXRlZFRhcmdldCkgfHwgY29udGFpbnMoZmxvYXRpbmcsIHJlbGF0ZWRUYXJnZXQpIHx8IGNvbnRhaW5zKHJlbGF0ZWRUYXJnZXQsIGZsb2F0aW5nKSB8fCBjb250YWlucyhwb3J0YWxDb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUsIHJlbGF0ZWRUYXJnZXQpIHx8IHJlbGF0ZWRUYXJnZXQgIT0gbnVsbCAmJiByZWxhdGVkVGFyZ2V0Lmhhc0F0dHJpYnV0ZShjcmVhdGVBdHRyaWJ1dGUoJ2ZvY3VzLWd1YXJkJykpIHx8IHRyZWUgJiYgKGdldENoaWxkcmVuKHRyZWUubm9kZXNSZWYuY3VycmVudCwgbm9kZUlkKS5maW5kKG5vZGUgPT4ge1xuICAgICAgICAgIHZhciBfbm9kZSRjb250ZXh0LCBfbm9kZSRjb250ZXh0MjtcbiAgICAgICAgICByZXR1cm4gY29udGFpbnMoKF9ub2RlJGNvbnRleHQgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0LmVsZW1lbnRzLmZsb2F0aW5nLCByZWxhdGVkVGFyZ2V0KSB8fCBjb250YWlucygoX25vZGUkY29udGV4dDIgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0Mi5lbGVtZW50cy5kb21SZWZlcmVuY2UsIHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICB9KSB8fCBnZXRBbmNlc3RvcnModHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpLmZpbmQobm9kZSA9PiB7XG4gICAgICAgICAgdmFyIF9ub2RlJGNvbnRleHQzLCBfbm9kZSRjb250ZXh0NDtcbiAgICAgICAgICByZXR1cm4gKChfbm9kZSRjb250ZXh0MyA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQzLmVsZW1lbnRzLmZsb2F0aW5nKSA9PT0gcmVsYXRlZFRhcmdldCB8fCAoKF9ub2RlJGNvbnRleHQ0ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dDQuZWxlbWVudHMuZG9tUmVmZXJlbmNlKSA9PT0gcmVsYXRlZFRhcmdldDtcbiAgICAgICAgfSkpKTtcblxuICAgICAgICAvLyBGb2N1cyBkaWQgbm90IG1vdmUgaW5zaWRlIHRoZSBmbG9hdGluZyB0cmVlLCBhbmQgdGhlcmUgYXJlIG5vIHRhYmJhYmxlXG4gICAgICAgIC8vIHBvcnRhbCBndWFyZHMgdG8gaGFuZGxlIGNsb3NpbmcuXG4gICAgICAgIGlmIChyZWxhdGVkVGFyZ2V0ICYmIG1vdmVkVG9VbnJlbGF0ZWROb2RlICYmICFpc1BvaW50ZXJEb3duUmVmLmN1cnJlbnQgJiZcbiAgICAgICAgLy8gRml4IFJlYWN0IDE4IFN0cmljdCBNb2RlIHJldHVybkZvY3VzIGR1ZSB0byBkb3VibGUgcmVuZGVyaW5nLlxuICAgICAgICByZWxhdGVkVGFyZ2V0ICE9PSBnZXRQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQoKSkge1xuICAgICAgICAgIHByZXZlbnRSZXR1cm5Gb2N1c1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChmbG9hdGluZyAmJiBpc0hUTUxFbGVtZW50KGRvbVJlZmVyZW5jZSkpIHtcbiAgICAgIGRvbVJlZmVyZW5jZS5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIGhhbmRsZUZvY3VzT3V0c2lkZSk7XG4gICAgICBkb21SZWZlcmVuY2UuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBoYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAhbW9kYWwgJiYgZmxvYXRpbmcuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBoYW5kbGVGb2N1c091dHNpZGUpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgZG9tUmVmZXJlbmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgaGFuZGxlRm9jdXNPdXRzaWRlKTtcbiAgICAgICAgZG9tUmVmZXJlbmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgICAhbW9kYWwgJiYgZmxvYXRpbmcucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBoYW5kbGVGb2N1c091dHNpZGUpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtkaXNhYmxlZCwgZG9tUmVmZXJlbmNlLCBmbG9hdGluZywgbW9kYWwsIG5vZGVJZCwgdHJlZSwgcG9ydGFsQ29udGV4dCwgb25PcGVuQ2hhbmdlLCBjbG9zZU9uRm9jdXNPdXRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgX3BvcnRhbENvbnRleHQkcG9ydGFsO1xuICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuO1xuXG4gICAgLy8gRG9uJ3QgaGlkZSBwb3J0YWxzIG5lc3RlZCB3aXRoaW4gdGhlIHBhcmVudCBwb3J0YWwuXG4gICAgY29uc3QgcG9ydGFsTm9kZXMgPSBBcnJheS5mcm9tKChwb3J0YWxDb250ZXh0ID09IG51bGwgfHwgKF9wb3J0YWxDb250ZXh0JHBvcnRhbCA9IHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wb3J0YWxDb250ZXh0JHBvcnRhbC5xdWVyeVNlbGVjdG9yQWxsKFwiW1wiICsgY3JlYXRlQXR0cmlidXRlKCdwb3J0YWwnKSArIFwiXVwiKSkgfHwgW10pO1xuICAgIGlmIChmbG9hdGluZykge1xuICAgICAgY29uc3QgaW5zaWRlRWxlbWVudHMgPSBbZmxvYXRpbmcsIC4uLnBvcnRhbE5vZGVzLCBzdGFydERpc21pc3NCdXR0b25SZWYuY3VycmVudCwgZW5kRGlzbWlzc0J1dHRvblJlZi5jdXJyZW50LCBvcmRlclJlZi5jdXJyZW50LmluY2x1ZGVzKCdyZWZlcmVuY2UnKSB8fCBpc1VudHJhcHBlZFR5cGVhYmxlQ29tYm9ib3ggPyBkb21SZWZlcmVuY2UgOiBudWxsXS5maWx0ZXIoeCA9PiB4ICE9IG51bGwpO1xuICAgICAgY29uc3QgY2xlYW51cCA9IG1vZGFsIHx8IGlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCA/IG1hcmtPdGhlcnMoaW5zaWRlRWxlbWVudHMsIGd1YXJkcywgIWd1YXJkcykgOiBtYXJrT3RoZXJzKGluc2lkZUVsZW1lbnRzKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbZGlzYWJsZWQsIGRvbVJlZmVyZW5jZSwgZmxvYXRpbmcsIG1vZGFsLCBvcmRlclJlZiwgcG9ydGFsQ29udGV4dCwgaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94LCBndWFyZHNdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCB8fCAhZmxvYXRpbmcpIHJldHVybjtcbiAgICBjb25zdCBkb2MgPSBnZXREb2N1bWVudChmbG9hdGluZyk7XG4gICAgY29uc3QgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gYWN0aXZlRWxlbWVudChkb2MpO1xuXG4gICAgLy8gV2FpdCBmb3IgYW55IGxheW91dCBlZmZlY3Qgc3RhdGUgc2V0dGVycyB0byBleGVjdXRlIHRvIHNldCBgdGFiSW5kZXhgLlxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIGNvbnN0IGZvY3VzYWJsZUVsZW1lbnRzID0gZ2V0VGFiYmFibGVFbGVtZW50cyhmbG9hdGluZyk7XG4gICAgICBjb25zdCBpbml0aWFsRm9jdXNWYWx1ZSA9IGluaXRpYWxGb2N1c1JlZi5jdXJyZW50O1xuICAgICAgY29uc3QgZWxUb0ZvY3VzID0gKHR5cGVvZiBpbml0aWFsRm9jdXNWYWx1ZSA9PT0gJ251bWJlcicgPyBmb2N1c2FibGVFbGVtZW50c1tpbml0aWFsRm9jdXNWYWx1ZV0gOiBpbml0aWFsRm9jdXNWYWx1ZS5jdXJyZW50KSB8fCBmbG9hdGluZztcbiAgICAgIGNvbnN0IGZvY3VzQWxyZWFkeUluc2lkZUZsb2F0aW5nRWwgPSBjb250YWlucyhmbG9hdGluZywgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50KTtcbiAgICAgIGlmICghaWdub3JlSW5pdGlhbEZvY3VzICYmICFmb2N1c0FscmVhZHlJbnNpZGVGbG9hdGluZ0VsICYmIG9wZW4pIHtcbiAgICAgICAgZW5xdWV1ZUZvY3VzKGVsVG9Gb2N1cywge1xuICAgICAgICAgIHByZXZlbnRTY3JvbGw6IGVsVG9Gb2N1cyA9PT0gZmxvYXRpbmdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtkaXNhYmxlZCwgb3BlbiwgZmxvYXRpbmcsIGlnbm9yZUluaXRpYWxGb2N1cywgZ2V0VGFiYmFibGVFbGVtZW50cywgaW5pdGlhbEZvY3VzUmVmXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgIWZsb2F0aW5nKSByZXR1cm47XG4gICAgbGV0IHByZXZlbnRSZXR1cm5Gb2N1c1Njcm9sbCA9IGZhbHNlO1xuICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KGZsb2F0aW5nKTtcbiAgICBjb25zdCBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgPSBhY3RpdmVFbGVtZW50KGRvYyk7XG4gICAgY29uc3QgY29udGV4dERhdGEgPSBkYXRhUmVmLmN1cnJlbnQ7XG4gICAgYWRkUHJldmlvdXNseUZvY3VzZWRFbGVtZW50KHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCk7XG5cbiAgICAvLyBEaXNtaXNzaW5nIHZpYSBvdXRzaWRlIHByZXNzIHNob3VsZCBhbHdheXMgaWdub3JlIGByZXR1cm5Gb2N1c2AgdG9cbiAgICAvLyBwcmV2ZW50IHVud2FudGVkIHNjcm9sbGluZy5cbiAgICBmdW5jdGlvbiBvbk9wZW5DaGFuZ2UoX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgcmVhc29uLFxuICAgICAgICBldmVudCxcbiAgICAgICAgbmVzdGVkXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIGlmIChyZWFzb24gPT09ICdlc2NhcGUta2V5JyAmJiByZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50KSB7XG4gICAgICAgIGFkZFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudChyZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWFzb24gPT09ICdob3ZlcicgJiYgZXZlbnQudHlwZSA9PT0gJ21vdXNlbGVhdmUnKSB7XG4gICAgICAgIHByZXZlbnRSZXR1cm5Gb2N1c1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWFzb24gIT09ICdvdXRzaWRlLXByZXNzJykgcmV0dXJuO1xuICAgICAgaWYgKG5lc3RlZCkge1xuICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNTY3JvbGwgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSAhKGlzVmlydHVhbENsaWNrKGV2ZW50KSB8fCBpc1ZpcnR1YWxQb2ludGVyRXZlbnQoZXZlbnQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZXZlbnRzLm9uKCdvcGVuY2hhbmdlJywgb25PcGVuQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZXZlbnRzLm9mZignb3BlbmNoYW5nZScsIG9uT3BlbkNoYW5nZSk7XG4gICAgICBjb25zdCBhY3RpdmVFbCA9IGFjdGl2ZUVsZW1lbnQoZG9jKTtcbiAgICAgIGNvbnN0IGlzRm9jdXNJbnNpZGVGbG9hdGluZ1RyZWUgPSBjb250YWlucyhmbG9hdGluZywgYWN0aXZlRWwpIHx8IHRyZWUgJiYgZ2V0Q2hpbGRyZW4odHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpLnNvbWUobm9kZSA9PiB7XG4gICAgICAgIHZhciBfbm9kZSRjb250ZXh0NTtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zKChfbm9kZSRjb250ZXh0NSA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQ1LmVsZW1lbnRzLmZsb2F0aW5nLCBhY3RpdmVFbCk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHNob3VsZEZvY3VzUmVmZXJlbmNlID0gaXNGb2N1c0luc2lkZUZsb2F0aW5nVHJlZSB8fCBjb250ZXh0RGF0YS5vcGVuRXZlbnQgJiYgWydjbGljaycsICdtb3VzZWRvd24nXS5pbmNsdWRlcyhjb250ZXh0RGF0YS5vcGVuRXZlbnQudHlwZSk7XG4gICAgICBpZiAoc2hvdWxkRm9jdXNSZWZlcmVuY2UgJiYgcmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCkge1xuICAgICAgICBhZGRQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQocmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXR1cm5FbGVtZW50ID0gZ2V0UHJldmlvdXNseUZvY3VzZWRFbGVtZW50KCk7XG4gICAgICBpZiAocmV0dXJuRm9jdXNSZWYuY3VycmVudCAmJiAhcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgJiYgaXNIVE1MRWxlbWVudChyZXR1cm5FbGVtZW50KSAmJiAoXG4gICAgICAvLyBJZiB0aGUgZm9jdXMgbW92ZWQgc29tZXdoZXJlIGVsc2UgYWZ0ZXIgbW91bnQsIGF2b2lkIHJldHVybmluZyBmb2N1c1xuICAgICAgLy8gc2luY2UgaXQgbGlrZWx5IGVudGVyZWQgYSBkaWZmZXJlbnQgZWxlbWVudCB3aGljaCBzaG91bGQgYmVcbiAgICAgIC8vIHJlc3BlY3RlZDogaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8yNjA3XG4gICAgICByZXR1cm5FbGVtZW50ICE9PSBhY3RpdmVFbCAmJiBhY3RpdmVFbCAhPT0gZG9jLmJvZHkgPyBpc0ZvY3VzSW5zaWRlRmxvYXRpbmdUcmVlIDogdHJ1ZSkpIHtcbiAgICAgICAgZW5xdWV1ZUZvY3VzKHJldHVybkVsZW1lbnQsIHtcbiAgICAgICAgICAvLyBXaGVuIGRpc21pc3NpbmcgbmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzLCBieSB0aGUgdGltZSB0aGUgckFGIGhhc1xuICAgICAgICAgIC8vIGV4ZWN1dGVkLCB0aGUgbWVudXMgd2lsbCBhbGwgaGF2ZSBiZWVuIHVubW91bnRlZC4gV2hlbiB0aGV5IHRyeVxuICAgICAgICAgIC8vIHRvIGdldCBmb2N1c2VkLCB0aGUgY2FsbHMgZ2V0IGlnbm9yZWQg4oCUIGxlYXZpbmcgdGhlIHJvb3RcbiAgICAgICAgICAvLyByZWZlcmVuY2UgZm9jdXNlZCBhcyBkZXNpcmVkLlxuICAgICAgICAgIGNhbmNlbFByZXZpb3VzOiBmYWxzZSxcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiBwcmV2ZW50UmV0dXJuRm9jdXNTY3JvbGxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2Rpc2FibGVkLCBmbG9hdGluZywgcmV0dXJuRm9jdXNSZWYsIGRhdGFSZWYsIHJlZnMsIGV2ZW50cywgdHJlZSwgbm9kZUlkXSk7XG5cbiAgLy8gU3luY2hyb25pemUgdGhlIGBjb250ZXh0YCAmIGBtb2RhbGAgdmFsdWUgdG8gdGhlIEZsb2F0aW5nUG9ydGFsIGNvbnRleHQuXG4gIC8vIEl0IHdpbGwgZGVjaWRlIHdoZXRoZXIgb3Igbm90IGl0IG5lZWRzIHRvIHJlbmRlciBpdHMgb3duIGd1YXJkcy5cbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCB8fCAhcG9ydGFsQ29udGV4dCkgcmV0dXJuO1xuICAgIHBvcnRhbENvbnRleHQuc2V0Rm9jdXNNYW5hZ2VyU3RhdGUoe1xuICAgICAgbW9kYWwsXG4gICAgICBjbG9zZU9uRm9jdXNPdXQsXG4gICAgICBvcGVuLFxuICAgICAgb25PcGVuQ2hhbmdlLFxuICAgICAgcmVmc1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwb3J0YWxDb250ZXh0LnNldEZvY3VzTWFuYWdlclN0YXRlKG51bGwpO1xuICAgIH07XG4gIH0sIFtkaXNhYmxlZCwgcG9ydGFsQ29udGV4dCwgbW9kYWwsIG9wZW4sIG9uT3BlbkNoYW5nZSwgcmVmcywgY2xvc2VPbkZvY3VzT3V0XSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgIWZsb2F0aW5nIHx8IHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAnZnVuY3Rpb24nIHx8IGlnbm9yZUluaXRpYWxGb2N1cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVNdXRhdGlvbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHRhYkluZGV4ID0gZmxvYXRpbmcuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgaWYgKG9yZGVyUmVmLmN1cnJlbnQuaW5jbHVkZXMoJ2Zsb2F0aW5nJykgfHwgYWN0aXZlRWxlbWVudChnZXREb2N1bWVudChmbG9hdGluZykpICE9PSByZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50ICYmIGdldFRhYmJhYmxlQ29udGVudCgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAodGFiSW5kZXggIT09ICcwJykge1xuICAgICAgICAgIGZsb2F0aW5nLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnMCcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRhYkluZGV4ICE9PSAnLTEnKSB7XG4gICAgICAgIGZsb2F0aW5nLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGhhbmRsZU11dGF0aW9uKCk7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihoYW5kbGVNdXRhdGlvbik7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShmbG9hdGluZywge1xuICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgIGF0dHJpYnV0ZXM6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH07XG4gIH0sIFtkaXNhYmxlZCwgZmxvYXRpbmcsIHJlZnMsIG9yZGVyUmVmLCBnZXRUYWJiYWJsZUNvbnRlbnQsIGlnbm9yZUluaXRpYWxGb2N1c10pO1xuICBmdW5jdGlvbiByZW5kZXJEaXNtaXNzQnV0dG9uKGxvY2F0aW9uKSB7XG4gICAgaWYgKGRpc2FibGVkIHx8ICF2aXN1YWxseUhpZGRlbkRpc21pc3MgfHwgIW1vZGFsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFZpc3VhbGx5SGlkZGVuRGlzbWlzcywge1xuICAgICAgcmVmOiBsb2NhdGlvbiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0RGlzbWlzc0J1dHRvblJlZiA6IGVuZERpc21pc3NCdXR0b25SZWYsXG4gICAgICBvbkNsaWNrOiBldmVudCA9PiBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50KVxuICAgIH0sIHR5cGVvZiB2aXN1YWxseUhpZGRlbkRpc21pc3MgPT09ICdzdHJpbmcnID8gdmlzdWFsbHlIaWRkZW5EaXNtaXNzIDogJ0Rpc21pc3MnKTtcbiAgfVxuICBjb25zdCBzaG91bGRSZW5kZXJHdWFyZHMgPSAhZGlzYWJsZWQgJiYgZ3VhcmRzICYmIChpc0luc2lkZVBvcnRhbCB8fCBtb2RhbCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgc2hvdWxkUmVuZGVyR3VhcmRzICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvY3VzR3VhcmQsIHtcbiAgICBcImRhdGEtdHlwZVwiOiBcImluc2lkZVwiLFxuICAgIHJlZjogcG9ydGFsQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcG9ydGFsQ29udGV4dC5iZWZvcmVJbnNpZGVSZWYsXG4gICAgb25Gb2N1czogZXZlbnQgPT4ge1xuICAgICAgaWYgKG1vZGFsKSB7XG4gICAgICAgIGNvbnN0IGVscyA9IGdldFRhYmJhYmxlRWxlbWVudHMoKTtcbiAgICAgICAgZW5xdWV1ZUZvY3VzKG9yZGVyWzBdID09PSAncmVmZXJlbmNlJyA/IGVsc1swXSA6IGVsc1tlbHMubGVuZ3RoIC0gMV0pO1xuICAgICAgfSBlbHNlIGlmIChwb3J0YWxDb250ZXh0ICE9IG51bGwgJiYgcG9ydGFsQ29udGV4dC5wcmVzZXJ2ZVRhYk9yZGVyICYmIHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkge1xuICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBpZiAoaXNPdXRzaWRlRXZlbnQoZXZlbnQsIHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBuZXh0VGFiYmFibGUgPSBnZXROZXh0VGFiYmFibGUoKSB8fCBkb21SZWZlcmVuY2U7XG4gICAgICAgICAgbmV4dFRhYmJhYmxlID09IG51bGwgfHwgbmV4dFRhYmJhYmxlLmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9wb3J0YWxDb250ZXh0JGJlZm9yZTtcbiAgICAgICAgICAoX3BvcnRhbENvbnRleHQkYmVmb3JlID0gcG9ydGFsQ29udGV4dC5iZWZvcmVPdXRzaWRlUmVmLmN1cnJlbnQpID09IG51bGwgfHwgX3BvcnRhbENvbnRleHQkYmVmb3JlLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pLCAhaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94ICYmIHJlbmRlckRpc21pc3NCdXR0b24oJ3N0YXJ0JyksIGNoaWxkcmVuLCByZW5kZXJEaXNtaXNzQnV0dG9uKCdlbmQnKSwgc2hvdWxkUmVuZGVyR3VhcmRzICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvY3VzR3VhcmQsIHtcbiAgICBcImRhdGEtdHlwZVwiOiBcImluc2lkZVwiLFxuICAgIHJlZjogcG9ydGFsQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcG9ydGFsQ29udGV4dC5hZnRlckluc2lkZVJlZixcbiAgICBvbkZvY3VzOiBldmVudCA9PiB7XG4gICAgICBpZiAobW9kYWwpIHtcbiAgICAgICAgZW5xdWV1ZUZvY3VzKGdldFRhYmJhYmxlRWxlbWVudHMoKVswXSk7XG4gICAgICB9IGVsc2UgaWYgKHBvcnRhbENvbnRleHQgIT0gbnVsbCAmJiBwb3J0YWxDb250ZXh0LnByZXNlcnZlVGFiT3JkZXIgJiYgcG9ydGFsQ29udGV4dC5wb3J0YWxOb2RlKSB7XG4gICAgICAgIGlmIChjbG9zZU9uRm9jdXNPdXQpIHtcbiAgICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgcHJldlRhYmJhYmxlID0gZ2V0UHJldmlvdXNUYWJiYWJsZSgpIHx8IGRvbVJlZmVyZW5jZTtcbiAgICAgICAgICBwcmV2VGFiYmFibGUgPT0gbnVsbCB8fCBwcmV2VGFiYmFibGUuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX3BvcnRhbENvbnRleHQkYWZ0ZXJPO1xuICAgICAgICAgIChfcG9ydGFsQ29udGV4dCRhZnRlck8gPSBwb3J0YWxDb250ZXh0LmFmdGVyT3V0c2lkZVJlZi5jdXJyZW50KSA9PSBudWxsIHx8IF9wb3J0YWxDb250ZXh0JGFmdGVyTy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KSk7XG59XG5cbmNvbnN0IGFjdGl2ZUxvY2tzID0gLyojX19QVVJFX18qL25ldyBTZXQoKTtcbi8qKlxuICogUHJvdmlkZXMgYmFzZSBzdHlsaW5nIGZvciBhIGZpeGVkIG92ZXJsYXkgZWxlbWVudCB0byBkaW0gY29udGVudCBvciBibG9ja1xuICogcG9pbnRlciBldmVudHMgYmVoaW5kIGEgZmxvYXRpbmcgZWxlbWVudC5cbiAqIEl0J3MgYSByZWd1bGFyIGA8ZGl2PmAsIHNvIGl0IGNhbiBiZSBzdHlsZWQgdmlhIGFueSBDU1Mgc29sdXRpb24geW91IHByZWZlci5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ092ZXJsYXlcbiAqL1xuY29uc3QgRmxvYXRpbmdPdmVybGF5ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gRmxvYXRpbmdPdmVybGF5KF9yZWYsIHJlZikge1xuICBsZXQge1xuICAgIGxvY2tTY3JvbGwgPSBmYWxzZSxcbiAgICAuLi5yZXN0XG4gIH0gPSBfcmVmO1xuICBjb25zdCBsb2NrSWQgPSB1c2VJZCgpO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKCFsb2NrU2Nyb2xsKSByZXR1cm47XG4gICAgYWN0aXZlTG9ja3MuYWRkKGxvY2tJZCk7XG4gICAgY29uc3QgaXNJT1MgPSAvaVAoaG9uZXxhZHxvZCl8aU9TLy50ZXN0KGdldFBsYXRmb3JtKCkpO1xuICAgIGNvbnN0IGJvZHlTdHlsZSA9IGRvY3VtZW50LmJvZHkuc3R5bGU7XG4gICAgLy8gUlRMIDxib2R5PiBzY3JvbGxiYXJcbiAgICBjb25zdCBzY3JvbGxiYXJYID0gTWF0aC5yb3VuZChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCkgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICBjb25zdCBwYWRkaW5nUHJvcCA9IHNjcm9sbGJhclggPyAncGFkZGluZ0xlZnQnIDogJ3BhZGRpbmdSaWdodCc7XG4gICAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICBjb25zdCBzY3JvbGxYID0gYm9keVN0eWxlLmxlZnQgPyBwYXJzZUZsb2F0KGJvZHlTdHlsZS5sZWZ0KSA6IHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICBjb25zdCBzY3JvbGxZID0gYm9keVN0eWxlLnRvcCA/IHBhcnNlRmxvYXQoYm9keVN0eWxlLnRvcCkgOiB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgYm9keVN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgaWYgKHNjcm9sbGJhcldpZHRoKSB7XG4gICAgICBib2R5U3R5bGVbcGFkZGluZ1Byb3BdID0gc2Nyb2xsYmFyV2lkdGggKyBcInB4XCI7XG4gICAgfVxuXG4gICAgLy8gT25seSBpT1MgZG9lc24ndCByZXNwZWN0IGBvdmVyZmxvdzogaGlkZGVuYCBvbiBkb2N1bWVudC5ib2R5LCBhbmQgdGhpc1xuICAgIC8vIHRlY2huaXF1ZSBoYXMgZmV3ZXIgc2lkZSBlZmZlY3RzLlxuICAgIGlmIChpc0lPUykge1xuICAgICAgdmFyIF93aW5kb3ckdmlzdWFsVmlld3BvciwgX3dpbmRvdyR2aXN1YWxWaWV3cG9yMjtcbiAgICAgIC8vIGlPUyAxMiBkb2VzIG5vdCBzdXBwb3J0IGB2aXN1YWxWaWV3cG9ydGAuXG4gICAgICBjb25zdCBvZmZzZXRMZWZ0ID0gKChfd2luZG93JHZpc3VhbFZpZXdwb3IgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQpID09IG51bGwgPyB2b2lkIDAgOiBfd2luZG93JHZpc3VhbFZpZXdwb3Iub2Zmc2V0TGVmdCkgfHwgMDtcbiAgICAgIGNvbnN0IG9mZnNldFRvcCA9ICgoX3dpbmRvdyR2aXN1YWxWaWV3cG9yMiA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3ckdmlzdWFsVmlld3BvcjIub2Zmc2V0VG9wKSB8fCAwO1xuICAgICAgT2JqZWN0LmFzc2lnbihib2R5U3R5bGUsIHtcbiAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgIHRvcDogLShzY3JvbGxZIC0gTWF0aC5mbG9vcihvZmZzZXRUb3ApKSArIFwicHhcIixcbiAgICAgICAgbGVmdDogLShzY3JvbGxYIC0gTWF0aC5mbG9vcihvZmZzZXRMZWZ0KSkgKyBcInB4XCIsXG4gICAgICAgIHJpZ2h0OiAnMCdcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgYWN0aXZlTG9ja3MuZGVsZXRlKGxvY2tJZCk7XG4gICAgICBpZiAoYWN0aXZlTG9ja3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICBPYmplY3QuYXNzaWduKGJvZHlTdHlsZSwge1xuICAgICAgICAgIG92ZXJmbG93OiAnJyxcbiAgICAgICAgICBbcGFkZGluZ1Byb3BdOiAnJ1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzSU9TKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihib2R5U3R5bGUsIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnJyxcbiAgICAgICAgICAgIHRvcDogJycsXG4gICAgICAgICAgICBsZWZ0OiAnJyxcbiAgICAgICAgICAgIHJpZ2h0OiAnJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyhzY3JvbGxYLCBzY3JvbGxZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtsb2NrSWQsIGxvY2tTY3JvbGxdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHtcbiAgICByZWY6IHJlZlxuICB9LCByZXN0LCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgb3ZlcmZsb3c6ICdhdXRvJyxcbiAgICAgIHRvcDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIC4uLnJlc3Quc3R5bGVcbiAgICB9XG4gIH0pKTtcbn0pO1xuXG5mdW5jdGlvbiBpc0J1dHRvblRhcmdldChldmVudCkge1xuICByZXR1cm4gaXNIVE1MRWxlbWVudChldmVudC50YXJnZXQpICYmIGV2ZW50LnRhcmdldC50YWdOYW1lID09PSAnQlVUVE9OJztcbn1cbmZ1bmN0aW9uIGlzU3BhY2VJZ25vcmVkKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGlzVHlwZWFibGVFbGVtZW50KGVsZW1lbnQpO1xufVxuLyoqXG4gKiBPcGVucyBvciBjbG9zZXMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgd2hlbiBjbGlja2luZyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlQ2xpY2tcbiAqL1xuZnVuY3Rpb24gdXNlQ2xpY2soY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICBkYXRhUmVmLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBkb21SZWZlcmVuY2VcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgZXZlbnQ6IGV2ZW50T3B0aW9uID0gJ2NsaWNrJyxcbiAgICB0b2dnbGUgPSB0cnVlLFxuICAgIGlnbm9yZU1vdXNlID0gZmFsc2UsXG4gICAga2V5Ym9hcmRIYW5kbGVycyA9IHRydWVcbiAgfSA9IHByb3BzO1xuICBjb25zdCBwb2ludGVyVHlwZVJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBkaWRLZXlEb3duUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuIHt9O1xuICAgIHJldHVybiB7XG4gICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgb25Qb2ludGVyRG93bihldmVudCkge1xuICAgICAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSBldmVudC5wb2ludGVyVHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgYWxsIGJ1dHRvbnMgZXhjZXB0IGZvciB0aGUgXCJtYWluXCIgYnV0dG9uLlxuICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Nb3VzZUV2ZW50L2J1dHRvblxuICAgICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzTW91c2VMaWtlUG9pbnRlclR5cGUocG9pbnRlclR5cGVSZWYuY3VycmVudCwgdHJ1ZSkgJiYgaWdub3JlTW91c2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV2ZW50T3B0aW9uID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcGVuICYmIHRvZ2dsZSAmJiAoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCA/IGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgOiB0cnVlKSkge1xuICAgICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgc3RlYWxpbmcgZm9jdXMgZnJvbSB0aGUgZmxvYXRpbmcgZWxlbWVudFxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKGV2ZW50T3B0aW9uID09PSAnbW91c2Vkb3duJyAmJiBwb2ludGVyVHlwZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZVJlZi5jdXJyZW50LCB0cnVlKSAmJiBpZ25vcmVNb3VzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3BlbiAmJiB0b2dnbGUgJiYgKGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQgPyBkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50LnR5cGUgPT09ICdjbGljaycgOiB0cnVlKSkge1xuICAgICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbktleURvd24oZXZlbnQpIHtcbiAgICAgICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkIHx8ICFrZXlib2FyZEhhbmRsZXJzIHx8IGlzQnV0dG9uVGFyZ2V0KGV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnICcgJiYgIWlzU3BhY2VJZ25vcmVkKGRvbVJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgc2Nyb2xsaW5nXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZGlkS2V5RG93blJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICAgICAgaWYgKG9wZW4gJiYgdG9nZ2xlKSB7XG4gICAgICAgICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQsICdjbGljaycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uS2V5VXAoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCB8fCAha2V5Ym9hcmRIYW5kbGVycyB8fCBpc0J1dHRvblRhcmdldChldmVudCkgfHwgaXNTcGFjZUlnbm9yZWQoZG9tUmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnICcgJiYgZGlkS2V5RG93blJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBkaWRLZXlEb3duUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChvcGVuICYmIHRvZ2dsZSkge1xuICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIGRhdGFSZWYsIGV2ZW50T3B0aW9uLCBpZ25vcmVNb3VzZSwga2V5Ym9hcmRIYW5kbGVycywgZG9tUmVmZXJlbmNlLCB0b2dnbGUsIG9wZW4sIG9uT3BlbkNoYW5nZV0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVWaXJ0dWFsRWxlbWVudChkb21SZWYsIGRhdGEpIHtcbiAgbGV0IG9mZnNldFggPSBudWxsO1xuICBsZXQgb2Zmc2V0WSA9IG51bGw7XG4gIGxldCBpc0F1dG9VcGRhdGVFdmVudCA9IGZhbHNlO1xuICByZXR1cm4ge1xuICAgIGNvbnRleHRFbGVtZW50OiBkb21SZWYuY3VycmVudCB8fCB1bmRlZmluZWQsXG4gICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkge1xuICAgICAgdmFyIF9kb21SZWYkY3VycmVudCwgX2RhdGEkZGF0YVJlZiRjdXJyZW50O1xuICAgICAgY29uc3QgZG9tUmVjdCA9ICgoX2RvbVJlZiRjdXJyZW50ID0gZG9tUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZG9tUmVmJGN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpIHx8IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGlzWEF4aXMgPSBkYXRhLmF4aXMgPT09ICd4JyB8fCBkYXRhLmF4aXMgPT09ICdib3RoJztcbiAgICAgIGNvbnN0IGlzWUF4aXMgPSBkYXRhLmF4aXMgPT09ICd5JyB8fCBkYXRhLmF4aXMgPT09ICdib3RoJztcbiAgICAgIGNvbnN0IGNhblRyYWNrQ3Vyc29yT25BdXRvVXBkYXRlID0gWydtb3VzZWVudGVyJywgJ21vdXNlbW92ZSddLmluY2x1ZGVzKCgoX2RhdGEkZGF0YVJlZiRjdXJyZW50ID0gZGF0YS5kYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGEkZGF0YVJlZiRjdXJyZW50LnR5cGUpIHx8ICcnKSAmJiBkYXRhLnBvaW50ZXJUeXBlICE9PSAndG91Y2gnO1xuICAgICAgbGV0IHdpZHRoID0gZG9tUmVjdC53aWR0aDtcbiAgICAgIGxldCBoZWlnaHQgPSBkb21SZWN0LmhlaWdodDtcbiAgICAgIGxldCB4ID0gZG9tUmVjdC54O1xuICAgICAgbGV0IHkgPSBkb21SZWN0Lnk7XG4gICAgICBpZiAob2Zmc2V0WCA9PSBudWxsICYmIGRhdGEueCAmJiBpc1hBeGlzKSB7XG4gICAgICAgIG9mZnNldFggPSBkb21SZWN0LnggLSBkYXRhLng7XG4gICAgICB9XG4gICAgICBpZiAob2Zmc2V0WSA9PSBudWxsICYmIGRhdGEueSAmJiBpc1lBeGlzKSB7XG4gICAgICAgIG9mZnNldFkgPSBkb21SZWN0LnkgLSBkYXRhLnk7XG4gICAgICB9XG4gICAgICB4IC09IG9mZnNldFggfHwgMDtcbiAgICAgIHkgLT0gb2Zmc2V0WSB8fCAwO1xuICAgICAgd2lkdGggPSAwO1xuICAgICAgaGVpZ2h0ID0gMDtcbiAgICAgIGlmICghaXNBdXRvVXBkYXRlRXZlbnQgfHwgY2FuVHJhY2tDdXJzb3JPbkF1dG9VcGRhdGUpIHtcbiAgICAgICAgd2lkdGggPSBkYXRhLmF4aXMgPT09ICd5JyA/IGRvbVJlY3Qud2lkdGggOiAwO1xuICAgICAgICBoZWlnaHQgPSBkYXRhLmF4aXMgPT09ICd4JyA/IGRvbVJlY3QuaGVpZ2h0IDogMDtcbiAgICAgICAgeCA9IGlzWEF4aXMgJiYgZGF0YS54ICE9IG51bGwgPyBkYXRhLnggOiB4O1xuICAgICAgICB5ID0gaXNZQXhpcyAmJiBkYXRhLnkgIT0gbnVsbCA/IGRhdGEueSA6IHk7XG4gICAgICB9IGVsc2UgaWYgKGlzQXV0b1VwZGF0ZUV2ZW50ICYmICFjYW5UcmFja0N1cnNvck9uQXV0b1VwZGF0ZSkge1xuICAgICAgICBoZWlnaHQgPSBkYXRhLmF4aXMgPT09ICd4JyA/IGRvbVJlY3QuaGVpZ2h0IDogaGVpZ2h0O1xuICAgICAgICB3aWR0aCA9IGRhdGEuYXhpcyA9PT0gJ3knID8gZG9tUmVjdC53aWR0aCA6IHdpZHRoO1xuICAgICAgfVxuICAgICAgaXNBdXRvVXBkYXRlRXZlbnQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgdG9wOiB5LFxuICAgICAgICByaWdodDogeCArIHdpZHRoLFxuICAgICAgICBib3R0b206IHkgKyBoZWlnaHQsXG4gICAgICAgIGxlZnQ6IHhcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaXNNb3VzZUJhc2VkRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50ICE9IG51bGwgJiYgZXZlbnQuY2xpZW50WCAhPSBudWxsO1xufVxuLyoqXG4gKiBQb3NpdGlvbnMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgcmVsYXRpdmUgdG8gYSBjbGllbnQgcG9pbnQgKGluIHRoZSB2aWV3cG9ydCksXG4gKiBzdWNoIGFzIHRoZSBtb3VzZSBwb3NpdGlvbi4gQnkgZGVmYXVsdCwgaXQgZm9sbG93cyB0aGUgbW91c2UgY3Vyc29yLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUNsaWVudFBvaW50XG4gKi9cbmZ1bmN0aW9uIHVzZUNsaWVudFBvaW50KGNvbnRleHQsIHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICByZWZzLFxuICAgIGRhdGFSZWYsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGZsb2F0aW5nXG4gICAgfVxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIGF4aXMgPSAnYm90aCcsXG4gICAgeCA9IG51bGwsXG4gICAgeSA9IG51bGxcbiAgfSA9IHByb3BzO1xuICBjb25zdCBpbml0aWFsUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgY2xlYW51cExpc3RlbmVyUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBbcG9pbnRlclR5cGUsIHNldFBvaW50ZXJUeXBlXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gIGNvbnN0IFtyZWFjdGl2ZSwgc2V0UmVhY3RpdmVdID0gUmVhY3QudXNlU3RhdGUoW10pO1xuICBjb25zdCBzZXRSZWZlcmVuY2UgPSB1c2VFZmZlY3RFdmVudCgoeCwgeSkgPT4ge1xuICAgIGlmIChpbml0aWFsUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgIC8vIFByZXZlbnQgc2V0dGluZyBpZiB0aGUgb3BlbiBldmVudCB3YXMgbm90IGEgbW91c2UtbGlrZSBvbmVcbiAgICAvLyAoZS5nLiBmb2N1cyB0byBvcGVuLCB0aGVuIGhvdmVyIG92ZXIgdGhlIHJlZmVyZW5jZSBlbGVtZW50KS5cbiAgICAvLyBPbmx5IGFwcGx5IGlmIHRoZSBldmVudCBleGlzdHMuXG4gICAgaWYgKGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQgJiYgIWlzTW91c2VCYXNlZEV2ZW50KGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlZnMuc2V0UG9zaXRpb25SZWZlcmVuY2UoY3JlYXRlVmlydHVhbEVsZW1lbnQocmVmcy5kb21SZWZlcmVuY2UsIHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgYXhpcyxcbiAgICAgIGRhdGFSZWYsXG4gICAgICBwb2ludGVyVHlwZVxuICAgIH0pKTtcbiAgfSk7XG4gIGNvbnN0IGhhbmRsZVJlZmVyZW5jZUVudGVyT3JNb3ZlID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIGlmICh4ICE9IG51bGwgfHwgeSAhPSBudWxsKSByZXR1cm47XG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICBzZXRSZWZlcmVuY2UoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgfSBlbHNlIGlmICghY2xlYW51cExpc3RlbmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gY2xlYW51cCwgdGhlcmUncyBubyBsaXN0ZW5lciwgYnV0IHdlIHdhbnQgdG8gZW5zdXJlXG4gICAgICAvLyB3ZSBhZGQgdGhlIGxpc3RlbmVyIGlmIHRoZSBjdXJzb3IgbGFuZGVkIG9uIHRoZSBmbG9hdGluZyBlbGVtZW50IGFuZFxuICAgICAgLy8gdGhlbiBiYWNrIG9uIHRoZSByZWZlcmVuY2UgKGkuZS4gaXQncyBpbnRlcmFjdGl2ZSkuXG4gICAgICBzZXRSZWFjdGl2ZShbXSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBJZiB0aGUgcG9pbnRlciBpcyBhIG1vdXNlLWxpa2UgcG9pbnRlciwgd2Ugd2FudCB0byBjb250aW51ZSBmb2xsb3dpbmcgdGhlXG4gIC8vIG1vdXNlIGV2ZW4gaWYgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgdHJhbnNpdGlvbmluZyBvdXQuIE9uIHRvdWNoXG4gIC8vIGRldmljZXMsIHRoaXMgaXMgdW5kZXNpcmFibGUgYmVjYXVzZSB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aWxsIG1vdmUgdG9cbiAgLy8gdGhlIGRpc21pc3NhbCB0b3VjaCBwb2ludC5cbiAgY29uc3Qgb3BlbkNoZWNrID0gaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZSkgPyBmbG9hdGluZyA6IG9wZW47XG4gIGNvbnN0IGFkZExpc3RlbmVyID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIC8vIEV4cGxpY2l0bHkgc3BlY2lmaWVkIGB4YC9geWAgY29vcmRpbmF0ZXMgc2hvdWxkbid0IGFkZCBhIGxpc3RlbmVyLlxuICAgIGlmICghb3BlbkNoZWNrIHx8ICFlbmFibGVkIHx8IHggIT0gbnVsbCB8fCB5ICE9IG51bGwpIHJldHVybjtcbiAgICBjb25zdCB3aW4gPSBnZXRXaW5kb3cocmVmcy5mbG9hdGluZy5jdXJyZW50KTtcbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChldmVudCk7XG4gICAgICBpZiAoIWNvbnRhaW5zKHJlZnMuZmxvYXRpbmcuY3VycmVudCwgdGFyZ2V0KSkge1xuICAgICAgICBzZXRSZWZlcmVuY2UoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgY2xlYW51cExpc3RlbmVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQgfHwgaXNNb3VzZUJhc2VkRXZlbnQoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCkpIHtcbiAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICAgIGNsZWFudXBMaXN0ZW5lclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH07XG4gICAgICBjbGVhbnVwTGlzdGVuZXJSZWYuY3VycmVudCA9IGNsZWFudXA7XG4gICAgICByZXR1cm4gY2xlYW51cDtcbiAgICB9XG4gICAgcmVmcy5zZXRQb3NpdGlvblJlZmVyZW5jZShyZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50KTtcbiAgfSwgW2RhdGFSZWYsIGVuYWJsZWQsIG9wZW5DaGVjaywgcmVmcywgc2V0UmVmZXJlbmNlLCB4LCB5XSk7XG5cbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvY29ycmVjdG5lc3MvdXNlRXhoYXVzdGl2ZURlcGVuZGVuY2llczogaW50ZW50aW9uYWxseSBzcGVjaWZ5aW5nIGByZWFjdGl2ZWBcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gYWRkTGlzdGVuZXIoKTtcbiAgfSwgW2FkZExpc3RlbmVyLCByZWFjdGl2ZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChlbmFibGVkICYmICFmbG9hdGluZykge1xuICAgICAgaW5pdGlhbFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgZmxvYXRpbmddKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQgJiYgb3Blbikge1xuICAgICAgaW5pdGlhbFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoZW5hYmxlZCAmJiAoeCAhPSBudWxsIHx8IHkgIT0gbnVsbCkpIHtcbiAgICAgIGluaXRpYWxSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgc2V0UmVmZXJlbmNlKHgsIHkpO1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIHgsIHksIHNldFJlZmVyZW5jZV0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm4ge307XG4gICAgZnVuY3Rpb24gc2V0UG9pbnRlclR5cGVSZWYoX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgcG9pbnRlclR5cGVcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgc2V0UG9pbnRlclR5cGUocG9pbnRlclR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgIG9uUG9pbnRlckRvd246IHNldFBvaW50ZXJUeXBlUmVmLFxuICAgICAgICBvblBvaW50ZXJFbnRlcjogc2V0UG9pbnRlclR5cGVSZWYsXG4gICAgICAgIG9uTW91c2VNb3ZlOiBoYW5kbGVSZWZlcmVuY2VFbnRlck9yTW92ZSxcbiAgICAgICAgb25Nb3VzZUVudGVyOiBoYW5kbGVSZWZlcmVuY2VFbnRlck9yTW92ZVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbmFibGVkLCBoYW5kbGVSZWZlcmVuY2VFbnRlck9yTW92ZV0pO1xufVxuXG5jb25zdCBidWJibGVIYW5kbGVyS2V5cyA9IHtcbiAgcG9pbnRlcmRvd246ICdvblBvaW50ZXJEb3duJyxcbiAgbW91c2Vkb3duOiAnb25Nb3VzZURvd24nLFxuICBjbGljazogJ29uQ2xpY2snXG59O1xuY29uc3QgY2FwdHVyZUhhbmRsZXJLZXlzID0ge1xuICBwb2ludGVyZG93bjogJ29uUG9pbnRlckRvd25DYXB0dXJlJyxcbiAgbW91c2Vkb3duOiAnb25Nb3VzZURvd25DYXB0dXJlJyxcbiAgY2xpY2s6ICdvbkNsaWNrQ2FwdHVyZSdcbn07XG5jb25zdCBub3JtYWxpemVQcm9wID0gbm9ybWFsaXphYmxlID0+IHtcbiAgdmFyIF9ub3JtYWxpemFibGUkZXNjYXBlSywgX25vcm1hbGl6YWJsZSRvdXRzaWRlO1xuICByZXR1cm4ge1xuICAgIGVzY2FwZUtleTogdHlwZW9mIG5vcm1hbGl6YWJsZSA9PT0gJ2Jvb2xlYW4nID8gbm9ybWFsaXphYmxlIDogKF9ub3JtYWxpemFibGUkZXNjYXBlSyA9IG5vcm1hbGl6YWJsZSA9PSBudWxsID8gdm9pZCAwIDogbm9ybWFsaXphYmxlLmVzY2FwZUtleSkgIT0gbnVsbCA/IF9ub3JtYWxpemFibGUkZXNjYXBlSyA6IGZhbHNlLFxuICAgIG91dHNpZGVQcmVzczogdHlwZW9mIG5vcm1hbGl6YWJsZSA9PT0gJ2Jvb2xlYW4nID8gbm9ybWFsaXphYmxlIDogKF9ub3JtYWxpemFibGUkb3V0c2lkZSA9IG5vcm1hbGl6YWJsZSA9PSBudWxsID8gdm9pZCAwIDogbm9ybWFsaXphYmxlLm91dHNpZGVQcmVzcykgIT0gbnVsbCA/IF9ub3JtYWxpemFibGUkb3V0c2lkZSA6IHRydWVcbiAgfTtcbn07XG4vKipcbiAqIENsb3NlcyB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aGVuIGEgZGlzbWlzc2FsIGlzIHJlcXVlc3RlZCDigJQgYnkgZGVmYXVsdCwgd2hlblxuICogdGhlIHVzZXIgcHJlc3NlcyB0aGUgYGVzY2FwZWAga2V5IG9yIG91dHNpZGUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlRGlzbWlzc1xuICovXG5mdW5jdGlvbiB1c2VEaXNtaXNzKGNvbnRleHQsIHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgbm9kZUlkLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICByZWZlcmVuY2UsXG4gICAgICBkb21SZWZlcmVuY2UsXG4gICAgICBmbG9hdGluZ1xuICAgIH0sXG4gICAgZGF0YVJlZlxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIGVzY2FwZUtleSA9IHRydWUsXG4gICAgb3V0c2lkZVByZXNzOiB1bnN0YWJsZV9vdXRzaWRlUHJlc3MgPSB0cnVlLFxuICAgIG91dHNpZGVQcmVzc0V2ZW50ID0gJ3BvaW50ZXJkb3duJyxcbiAgICByZWZlcmVuY2VQcmVzcyA9IGZhbHNlLFxuICAgIHJlZmVyZW5jZVByZXNzRXZlbnQgPSAncG9pbnRlcmRvd24nLFxuICAgIGFuY2VzdG9yU2Nyb2xsID0gZmFsc2UsXG4gICAgYnViYmxlcyxcbiAgICBjYXB0dXJlXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCBvdXRzaWRlUHJlc3NGbiA9IHVzZUVmZmVjdEV2ZW50KHR5cGVvZiB1bnN0YWJsZV9vdXRzaWRlUHJlc3MgPT09ICdmdW5jdGlvbicgPyB1bnN0YWJsZV9vdXRzaWRlUHJlc3MgOiAoKSA9PiBmYWxzZSk7XG4gIGNvbnN0IG91dHNpZGVQcmVzcyA9IHR5cGVvZiB1bnN0YWJsZV9vdXRzaWRlUHJlc3MgPT09ICdmdW5jdGlvbicgPyBvdXRzaWRlUHJlc3NGbiA6IHVuc3RhYmxlX291dHNpZGVQcmVzcztcbiAgY29uc3QgaW5zaWRlUmVhY3RUcmVlUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgZW5kZWRPclN0YXJ0ZWRJbnNpZGVSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCB7XG4gICAgZXNjYXBlS2V5OiBlc2NhcGVLZXlCdWJibGVzLFxuICAgIG91dHNpZGVQcmVzczogb3V0c2lkZVByZXNzQnViYmxlc1xuICB9ID0gbm9ybWFsaXplUHJvcChidWJibGVzKTtcbiAgY29uc3Qge1xuICAgIGVzY2FwZUtleTogZXNjYXBlS2V5Q2FwdHVyZSxcbiAgICBvdXRzaWRlUHJlc3M6IG91dHNpZGVQcmVzc0NhcHR1cmVcbiAgfSA9IG5vcm1hbGl6ZVByb3AoY2FwdHVyZSk7XG4gIGNvbnN0IGNsb3NlT25Fc2NhcGVLZXlEb3duID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIGlmICghb3BlbiB8fCAhZW5hYmxlZCB8fCAhZXNjYXBlS2V5IHx8IGV2ZW50LmtleSAhPT0gJ0VzY2FwZScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0cmVlID8gZ2V0Q2hpbGRyZW4odHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpIDogW107XG4gICAgaWYgKCFlc2NhcGVLZXlCdWJibGVzKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBzaG91bGREaXNtaXNzID0gdHJ1ZTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgdmFyIF9jaGlsZCRjb250ZXh0O1xuICAgICAgICAgIGlmICgoX2NoaWxkJGNvbnRleHQgPSBjaGlsZC5jb250ZXh0KSAhPSBudWxsICYmIF9jaGlsZCRjb250ZXh0Lm9wZW4gJiYgIWNoaWxkLmNvbnRleHQuZGF0YVJlZi5jdXJyZW50Ll9fZXNjYXBlS2V5QnViYmxlcykge1xuICAgICAgICAgICAgc2hvdWxkRGlzbWlzcyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc2hvdWxkRGlzbWlzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGlzUmVhY3RFdmVudChldmVudCkgPyBldmVudC5uYXRpdmVFdmVudCA6IGV2ZW50LCAnZXNjYXBlLWtleScpO1xuICB9KTtcbiAgY29uc3QgY2xvc2VPbkVzY2FwZUtleURvd25DYXB0dXJlID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIHZhciBfZ2V0VGFyZ2V0MjtcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHZhciBfZ2V0VGFyZ2V0O1xuICAgICAgY2xvc2VPbkVzY2FwZUtleURvd24oZXZlbnQpO1xuICAgICAgKF9nZXRUYXJnZXQgPSBnZXRUYXJnZXQoZXZlbnQpKSA9PSBudWxsIHx8IF9nZXRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIChfZ2V0VGFyZ2V0MiA9IGdldFRhcmdldChldmVudCkpID09IG51bGwgfHwgX2dldFRhcmdldDIuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNhbGxiYWNrKTtcbiAgfSk7XG4gIGNvbnN0IGNsb3NlT25QcmVzc091dHNpZGUgPSB1c2VFZmZlY3RFdmVudChldmVudCA9PiB7XG4gICAgLy8gR2l2ZW4gZGV2ZWxvcGVycyBjYW4gc3RvcCB0aGUgcHJvcGFnYXRpb24gb2YgdGhlIHN5bnRoZXRpYyBldmVudCxcbiAgICAvLyB3ZSBjYW4gb25seSBiZSBjb25maWRlbnQgd2l0aCBhIHBvc2l0aXZlIHZhbHVlLlxuICAgIGNvbnN0IGluc2lkZVJlYWN0VHJlZSA9IGluc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50O1xuICAgIGluc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50ID0gZmFsc2U7XG5cbiAgICAvLyBXaGVuIGNsaWNrIG91dHNpZGUgaXMgbGF6eSAoYGNsaWNrYCBldmVudCksIGhhbmRsZSBkcmFnZ2luZy5cbiAgICAvLyBEb24ndCBjbG9zZSBpZjpcbiAgICAvLyAtIFRoZSBjbGljayBzdGFydGVkIGluc2lkZSB0aGUgZmxvYXRpbmcgZWxlbWVudC5cbiAgICAvLyAtIFRoZSBjbGljayBlbmRlZCBpbnNpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gICAgY29uc3QgZW5kZWRPclN0YXJ0ZWRJbnNpZGUgPSBlbmRlZE9yU3RhcnRlZEluc2lkZVJlZi5jdXJyZW50O1xuICAgIGVuZGVkT3JTdGFydGVkSW5zaWRlUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICBpZiAob3V0c2lkZVByZXNzRXZlbnQgPT09ICdjbGljaycgJiYgZW5kZWRPclN0YXJ0ZWRJbnNpZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGluc2lkZVJlYWN0VHJlZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG91dHNpZGVQcmVzcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhb3V0c2lkZVByZXNzKGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQoZXZlbnQpO1xuICAgIGNvbnN0IGluZXJ0U2VsZWN0b3IgPSBcIltcIiArIGNyZWF0ZUF0dHJpYnV0ZSgnaW5lcnQnKSArIFwiXVwiO1xuICAgIGNvbnN0IG1hcmtlcnMgPSBnZXREb2N1bWVudChmbG9hdGluZykucXVlcnlTZWxlY3RvckFsbChpbmVydFNlbGVjdG9yKTtcbiAgICBsZXQgdGFyZ2V0Um9vdEFuY2VzdG9yID0gaXNFbGVtZW50KHRhcmdldCkgPyB0YXJnZXQgOiBudWxsO1xuICAgIHdoaWxlICh0YXJnZXRSb290QW5jZXN0b3IgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZSh0YXJnZXRSb290QW5jZXN0b3IpKSB7XG4gICAgICBjb25zdCBuZXh0UGFyZW50ID0gZ2V0UGFyZW50Tm9kZSh0YXJnZXRSb290QW5jZXN0b3IpO1xuICAgICAgaWYgKGlzTGFzdFRyYXZlcnNhYmxlTm9kZShuZXh0UGFyZW50KSB8fCAhaXNFbGVtZW50KG5leHRQYXJlbnQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGFyZ2V0Um9vdEFuY2VzdG9yID0gbmV4dFBhcmVudDtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgY2xpY2sgb2NjdXJyZWQgb24gYSB0aGlyZC1wYXJ0eSBlbGVtZW50IGluamVjdGVkIGFmdGVyIHRoZVxuICAgIC8vIGZsb2F0aW5nIGVsZW1lbnQgcmVuZGVyZWQuXG4gICAgaWYgKG1hcmtlcnMubGVuZ3RoICYmIGlzRWxlbWVudCh0YXJnZXQpICYmICFpc1Jvb3RFbGVtZW50KHRhcmdldCkgJiZcbiAgICAvLyBDbGlja2VkIG9uIGEgZGlyZWN0IGFuY2VzdG9yIChlLmcuIEZsb2F0aW5nT3ZlcmxheSkuXG4gICAgIWNvbnRhaW5zKHRhcmdldCwgZmxvYXRpbmcpICYmXG4gICAgLy8gSWYgdGhlIHRhcmdldCByb290IGVsZW1lbnQgY29udGFpbnMgbm9uZSBvZiB0aGUgbWFya2VycywgdGhlbiB0aGVcbiAgICAvLyBlbGVtZW50IHdhcyBpbmplY3RlZCBhZnRlciB0aGUgZmxvYXRpbmcgZWxlbWVudCByZW5kZXJlZC5cbiAgICBBcnJheS5mcm9tKG1hcmtlcnMpLmV2ZXJ5KG1hcmtlciA9PiAhY29udGFpbnModGFyZ2V0Um9vdEFuY2VzdG9yLCBtYXJrZXIpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZSBjbGljayBvY2N1cnJlZCBvbiB0aGUgc2Nyb2xsYmFyXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQodGFyZ2V0KSAmJiBmbG9hdGluZykge1xuICAgICAgLy8gSW4gRmlyZWZveCwgYHRhcmdldC5zY3JvbGxXaWR0aCA+IHRhcmdldC5jbGllbnRXaWR0aGAgZm9yIGlubGluZVxuICAgICAgLy8gZWxlbWVudHMuXG4gICAgICBjb25zdCBjYW5TY3JvbGxYID0gdGFyZ2V0LmNsaWVudFdpZHRoID4gMCAmJiB0YXJnZXQuc2Nyb2xsV2lkdGggPiB0YXJnZXQuY2xpZW50V2lkdGg7XG4gICAgICBjb25zdCBjYW5TY3JvbGxZID0gdGFyZ2V0LmNsaWVudEhlaWdodCA+IDAgJiYgdGFyZ2V0LnNjcm9sbEhlaWdodCA+IHRhcmdldC5jbGllbnRIZWlnaHQ7XG4gICAgICBsZXQgeENvbmQgPSBjYW5TY3JvbGxZICYmIGV2ZW50Lm9mZnNldFggPiB0YXJnZXQuY2xpZW50V2lkdGg7XG5cbiAgICAgIC8vIEluIHNvbWUgYnJvd3NlcnMgaXQgaXMgcG9zc2libGUgdG8gY2hhbmdlIHRoZSA8Ym9keT4gKG9yIHdpbmRvdylcbiAgICAgIC8vIHNjcm9sbGJhciB0byB0aGUgbGVmdCBzaWRlLCBidXQgaXMgdmVyeSByYXJlIGFuZCBpcyBkaWZmaWN1bHQgdG9cbiAgICAgIC8vIGNoZWNrIGZvci4gUGx1cywgZm9yIG1vZGFsIGRpYWxvZ3Mgd2l0aCBiYWNrZHJvcHMsIGl0IGlzIG1vcmVcbiAgICAgIC8vIGltcG9ydGFudCB0aGF0IHRoZSBiYWNrZHJvcCBpcyBjaGVja2VkIGJ1dCBub3Qgc28gbXVjaCB0aGUgd2luZG93LlxuICAgICAgaWYgKGNhblNjcm9sbFkpIHtcbiAgICAgICAgY29uc3QgaXNSVEwgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCkuZGlyZWN0aW9uID09PSAncnRsJztcbiAgICAgICAgaWYgKGlzUlRMKSB7XG4gICAgICAgICAgeENvbmQgPSBldmVudC5vZmZzZXRYIDw9IHRhcmdldC5vZmZzZXRXaWR0aCAtIHRhcmdldC5jbGllbnRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHhDb25kIHx8IGNhblNjcm9sbFggJiYgZXZlbnQub2Zmc2V0WSA+IHRhcmdldC5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0YXJnZXRJc0luc2lkZUNoaWxkcmVuID0gdHJlZSAmJiBnZXRDaGlsZHJlbih0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVJZCkuc29tZShub2RlID0+IHtcbiAgICAgIHZhciBfbm9kZSRjb250ZXh0O1xuICAgICAgcmV0dXJuIGlzRXZlbnRUYXJnZXRXaXRoaW4oZXZlbnQsIChfbm9kZSRjb250ZXh0ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dC5lbGVtZW50cy5mbG9hdGluZyk7XG4gICAgfSk7XG4gICAgaWYgKGlzRXZlbnRUYXJnZXRXaXRoaW4oZXZlbnQsIGZsb2F0aW5nKSB8fCBpc0V2ZW50VGFyZ2V0V2l0aGluKGV2ZW50LCBkb21SZWZlcmVuY2UpIHx8IHRhcmdldElzSW5zaWRlQ2hpbGRyZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0cmVlID8gZ2V0Q2hpbGRyZW4odHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpIDogW107XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGxldCBzaG91bGREaXNtaXNzID0gdHJ1ZTtcbiAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICB2YXIgX2NoaWxkJGNvbnRleHQyO1xuICAgICAgICBpZiAoKF9jaGlsZCRjb250ZXh0MiA9IGNoaWxkLmNvbnRleHQpICE9IG51bGwgJiYgX2NoaWxkJGNvbnRleHQyLm9wZW4gJiYgIWNoaWxkLmNvbnRleHQuZGF0YVJlZi5jdXJyZW50Ll9fb3V0c2lkZVByZXNzQnViYmxlcykge1xuICAgICAgICAgIHNob3VsZERpc21pc3MgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFzaG91bGREaXNtaXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCwgJ291dHNpZGUtcHJlc3MnKTtcbiAgfSk7XG4gIGNvbnN0IGNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIHZhciBfZ2V0VGFyZ2V0NDtcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHZhciBfZ2V0VGFyZ2V0MztcbiAgICAgIGNsb3NlT25QcmVzc091dHNpZGUoZXZlbnQpO1xuICAgICAgKF9nZXRUYXJnZXQzID0gZ2V0VGFyZ2V0KGV2ZW50KSkgPT0gbnVsbCB8fCBfZ2V0VGFyZ2V0My5yZW1vdmVFdmVudExpc3RlbmVyKG91dHNpZGVQcmVzc0V2ZW50LCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAoX2dldFRhcmdldDQgPSBnZXRUYXJnZXQoZXZlbnQpKSA9PSBudWxsIHx8IF9nZXRUYXJnZXQ0LmFkZEV2ZW50TGlzdGVuZXIob3V0c2lkZVByZXNzRXZlbnQsIGNhbGxiYWNrKTtcbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFvcGVuIHx8ICFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRhdGFSZWYuY3VycmVudC5fX2VzY2FwZUtleUJ1YmJsZXMgPSBlc2NhcGVLZXlCdWJibGVzO1xuICAgIGRhdGFSZWYuY3VycmVudC5fX291dHNpZGVQcmVzc0J1YmJsZXMgPSBvdXRzaWRlUHJlc3NCdWJibGVzO1xuICAgIGZ1bmN0aW9uIG9uU2Nyb2xsKGV2ZW50KSB7XG4gICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50LCAnYW5jZXN0b3Itc2Nyb2xsJyk7XG4gICAgfVxuICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KGZsb2F0aW5nKTtcbiAgICBlc2NhcGVLZXkgJiYgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBlc2NhcGVLZXlDYXB0dXJlID8gY2xvc2VPbkVzY2FwZUtleURvd25DYXB0dXJlIDogY2xvc2VPbkVzY2FwZUtleURvd24sIGVzY2FwZUtleUNhcHR1cmUpO1xuICAgIG91dHNpZGVQcmVzcyAmJiBkb2MuYWRkRXZlbnRMaXN0ZW5lcihvdXRzaWRlUHJlc3NFdmVudCwgb3V0c2lkZVByZXNzQ2FwdHVyZSA/IGNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlIDogY2xvc2VPblByZXNzT3V0c2lkZSwgb3V0c2lkZVByZXNzQ2FwdHVyZSk7XG4gICAgbGV0IGFuY2VzdG9ycyA9IFtdO1xuICAgIGlmIChhbmNlc3RvclNjcm9sbCkge1xuICAgICAgaWYgKGlzRWxlbWVudChkb21SZWZlcmVuY2UpKSB7XG4gICAgICAgIGFuY2VzdG9ycyA9IGdldE92ZXJmbG93QW5jZXN0b3JzKGRvbVJlZmVyZW5jZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNFbGVtZW50KGZsb2F0aW5nKSkge1xuICAgICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuY29uY2F0KGdldE92ZXJmbG93QW5jZXN0b3JzKGZsb2F0aW5nKSk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzRWxlbWVudChyZWZlcmVuY2UpICYmIHJlZmVyZW5jZSAmJiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIHtcbiAgICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLmNvbmNhdChnZXRPdmVyZmxvd0FuY2VzdG9ycyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZ25vcmUgdGhlIHZpc3VhbCB2aWV3cG9ydCBmb3Igc2Nyb2xsaW5nIGRpc21pc3NhbCAoYWxsb3cgcGluY2gtem9vbSlcbiAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuZmlsdGVyKGFuY2VzdG9yID0+IHtcbiAgICAgIHZhciBfZG9jJGRlZmF1bHRWaWV3O1xuICAgICAgcmV0dXJuIGFuY2VzdG9yICE9PSAoKF9kb2MkZGVmYXVsdFZpZXcgPSBkb2MuZGVmYXVsdFZpZXcpID09IG51bGwgPyB2b2lkIDAgOiBfZG9jJGRlZmF1bHRWaWV3LnZpc3VhbFZpZXdwb3J0KTtcbiAgICB9KTtcbiAgICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgICBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbCwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZXNjYXBlS2V5ICYmIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZXNjYXBlS2V5Q2FwdHVyZSA/IGNsb3NlT25Fc2NhcGVLZXlEb3duQ2FwdHVyZSA6IGNsb3NlT25Fc2NhcGVLZXlEb3duLCBlc2NhcGVLZXlDYXB0dXJlKTtcbiAgICAgIG91dHNpZGVQcmVzcyAmJiBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihvdXRzaWRlUHJlc3NFdmVudCwgb3V0c2lkZVByZXNzQ2FwdHVyZSA/IGNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlIDogY2xvc2VPblByZXNzT3V0c2lkZSwgb3V0c2lkZVByZXNzQ2FwdHVyZSk7XG4gICAgICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgICAgIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uU2Nyb2xsKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sIFtkYXRhUmVmLCBmbG9hdGluZywgZG9tUmVmZXJlbmNlLCByZWZlcmVuY2UsIGVzY2FwZUtleSwgb3V0c2lkZVByZXNzLCBvdXRzaWRlUHJlc3NFdmVudCwgb3Blbiwgb25PcGVuQ2hhbmdlLCBhbmNlc3RvclNjcm9sbCwgZW5hYmxlZCwgZXNjYXBlS2V5QnViYmxlcywgb3V0c2lkZVByZXNzQnViYmxlcywgY2xvc2VPbkVzY2FwZUtleURvd24sIGVzY2FwZUtleUNhcHR1cmUsIGNsb3NlT25Fc2NhcGVLZXlEb3duQ2FwdHVyZSwgY2xvc2VPblByZXNzT3V0c2lkZSwgb3V0c2lkZVByZXNzQ2FwdHVyZSwgY2xvc2VPblByZXNzT3V0c2lkZUNhcHR1cmVdKTtcblxuICAvLyBiaW9tZS1pZ25vcmUgbGludC9jb3JyZWN0bmVzcy91c2VFeGhhdXN0aXZlRGVwZW5kZW5jaWVzOiBpbnRlbnRpb25hbFxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGluc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gIH0sIFtvdXRzaWRlUHJlc3MsIG91dHNpZGVQcmVzc0V2ZW50XSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICBvbktleURvd246IGNsb3NlT25Fc2NhcGVLZXlEb3duLFxuICAgICAgICBbYnViYmxlSGFuZGxlcktleXNbcmVmZXJlbmNlUHJlc3NFdmVudF1dOiBldmVudCA9PiB7XG4gICAgICAgICAgaWYgKHJlZmVyZW5jZVByZXNzKSB7XG4gICAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAncmVmZXJlbmNlLXByZXNzJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZmxvYXRpbmc6IHtcbiAgICAgICAgb25LZXlEb3duOiBjbG9zZU9uRXNjYXBlS2V5RG93bixcbiAgICAgICAgb25Nb3VzZURvd24oKSB7XG4gICAgICAgICAgZW5kZWRPclN0YXJ0ZWRJbnNpZGVSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VVcCgpIHtcbiAgICAgICAgICBlbmRlZE9yU3RhcnRlZEluc2lkZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgW2NhcHR1cmVIYW5kbGVyS2V5c1tvdXRzaWRlUHJlc3NFdmVudF1dOiAoKSA9PiB7XG4gICAgICAgICAgaW5zaWRlUmVhY3RUcmVlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIHJlZmVyZW5jZVByZXNzLCBvdXRzaWRlUHJlc3NFdmVudCwgcmVmZXJlbmNlUHJlc3NFdmVudCwgb25PcGVuQ2hhbmdlLCBjbG9zZU9uRXNjYXBlS2V5RG93bl0pO1xufVxuXG5sZXQgZGV2TWVzc2FnZVNldDtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgZGV2TWVzc2FnZVNldCA9IC8qI19fUFVSRV9fKi9uZXcgU2V0KCk7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhIGZsb2F0aW5nIGVsZW1lbnQgYW5kIGNvbnRleHQgdG8gYWRkIGludGVyYWN0aW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VGbG9hdGluZ1xuICovXG5mdW5jdGlvbiB1c2VGbG9hdGluZyhvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRlbGVtZW50czI7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4gPSBmYWxzZSxcbiAgICBvbk9wZW5DaGFuZ2U6IHVuc3RhYmxlX29uT3BlbkNoYW5nZSxcbiAgICBub2RlSWRcbiAgfSA9IG9wdGlvbnM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YXIgX29wdGlvbnMkZWxlbWVudHM7XG4gICAgY29uc3QgZXJyID0gJ0Zsb2F0aW5nIFVJOiBDYW5ub3QgcGFzcyBhIHZpcnR1YWwgZWxlbWVudCB0byB0aGUgJyArICdgZWxlbWVudHMucmVmZXJlbmNlYCBvcHRpb24sIGFzIGl0IG11c3QgYmUgYSByZWFsIERPTSBlbGVtZW50LiAnICsgJ1VzZSBgcmVmcy5zZXRQb3NpdGlvblJlZmVyZW5jZWAgaW5zdGVhZC4nO1xuICAgIGlmICgoX29wdGlvbnMkZWxlbWVudHMgPSBvcHRpb25zLmVsZW1lbnRzKSAhPSBudWxsICYmIF9vcHRpb25zJGVsZW1lbnRzLnJlZmVyZW5jZSAmJiAhaXNFbGVtZW50KG9wdGlvbnMuZWxlbWVudHMucmVmZXJlbmNlKSkge1xuICAgICAgdmFyIF9kZXZNZXNzYWdlU2V0O1xuICAgICAgaWYgKCEoKF9kZXZNZXNzYWdlU2V0ID0gZGV2TWVzc2FnZVNldCkgIT0gbnVsbCAmJiBfZGV2TWVzc2FnZVNldC5oYXMoZXJyKSkpIHtcbiAgICAgICAgdmFyIF9kZXZNZXNzYWdlU2V0MjtcbiAgICAgICAgKF9kZXZNZXNzYWdlU2V0MiA9IGRldk1lc3NhZ2VTZXQpID09IG51bGwgfHwgX2Rldk1lc3NhZ2VTZXQyLmFkZChlcnIpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IFtfZG9tUmVmZXJlbmNlLCBzZXREb21SZWZlcmVuY2VdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IGRvbVJlZmVyZW5jZSA9ICgoX29wdGlvbnMkZWxlbWVudHMyID0gb3B0aW9ucy5lbGVtZW50cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9vcHRpb25zJGVsZW1lbnRzMi5yZWZlcmVuY2UpIHx8IF9kb21SZWZlcmVuY2U7XG4gIGNvbnN0IHBvc2l0aW9uID0gdXNlRmxvYXRpbmckMShvcHRpb25zKTtcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCBuZXN0ZWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpICE9IG51bGw7XG4gIGNvbnN0IG9uT3BlbkNoYW5nZSA9IHVzZUVmZmVjdEV2ZW50KChvcGVuLCBldmVudCwgcmVhc29uKSA9PiB7XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQgPSBldmVudDtcbiAgICB9XG4gICAgZXZlbnRzLmVtaXQoJ29wZW5jaGFuZ2UnLCB7XG4gICAgICBvcGVuLFxuICAgICAgZXZlbnQsXG4gICAgICByZWFzb24sXG4gICAgICBuZXN0ZWRcbiAgICB9KTtcbiAgICB1bnN0YWJsZV9vbk9wZW5DaGFuZ2UgPT0gbnVsbCB8fCB1bnN0YWJsZV9vbk9wZW5DaGFuZ2Uob3BlbiwgZXZlbnQsIHJlYXNvbik7XG4gIH0pO1xuICBjb25zdCBkb21SZWZlcmVuY2VSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGRhdGFSZWYgPSBSZWFjdC51c2VSZWYoe30pO1xuICBjb25zdCBldmVudHMgPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBjcmVhdGVQdWJTdWIoKSlbMF07XG4gIGNvbnN0IGZsb2F0aW5nSWQgPSB1c2VJZCgpO1xuICBjb25zdCBzZXRQb3NpdGlvblJlZmVyZW5jZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9uUmVmZXJlbmNlID0gaXNFbGVtZW50KG5vZGUpID8ge1xuICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiAoKSA9PiBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgY29udGV4dEVsZW1lbnQ6IG5vZGVcbiAgICB9IDogbm9kZTtcbiAgICBwb3NpdGlvbi5yZWZzLnNldFJlZmVyZW5jZShwb3NpdGlvblJlZmVyZW5jZSk7XG4gIH0sIFtwb3NpdGlvbi5yZWZzXSk7XG4gIGNvbnN0IHNldFJlZmVyZW5jZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGlmIChpc0VsZW1lbnQobm9kZSkgfHwgbm9kZSA9PT0gbnVsbCkge1xuICAgICAgZG9tUmVmZXJlbmNlUmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgc2V0RG9tUmVmZXJlbmNlKG5vZGUpO1xuICAgIH1cblxuICAgIC8vIEJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciBwYXNzaW5nIGEgdmlydHVhbCBlbGVtZW50IHRvIGByZWZlcmVuY2VgXG4gICAgLy8gYWZ0ZXIgaXQgaGFzIHNldCB0aGUgRE9NIHJlZmVyZW5jZS5cbiAgICBpZiAoaXNFbGVtZW50KHBvc2l0aW9uLnJlZnMucmVmZXJlbmNlLmN1cnJlbnQpIHx8IHBvc2l0aW9uLnJlZnMucmVmZXJlbmNlLmN1cnJlbnQgPT09IG51bGwgfHxcbiAgICAvLyBEb24ndCBhbGxvdyBzZXR0aW5nIHZpcnR1YWwgZWxlbWVudHMgdXNpbmcgdGhlIG9sZCB0ZWNobmlxdWUgYmFjayB0b1xuICAgIC8vIGBudWxsYCB0byBzdXBwb3J0IGBwb3NpdGlvblJlZmVyZW5jZWAgKyBhbiB1bnN0YWJsZSBgcmVmZXJlbmNlYFxuICAgIC8vIGNhbGxiYWNrIHJlZi5cbiAgICBub2RlICE9PSBudWxsICYmICFpc0VsZW1lbnQobm9kZSkpIHtcbiAgICAgIHBvc2l0aW9uLnJlZnMuc2V0UmVmZXJlbmNlKG5vZGUpO1xuICAgIH1cbiAgfSwgW3Bvc2l0aW9uLnJlZnNdKTtcbiAgY29uc3QgcmVmcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5wb3NpdGlvbi5yZWZzLFxuICAgIHNldFJlZmVyZW5jZSxcbiAgICBzZXRQb3NpdGlvblJlZmVyZW5jZSxcbiAgICBkb21SZWZlcmVuY2U6IGRvbVJlZmVyZW5jZVJlZlxuICB9KSwgW3Bvc2l0aW9uLnJlZnMsIHNldFJlZmVyZW5jZSwgc2V0UG9zaXRpb25SZWZlcmVuY2VdKTtcbiAgY29uc3QgZWxlbWVudHMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgLi4ucG9zaXRpb24uZWxlbWVudHMsXG4gICAgZG9tUmVmZXJlbmNlOiBkb21SZWZlcmVuY2VcbiAgfSksIFtwb3NpdGlvbi5lbGVtZW50cywgZG9tUmVmZXJlbmNlXSk7XG4gIGNvbnN0IGNvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgLi4ucG9zaXRpb24sXG4gICAgcmVmcyxcbiAgICBlbGVtZW50cyxcbiAgICBkYXRhUmVmLFxuICAgIG5vZGVJZCxcbiAgICBmbG9hdGluZ0lkLFxuICAgIGV2ZW50cyxcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZVxuICB9KSwgW3Bvc2l0aW9uLCBub2RlSWQsIGZsb2F0aW5nSWQsIGV2ZW50cywgb3Blbiwgb25PcGVuQ2hhbmdlLCByZWZzLCBlbGVtZW50c10pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IHRyZWUgPT0gbnVsbCA/IHZvaWQgMCA6IHRyZWUubm9kZXNSZWYuY3VycmVudC5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gbm9kZUlkKTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZS5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLnBvc2l0aW9uLFxuICAgIGNvbnRleHQsXG4gICAgcmVmcyxcbiAgICBlbGVtZW50c1xuICB9KSwgW3Bvc2l0aW9uLCByZWZzLCBlbGVtZW50cywgY29udGV4dF0pO1xufVxuXG4vKipcbiAqIE9wZW5zIHRoZSBmbG9hdGluZyBlbGVtZW50IHdoaWxlIHRoZSByZWZlcmVuY2UgZWxlbWVudCBoYXMgZm9jdXMsIGxpa2UgQ1NTXG4gKiBgOmZvY3VzYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VGb2N1c1xuICovXG5mdW5jdGlvbiB1c2VGb2N1cyhjb250ZXh0LCBwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGV2ZW50cyxcbiAgICByZWZzLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBkb21SZWZlcmVuY2VcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgdmlzaWJsZU9ubHkgPSB0cnVlXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgYmxvY2tGb2N1c1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHRpbWVvdXRSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3Qga2V5Ym9hcmRNb2RhbGl0eVJlZiA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgd2luID0gZ2V0V2luZG93KGRvbVJlZmVyZW5jZSk7XG5cbiAgICAvLyBJZiB0aGUgcmVmZXJlbmNlIHdhcyBmb2N1c2VkIGFuZCB0aGUgdXNlciBsZWZ0IHRoZSB0YWIvd2luZG93LCBhbmQgdGhlXG4gICAgLy8gZmxvYXRpbmcgZWxlbWVudCB3YXMgbm90IG9wZW4sIHRoZSBmb2N1cyBzaG91bGQgYmUgYmxvY2tlZCB3aGVuIHRoZXlcbiAgICAvLyByZXR1cm4gdG8gdGhlIHRhYi93aW5kb3cuXG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgaWYgKCFvcGVuICYmIGlzSFRNTEVsZW1lbnQoZG9tUmVmZXJlbmNlKSAmJiBkb21SZWZlcmVuY2UgPT09IGFjdGl2ZUVsZW1lbnQoZ2V0RG9jdW1lbnQoZG9tUmVmZXJlbmNlKSkpIHtcbiAgICAgICAgYmxvY2tGb2N1c1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25LZXlEb3duKCkge1xuICAgICAga2V5Ym9hcmRNb2RhbGl0eVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBvbkJsdXIpO1xuICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25LZXlEb3duLCB0cnVlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBvbkJsdXIpO1xuICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24sIHRydWUpO1xuICAgIH07XG4gIH0sIFtkb21SZWZlcmVuY2UsIG9wZW4sIGVuYWJsZWRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25PcGVuQ2hhbmdlKF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHJlYXNvblxuICAgICAgfSA9IF9yZWY7XG4gICAgICBpZiAocmVhc29uID09PSAncmVmZXJlbmNlLXByZXNzJyB8fCByZWFzb24gPT09ICdlc2NhcGUta2V5Jykge1xuICAgICAgICBibG9ja0ZvY3VzUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBldmVudHMub24oJ29wZW5jaGFuZ2UnLCBvbk9wZW5DaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBldmVudHMub2ZmKCdvcGVuY2hhbmdlJywgb25PcGVuQ2hhbmdlKTtcbiAgICB9O1xuICB9LCBbZXZlbnRzLCBlbmFibGVkXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgIG9uUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICAgICAgICBpZiAoaXNWaXJ0dWFsUG9pbnRlckV2ZW50KGV2ZW50Lm5hdGl2ZUV2ZW50KSkgcmV0dXJuO1xuICAgICAgICAgIGtleWJvYXJkTW9kYWxpdHlSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlTGVhdmUoKSB7XG4gICAgICAgICAgYmxvY2tGb2N1c1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRm9jdXMoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoYmxvY2tGb2N1c1JlZi5jdXJyZW50KSByZXR1cm47XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGV2ZW50Lm5hdGl2ZUV2ZW50KTtcbiAgICAgICAgICBpZiAodmlzaWJsZU9ubHkgJiYgaXNFbGVtZW50KHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIE1hYyBTYWZhcmkgdW5yZWxpYWJseSBtYXRjaGVzIGA6Zm9jdXMtdmlzaWJsZWAgb24gdGhlIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAvLyBpZiBmb2N1cyB3YXMgb3V0c2lkZSB0aGUgcGFnZSBpbml0aWFsbHkgLSB1c2UgdGhlIGZhbGxiYWNrXG4gICAgICAgICAgICAgIC8vIGluc3RlYWQuXG4gICAgICAgICAgICAgIGlmIChpc1NhZmFyaSgpICYmIGlzTWFjKCkpIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgIGlmICghdGFyZ2V0Lm1hdGNoZXMoJzpmb2N1cy12aXNpYmxlJykpIHJldHVybjtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgLy8gT2xkIGJyb3dzZXJzIHdpbGwgdGhyb3cgYW4gZXJyb3Igd2hlbiB1c2luZyBgOmZvY3VzLXZpc2libGVgLlxuICAgICAgICAgICAgICBpZiAoIWtleWJvYXJkTW9kYWxpdHlSZWYuY3VycmVudCAmJiAhaXNUeXBlYWJsZUVsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQubmF0aXZlRXZlbnQsICdmb2N1cycpO1xuICAgICAgICB9LFxuICAgICAgICBvbkJsdXIoZXZlbnQpIHtcbiAgICAgICAgICBibG9ja0ZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcblxuICAgICAgICAgIC8vIEhpdCB0aGUgbm9uLW1vZGFsIGZvY3VzIG1hbmFnZW1lbnQgcG9ydGFsIGd1YXJkLiBGb2N1cyB3aWxsIGJlXG4gICAgICAgICAgLy8gbW92ZWQgaW50byB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbW1lZGlhdGVseSBhZnRlci5cbiAgICAgICAgICBjb25zdCBtb3ZlZFRvRm9jdXNHdWFyZCA9IGlzRWxlbWVudChyZWxhdGVkVGFyZ2V0KSAmJiByZWxhdGVkVGFyZ2V0Lmhhc0F0dHJpYnV0ZShjcmVhdGVBdHRyaWJ1dGUoJ2ZvY3VzLWd1YXJkJykpICYmIHJlbGF0ZWRUYXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXR5cGUnKSA9PT0gJ291dHNpZGUnO1xuXG4gICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIHdpbmRvdyBibHVyIGxpc3RlbmVyIHRvIGZpcmUuXG4gICAgICAgICAgdGltZW91dFJlZi5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlRWwgPSBhY3RpdmVFbGVtZW50KGRvbVJlZmVyZW5jZSA/IGRvbVJlZmVyZW5jZS5vd25lckRvY3VtZW50IDogZG9jdW1lbnQpO1xuXG4gICAgICAgICAgICAvLyBGb2N1cyBsZWZ0IHRoZSBwYWdlLCBrZWVwIGl0IG9wZW4uXG4gICAgICAgICAgICBpZiAoIXJlbGF0ZWRUYXJnZXQgJiYgYWN0aXZlRWwgPT09IGRvbVJlZmVyZW5jZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBXaGVuIGZvY3VzaW5nIHRoZSByZWZlcmVuY2UgZWxlbWVudCAoZS5nLiByZWd1bGFyIGNsaWNrKSwgdGhlblxuICAgICAgICAgICAgLy8gY2xpY2tpbmcgaW50byB0aGUgZmxvYXRpbmcgZWxlbWVudCwgcHJldmVudCBpdCBmcm9tIGhpZGluZy5cbiAgICAgICAgICAgIC8vIE5vdGU6IGl0IG11c3QgYmUgZm9jdXNhYmxlLCBlLmcuIGB0YWJpbmRleD1cIi0xXCJgLlxuICAgICAgICAgICAgLy8gV2UgY2FuIG5vdCByZWx5IG9uIHJlbGF0ZWRUYXJnZXQgdG8gcG9pbnQgdG8gdGhlIGNvcnJlY3QgZWxlbWVudFxuICAgICAgICAgICAgLy8gYXMgaXQgd2lsbCBvbmx5IHBvaW50IHRvIHRoZSBzaGFkb3cgaG9zdCBvZiB0aGUgbmV3bHkgZm9jdXNlZCBlbGVtZW50XG4gICAgICAgICAgICAvLyBhbmQgbm90IHRoZSBlbGVtZW50IHRoYXQgYWN0dWFsbHkgaGFzIHJlY2VpdmVkIGZvY3VzIGlmIGl0IGlzIGxvY2F0ZWRcbiAgICAgICAgICAgIC8vIGluc2lkZSBhIHNoYWRvdyByb290LlxuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKHJlZnMuZmxvYXRpbmcuY3VycmVudCwgYWN0aXZlRWwpIHx8IGNvbnRhaW5zKGRvbVJlZmVyZW5jZSwgYWN0aXZlRWwpIHx8IG1vdmVkVG9Gb2N1c0d1YXJkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQsICdmb2N1cycpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIHZpc2libGVPbmx5LCBkb21SZWZlcmVuY2UsIHJlZnMsIG9uT3BlbkNoYW5nZV0pO1xufVxuXG5jb25zdCBBQ1RJVkVfS0VZID0gJ2FjdGl2ZSc7XG5jb25zdCBTRUxFQ1RFRF9LRVkgPSAnc2VsZWN0ZWQnO1xuZnVuY3Rpb24gbWVyZ2VQcm9wcyh1c2VyUHJvcHMsIHByb3BzTGlzdCwgZWxlbWVudEtleSkge1xuICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IGlzSXRlbSA9IGVsZW1lbnRLZXkgPT09ICdpdGVtJztcbiAgbGV0IGRvbVVzZXJQcm9wcyA9IHVzZXJQcm9wcztcbiAgaWYgKGlzSXRlbSAmJiB1c2VyUHJvcHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBbQUNUSVZFX0tFWV06IF8sXG4gICAgICBbU0VMRUNURURfS0VZXTogX18sXG4gICAgICAuLi52YWxpZFByb3BzXG4gICAgfSA9IHVzZXJQcm9wcztcbiAgICBkb21Vc2VyUHJvcHMgPSB2YWxpZFByb3BzO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uKGVsZW1lbnRLZXkgPT09ICdmbG9hdGluZycgJiYge1xuICAgICAgdGFiSW5kZXg6IC0xXG4gICAgfSksXG4gICAgLi4uZG9tVXNlclByb3BzLFxuICAgIC4uLnByb3BzTGlzdC5tYXAodmFsdWUgPT4ge1xuICAgICAgY29uc3QgcHJvcHNPckdldFByb3BzID0gdmFsdWUgPyB2YWx1ZVtlbGVtZW50S2V5XSA6IG51bGw7XG4gICAgICBpZiAodHlwZW9mIHByb3BzT3JHZXRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdXNlclByb3BzID8gcHJvcHNPckdldFByb3BzKHVzZXJQcm9wcykgOiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BzT3JHZXRQcm9wcztcbiAgICB9KS5jb25jYXQodXNlclByb3BzKS5yZWR1Y2UoKGFjYywgcHJvcHMpID0+IHtcbiAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIE9iamVjdC5lbnRyaWVzKHByb3BzKS5mb3JFYWNoKF9yZWYgPT4ge1xuICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjtcbiAgICAgICAgaWYgKGlzSXRlbSAmJiBbQUNUSVZFX0tFWSwgU0VMRUNURURfS0VZXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkuaW5kZXhPZignb24nKSA9PT0gMCkge1xuICAgICAgICAgIGlmICghbWFwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBtYXAuc2V0KGtleSwgW10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgX21hcCRnZXQ7XG4gICAgICAgICAgICAoX21hcCRnZXQgPSBtYXAuZ2V0KGtleSkpID09IG51bGwgfHwgX21hcCRnZXQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIF9tYXAkZ2V0MjtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gKF9tYXAkZ2V0MiA9IG1hcC5nZXQoa2V5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYXAkZ2V0Mi5tYXAoZm4gPT4gZm4oLi4uYXJncykpLmZpbmQodmFsID0+IHZhbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSlcbiAgfTtcbn1cblxuLyoqXG4gKiBNZXJnZXMgYW4gYXJyYXkgb2YgaW50ZXJhY3Rpb24gaG9va3MnIHByb3BzIGludG8gcHJvcCBnZXR0ZXJzLCBhbGxvd2luZ1xuICogZXZlbnQgaGFuZGxlciBmdW5jdGlvbnMgdG8gYmUgY29tcG9zZWQgdG9nZXRoZXIgd2l0aG91dCBvdmVyd3JpdGluZyBvbmVcbiAqIGFub3RoZXIuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlSW50ZXJhY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIHVzZUludGVyYWN0aW9ucyhwcm9wc0xpc3QpIHtcbiAgaWYgKHByb3BzTGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHNMaXN0ID0gW107XG4gIH1cbiAgLy8gVGhlIGRlcGVuZGVuY2llcyBhcmUgYSBkeW5hbWljIGFycmF5LCBzbyB3ZSBjYW4ndCB1c2UgdGhlIGxpbnRlcidzXG4gIC8vIHN1Z2dlc3Rpb24gdG8gYWRkIGl0IHRvIHRoZSBkZXBzIGFycmF5LlxuICBjb25zdCBkZXBzID0gcHJvcHNMaXN0O1xuXG4gIC8vIGJpb21lLWlnbm9yZSBsaW50L2NvcnJlY3RuZXNzL3VzZUV4aGF1c3RpdmVEZXBlbmRlbmNpZXM6IGludGVudGlvbmFsXG4gIGNvbnN0IGdldFJlZmVyZW5jZVByb3BzID0gUmVhY3QudXNlQ2FsbGJhY2sodXNlclByb3BzID0+IG1lcmdlUHJvcHModXNlclByb3BzLCBwcm9wc0xpc3QsICdyZWZlcmVuY2UnKSwgZGVwcyk7XG5cbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvY29ycmVjdG5lc3MvdXNlRXhoYXVzdGl2ZURlcGVuZGVuY2llczogaW50ZW50aW9uYWxcbiAgY29uc3QgZ2V0RmxvYXRpbmdQcm9wcyA9IFJlYWN0LnVzZUNhbGxiYWNrKHVzZXJQcm9wcyA9PiBtZXJnZVByb3BzKHVzZXJQcm9wcywgcHJvcHNMaXN0LCAnZmxvYXRpbmcnKSwgZGVwcyk7XG5cbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvY29ycmVjdG5lc3MvdXNlRXhoYXVzdGl2ZURlcGVuZGVuY2llczogaW50ZW50aW9uYWxcbiAgY29uc3QgZ2V0SXRlbVByb3BzID0gUmVhY3QudXNlQ2FsbGJhY2sodXNlclByb3BzID0+IG1lcmdlUHJvcHModXNlclByb3BzLCBwcm9wc0xpc3QsICdpdGVtJyksXG4gIC8vIEdyYW51bGFybHkgY2hlY2sgZm9yIGBpdGVtYCBjaGFuZ2VzLCBiZWNhdXNlIHRoZSBgZ2V0SXRlbVByb3BzYCBnZXR0ZXJcbiAgLy8gc2hvdWxkIGJlIGFzIHJlZmVyZW50aWFsbHkgc3RhYmxlIGFzIHBvc3NpYmxlIHNpbmNlIGl0IG1heSBiZSBwYXNzZWQgYXNcbiAgLy8gYSBwcm9wIHRvIG1hbnkgY29tcG9uZW50cy4gQWxsIGBpdGVtYCBrZXkgdmFsdWVzIG11c3QgdGhlcmVmb3JlIGJlXG4gIC8vIG1lbW9pemVkLlxuICBwcm9wc0xpc3QubWFwKGtleSA9PiBrZXkgPT0gbnVsbCA/IHZvaWQgMCA6IGtleS5pdGVtKSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgZ2V0UmVmZXJlbmNlUHJvcHMsXG4gICAgZ2V0RmxvYXRpbmdQcm9wcyxcbiAgICBnZXRJdGVtUHJvcHNcbiAgfSksIFtnZXRSZWZlcmVuY2VQcm9wcywgZ2V0RmxvYXRpbmdQcm9wcywgZ2V0SXRlbVByb3BzXSk7XG59XG5cbmxldCBpc1ByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGRvU3dpdGNoKG9yaWVudGF0aW9uLCB2ZXJ0aWNhbCwgaG9yaXpvbnRhbCkge1xuICBzd2l0Y2ggKG9yaWVudGF0aW9uKSB7XG4gICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgcmV0dXJuIHZlcnRpY2FsO1xuICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgcmV0dXJuIGhvcml6b250YWw7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2ZXJ0aWNhbCB8fCBob3Jpem9udGFsO1xuICB9XG59XG5mdW5jdGlvbiBpc01haW5PcmllbnRhdGlvbktleShrZXksIG9yaWVudGF0aW9uKSB7XG4gIGNvbnN0IHZlcnRpY2FsID0ga2V5ID09PSBBUlJPV19VUCB8fCBrZXkgPT09IEFSUk9XX0RPV047XG4gIGNvbnN0IGhvcml6b250YWwgPSBrZXkgPT09IEFSUk9XX0xFRlQgfHwga2V5ID09PSBBUlJPV19SSUdIVDtcbiAgcmV0dXJuIGRvU3dpdGNoKG9yaWVudGF0aW9uLCB2ZXJ0aWNhbCwgaG9yaXpvbnRhbCk7XG59XG5mdW5jdGlvbiBpc01haW5PcmllbnRhdGlvblRvRW5kS2V5KGtleSwgb3JpZW50YXRpb24sIHJ0bCkge1xuICBjb25zdCB2ZXJ0aWNhbCA9IGtleSA9PT0gQVJST1dfRE9XTjtcbiAgY29uc3QgaG9yaXpvbnRhbCA9IHJ0bCA/IGtleSA9PT0gQVJST1dfTEVGVCA6IGtleSA9PT0gQVJST1dfUklHSFQ7XG4gIHJldHVybiBkb1N3aXRjaChvcmllbnRhdGlvbiwgdmVydGljYWwsIGhvcml6b250YWwpIHx8IGtleSA9PT0gJ0VudGVyJyB8fCBrZXkgPT09ICcgJyB8fCBrZXkgPT09ICcnO1xufVxuZnVuY3Rpb24gaXNDcm9zc09yaWVudGF0aW9uT3BlbktleShrZXksIG9yaWVudGF0aW9uLCBydGwpIHtcbiAgY29uc3QgdmVydGljYWwgPSBydGwgPyBrZXkgPT09IEFSUk9XX0xFRlQgOiBrZXkgPT09IEFSUk9XX1JJR0hUO1xuICBjb25zdCBob3Jpem9udGFsID0ga2V5ID09PSBBUlJPV19ET1dOO1xuICByZXR1cm4gZG9Td2l0Y2gob3JpZW50YXRpb24sIHZlcnRpY2FsLCBob3Jpem9udGFsKTtcbn1cbmZ1bmN0aW9uIGlzQ3Jvc3NPcmllbnRhdGlvbkNsb3NlS2V5KGtleSwgb3JpZW50YXRpb24sIHJ0bCkge1xuICBjb25zdCB2ZXJ0aWNhbCA9IHJ0bCA/IGtleSA9PT0gQVJST1dfUklHSFQgOiBrZXkgPT09IEFSUk9XX0xFRlQ7XG4gIGNvbnN0IGhvcml6b250YWwgPSBrZXkgPT09IEFSUk9XX1VQO1xuICByZXR1cm4gZG9Td2l0Y2gob3JpZW50YXRpb24sIHZlcnRpY2FsLCBob3Jpem9udGFsKTtcbn1cbi8qKlxuICogQWRkcyBhcnJvdyBrZXktYmFzZWQgbmF2aWdhdGlvbiBvZiBhIGxpc3Qgb2YgaXRlbXMsIGVpdGhlciB1c2luZyByZWFsIERPTVxuICogZm9jdXMgb3IgdmlydHVhbCBmb2N1cy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VMaXN0TmF2aWdhdGlvblxuICovXG5mdW5jdGlvbiB1c2VMaXN0TmF2aWdhdGlvbihjb250ZXh0LCBwcm9wcykge1xuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgcmVmcyxcbiAgICBlbGVtZW50czoge1xuICAgICAgZG9tUmVmZXJlbmNlLFxuICAgICAgZmxvYXRpbmdcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgbGlzdFJlZixcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvbk5hdmlnYXRlOiB1bnN0YWJsZV9vbk5hdmlnYXRlID0gKCkgPT4ge30sXG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgc2VsZWN0ZWRJbmRleCA9IG51bGwsXG4gICAgYWxsb3dFc2NhcGUgPSBmYWxzZSxcbiAgICBsb29wID0gZmFsc2UsXG4gICAgbmVzdGVkID0gZmFsc2UsXG4gICAgcnRsID0gZmFsc2UsXG4gICAgdmlydHVhbCA9IGZhbHNlLFxuICAgIGZvY3VzSXRlbU9uT3BlbiA9ICdhdXRvJyxcbiAgICBmb2N1c0l0ZW1PbkhvdmVyID0gdHJ1ZSxcbiAgICBvcGVuT25BcnJvd0tleURvd24gPSB0cnVlLFxuICAgIGRpc2FibGVkSW5kaWNlcyA9IHVuZGVmaW5lZCxcbiAgICBvcmllbnRhdGlvbiA9ICd2ZXJ0aWNhbCcsXG4gICAgY29scyA9IDEsXG4gICAgc2Nyb2xsSXRlbUludG9WaWV3ID0gdHJ1ZSxcbiAgICB2aXJ0dWFsSXRlbVJlZixcbiAgICBpdGVtU2l6ZXMsXG4gICAgZGVuc2UgPSBmYWxzZVxuICB9ID0gcHJvcHM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoYWxsb3dFc2NhcGUpIHtcbiAgICAgIGlmICghbG9vcCkge1xuICAgICAgICBjb25zb2xlLndhcm4oWydGbG9hdGluZyBVSTogYHVzZUxpc3ROYXZpZ2F0aW9uYCBsb29waW5nIG11c3QgYmUgZW5hYmxlZCB0byBhbGxvdycsICdlc2NhcGluZy4nXS5qb2luKCcgJykpO1xuICAgICAgfVxuICAgICAgaWYgKCF2aXJ0dWFsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihbJ0Zsb2F0aW5nIFVJOiBgdXNlTGlzdE5hdmlnYXRpb25gIG11c3QgYmUgdmlydHVhbCB0byBhbGxvdycsICdlc2NhcGluZy4nXS5qb2luKCcgJykpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgJiYgY29scyA+IDEpIHtcbiAgICAgIGNvbnNvbGUud2FybihbJ0Zsb2F0aW5nIFVJOiBJbiBncmlkIGxpc3QgbmF2aWdhdGlvbiBtb2RlIChgY29sc2AgPiAxKSwgdGhlJywgJ2BvcmllbnRhdGlvbmAgc2hvdWxkIGJlIGVpdGhlciBcImhvcml6b250YWxcIiBvciBcImJvdGhcIi4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfVxuICBjb25zdCBwYXJlbnRJZCA9IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkKCk7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgY29uc3Qgb25OYXZpZ2F0ZSA9IHVzZUVmZmVjdEV2ZW50KHVuc3RhYmxlX29uTmF2aWdhdGUpO1xuICBjb25zdCBmb2N1c0l0ZW1Pbk9wZW5SZWYgPSBSZWFjdC51c2VSZWYoZm9jdXNJdGVtT25PcGVuKTtcbiAgY29uc3QgaW5kZXhSZWYgPSBSZWFjdC51c2VSZWYoc2VsZWN0ZWRJbmRleCAhPSBudWxsID8gc2VsZWN0ZWRJbmRleCA6IC0xKTtcbiAgY29uc3Qga2V5UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBpc1BvaW50ZXJNb2RhbGl0eVJlZiA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgY29uc3QgcHJldmlvdXNPbk5hdmlnYXRlUmVmID0gUmVhY3QudXNlUmVmKG9uTmF2aWdhdGUpO1xuICBjb25zdCBwcmV2aW91c01vdW50ZWRSZWYgPSBSZWFjdC51c2VSZWYoISFmbG9hdGluZyk7XG4gIGNvbnN0IGZvcmNlU3luY0ZvY3VzID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgZm9yY2VTY3JvbGxJbnRvVmlld1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGRpc2FibGVkSW5kaWNlc1JlZiA9IHVzZUxhdGVzdFJlZihkaXNhYmxlZEluZGljZXMpO1xuICBjb25zdCBsYXRlc3RPcGVuUmVmID0gdXNlTGF0ZXN0UmVmKG9wZW4pO1xuICBjb25zdCBzY3JvbGxJdGVtSW50b1ZpZXdSZWYgPSB1c2VMYXRlc3RSZWYoc2Nyb2xsSXRlbUludG9WaWV3KTtcbiAgY29uc3QgW2FjdGl2ZUlkLCBzZXRBY3RpdmVJZF0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICBjb25zdCBbdmlydHVhbElkLCBzZXRWaXJ0dWFsSWRdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgY29uc3QgZm9jdXNJdGVtID0gdXNlRWZmZWN0RXZlbnQoZnVuY3Rpb24gKGxpc3RSZWYsIGluZGV4UmVmLCBmb3JjZVNjcm9sbEludG9WaWV3KSB7XG4gICAgaWYgKGZvcmNlU2Nyb2xsSW50b1ZpZXcgPT09IHZvaWQgMCkge1xuICAgICAgZm9yY2VTY3JvbGxJbnRvVmlldyA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpdGVtID0gbGlzdFJlZi5jdXJyZW50W2luZGV4UmVmLmN1cnJlbnRdO1xuICAgIGlmICghaXRlbSkgcmV0dXJuO1xuICAgIGlmICh2aXJ0dWFsKSB7XG4gICAgICBzZXRBY3RpdmVJZChpdGVtLmlkKTtcbiAgICAgIHRyZWUgPT0gbnVsbCB8fCB0cmVlLmV2ZW50cy5lbWl0KCd2aXJ0dWFsZm9jdXMnLCBpdGVtKTtcbiAgICAgIGlmICh2aXJ0dWFsSXRlbVJlZikge1xuICAgICAgICB2aXJ0dWFsSXRlbVJlZi5jdXJyZW50ID0gaXRlbTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZW5xdWV1ZUZvY3VzKGl0ZW0sIHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZSxcbiAgICAgICAgLy8gTWFjIFNhZmFyaSBkb2VzIG5vdCBtb3ZlIHRoZSB2aXJ0dWFsIGN1cnNvciB1bmxlc3MgdGhlIGZvY3VzIGNhbGxcbiAgICAgICAgLy8gaXMgc3luYy4gSG93ZXZlciwgZm9yIHRoZSB2ZXJ5IGZpcnN0IGZvY3VzIGNhbGwsIHdlIG5lZWQgdG8gd2FpdFxuICAgICAgICAvLyBmb3IgdGhlIHBvc2l0aW9uIHRvIGJlIHJlYWR5IGluIG9yZGVyIHRvIHByZXZlbnQgdW53YW50ZWRcbiAgICAgICAgLy8gc2Nyb2xsaW5nLiBUaGlzIG1lYW5zIHRoZSB2aXJ0dWFsIGN1cnNvciB3aWxsIG5vdCBtb3ZlIHRvIHRoZSBmaXJzdFxuICAgICAgICAvLyBpdGVtIHdoZW4gZmlyc3Qgb3BlbmluZyB0aGUgZmxvYXRpbmcgZWxlbWVudCwgYnV0IHdpbGwgb25cbiAgICAgICAgLy8gc3Vic2VxdWVudCBjYWxscy4gYHByZXZlbnRTY3JvbGxgIGlzIHN1cHBvcnRlZCBpbiBtb2Rlcm4gU2FmYXJpLFxuICAgICAgICAvLyBzbyB3ZSBjYW4gdXNlIHRoYXQgaW5zdGVhZC5cbiAgICAgICAgLy8gaU9TIFNhZmFyaSBtdXN0IGJlIGFzeW5jIG9yIHRoZSBmaXJzdCBpdGVtIHdpbGwgbm90IGJlIGZvY3VzZWQuXG4gICAgICAgIHN5bmM6IGlzTWFjKCkgJiYgaXNTYWZhcmkoKSA/IGlzUHJldmVudFNjcm9sbFN1cHBvcnRlZCB8fCBmb3JjZVN5bmNGb2N1cy5jdXJyZW50IDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgY29uc3Qgc2Nyb2xsSW50b1ZpZXdPcHRpb25zID0gc2Nyb2xsSXRlbUludG9WaWV3UmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBzaG91bGRTY3JvbGxJbnRvVmlldyA9IHNjcm9sbEludG9WaWV3T3B0aW9ucyAmJiBpdGVtICYmIChmb3JjZVNjcm9sbEludG9WaWV3IHx8ICFpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50KTtcbiAgICAgIGlmIChzaG91bGRTY3JvbGxJbnRvVmlldykge1xuICAgICAgICAvLyBKU0RPTSBkb2Vzbid0IHN1cHBvcnQgYC5zY3JvbGxJbnRvVmlldygpYCBidXQgaXQncyB3aWRlbHkgc3VwcG9ydGVkXG4gICAgICAgIC8vIGJ5IGFsbCBicm93c2Vycy5cbiAgICAgICAgaXRlbS5zY3JvbGxJbnRvVmlldyA9PSBudWxsIHx8IGl0ZW0uc2Nyb2xsSW50b1ZpZXcodHlwZW9mIHNjcm9sbEludG9WaWV3T3B0aW9ucyA9PT0gJ2Jvb2xlYW4nID8ge1xuICAgICAgICAgIGJsb2NrOiAnbmVhcmVzdCcsXG4gICAgICAgICAgaW5saW5lOiAnbmVhcmVzdCdcbiAgICAgICAgfSA6IHNjcm9sbEludG9WaWV3T3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykuZm9jdXMoe1xuICAgICAgZ2V0IHByZXZlbnRTY3JvbGwoKSB7XG4gICAgICAgIGlzUHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW10pO1xuXG4gIC8vIFN5bmMgYHNlbGVjdGVkSW5kZXhgIHRvIGJlIHRoZSBgYWN0aXZlSW5kZXhgIHVwb24gb3BlbmluZyB0aGUgZmxvYXRpbmdcbiAgLy8gZWxlbWVudC4gQWxzbywgcmVzZXQgYGFjdGl2ZUluZGV4YCB1cG9uIGNsb3NpbmcgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9wZW4gJiYgZmxvYXRpbmcpIHtcbiAgICAgIGlmIChmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCAmJiBzZWxlY3RlZEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgLy8gUmVnYXJkbGVzcyBvZiB0aGUgcG9pbnRlciBtb2RhbGl0eSwgd2Ugd2FudCB0byBlbnN1cmUgdGhlIHNlbGVjdGVkXG4gICAgICAgIC8vIGl0ZW0gY29tZXMgaW50byB2aWV3IHdoZW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgb3BlbmVkLlxuICAgICAgICBmb3JjZVNjcm9sbEludG9WaWV3UmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgb25OYXZpZ2F0ZShzZWxlY3RlZEluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByZXZpb3VzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAvLyBTaW5jZSB0aGUgdXNlciBjYW4gc3BlY2lmeSBgb25OYXZpZ2F0ZWAgY29uZGl0aW9uYWxseVxuICAgICAgLy8gKG9uTmF2aWdhdGU6IG9wZW4gPyBzZXRBY3RpdmVJbmRleCA6IHNldFNlbGVjdGVkSW5kZXgpLFxuICAgICAgLy8gd2Ugc3RvcmUgYW5kIGNhbGwgdGhlIHByZXZpb3VzIGZ1bmN0aW9uLlxuICAgICAgaW5kZXhSZWYuY3VycmVudCA9IC0xO1xuICAgICAgcHJldmlvdXNPbk5hdmlnYXRlUmVmLmN1cnJlbnQobnVsbCk7XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgb3BlbiwgZmxvYXRpbmcsIHNlbGVjdGVkSW5kZXgsIG9uTmF2aWdhdGVdKTtcblxuICAvLyBTeW5jIGBhY3RpdmVJbmRleGAgdG8gYmUgdGhlIGZvY3VzZWQgaXRlbSB3aGlsZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBpc1xuICAvLyBvcGVuLlxuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcGVuICYmIGZsb2F0aW5nKSB7XG4gICAgICBpZiAoYWN0aXZlSW5kZXggPT0gbnVsbCkge1xuICAgICAgICBmb3JjZVN5bmNGb2N1cy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIGlmIChzZWxlY3RlZEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNldCB3aGlsZSB0aGUgZmxvYXRpbmcgZWxlbWVudCB3YXMgb3BlbiAoZS5nLiB0aGUgbGlzdCBjaGFuZ2VkKS5cbiAgICAgICAgaWYgKHByZXZpb3VzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IC0xO1xuICAgICAgICAgIGZvY3VzSXRlbShsaXN0UmVmLCBpbmRleFJlZik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbml0aWFsIHN5bmMuXG4gICAgICAgIGlmICghcHJldmlvdXNNb3VudGVkUmVmLmN1cnJlbnQgJiYgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgJiYgKGtleVJlZi5jdXJyZW50ICE9IG51bGwgfHwgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgPT09IHRydWUgJiYga2V5UmVmLmN1cnJlbnQgPT0gbnVsbCkpIHtcbiAgICAgICAgICBsZXQgcnVucyA9IDA7XG4gICAgICAgICAgY29uc3Qgd2FpdEZvckxpc3RQb3B1bGF0ZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAobGlzdFJlZi5jdXJyZW50WzBdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gQXZvaWQgbGV0dGluZyB0aGUgYnJvd3NlciBwYWludCBpZiBwb3NzaWJsZSBvbiB0aGUgZmlyc3QgdHJ5LFxuICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgdXNlIHJBRi4gRG9uJ3QgdHJ5IG1vcmUgdGhhbiB0d2ljZSwgc2luY2Ugc29tZXRoaW5nXG4gICAgICAgICAgICAgIC8vIGlzIHdyb25nIG90aGVyd2lzZS5cbiAgICAgICAgICAgICAgaWYgKHJ1bnMgPCAyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZWR1bGVyID0gcnVucyA/IHJlcXVlc3RBbmltYXRpb25GcmFtZSA6IHF1ZXVlTWljcm90YXNrO1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlcih3YWl0Rm9yTGlzdFBvcHVsYXRlZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcnVucysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGtleVJlZi5jdXJyZW50ID09IG51bGwgfHwgaXNNYWluT3JpZW50YXRpb25Ub0VuZEtleShrZXlSZWYuY3VycmVudCwgb3JpZW50YXRpb24sIHJ0bCkgfHwgbmVzdGVkID8gZ2V0TWluSW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzUmVmLmN1cnJlbnQpIDogZ2V0TWF4SW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgICBrZXlSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3YWl0Rm9yTGlzdFBvcHVsYXRlZCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpc0luZGV4T3V0T2ZCb3VuZHMobGlzdFJlZiwgYWN0aXZlSW5kZXgpKSB7XG4gICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBhY3RpdmVJbmRleDtcbiAgICAgICAgZm9jdXNJdGVtKGxpc3RSZWYsIGluZGV4UmVmLCBmb3JjZVNjcm9sbEludG9WaWV3UmVmLmN1cnJlbnQpO1xuICAgICAgICBmb3JjZVNjcm9sbEludG9WaWV3UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBmbG9hdGluZywgYWN0aXZlSW5kZXgsIHNlbGVjdGVkSW5kZXgsIG5lc3RlZCwgbGlzdFJlZiwgb3JpZW50YXRpb24sIHJ0bCwgb25OYXZpZ2F0ZSwgZm9jdXNJdGVtLCBkaXNhYmxlZEluZGljZXNSZWZdKTtcblxuICAvLyBFbnN1cmUgdGhlIHBhcmVudCBmbG9hdGluZyBlbGVtZW50IGhhcyBmb2N1cyB3aGVuIGEgbmVzdGVkIGNoaWxkIGNsb3Nlc1xuICAvLyB0byBhbGxvdyBhcnJvdyBrZXkgbmF2aWdhdGlvbiB0byB3b3JrIGFmdGVyIHRoZSBwb2ludGVyIGxlYXZlcyB0aGUgY2hpbGQuXG4gIGluZGV4KCgpID0+IHtcbiAgICB2YXIgX25vZGVzJGZpbmQ7XG4gICAgaWYgKCFlbmFibGVkIHx8IGZsb2F0aW5nIHx8ICF0cmVlIHx8IHZpcnR1YWwgfHwgIXByZXZpb3VzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vZGVzID0gdHJlZS5ub2Rlc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHBhcmVudCA9IChfbm9kZXMkZmluZCA9IG5vZGVzLmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBwYXJlbnRJZCkpID09IG51bGwgfHwgKF9ub2RlcyRmaW5kID0gX25vZGVzJGZpbmQuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlcyRmaW5kLmVsZW1lbnRzLmZsb2F0aW5nO1xuICAgIGNvbnN0IGFjdGl2ZUVsID0gYWN0aXZlRWxlbWVudChnZXREb2N1bWVudChmbG9hdGluZykpO1xuICAgIGNvbnN0IHRyZWVDb250YWluc0FjdGl2ZUVsID0gbm9kZXMuc29tZShub2RlID0+IG5vZGUuY29udGV4dCAmJiBjb250YWlucyhub2RlLmNvbnRleHQuZWxlbWVudHMuZmxvYXRpbmcsIGFjdGl2ZUVsKSk7XG4gICAgaWYgKHBhcmVudCAmJiAhdHJlZUNvbnRhaW5zQWN0aXZlRWwgJiYgaXNQb2ludGVyTW9kYWxpdHlSZWYuY3VycmVudCkge1xuICAgICAgcGFyZW50LmZvY3VzKHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgZmxvYXRpbmcsIHRyZWUsIHBhcmVudElkLCB2aXJ0dWFsXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQgfHwgIXRyZWUgfHwgIXZpcnR1YWwgfHwgcGFyZW50SWQpIHJldHVybjtcbiAgICBmdW5jdGlvbiBoYW5kbGVWaXJ0dWFsRm9jdXMoaXRlbSkge1xuICAgICAgc2V0VmlydHVhbElkKGl0ZW0uaWQpO1xuICAgICAgaWYgKHZpcnR1YWxJdGVtUmVmKSB7XG4gICAgICAgIHZpcnR1YWxJdGVtUmVmLmN1cnJlbnQgPSBpdGVtO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmVlLmV2ZW50cy5vbigndmlydHVhbGZvY3VzJywgaGFuZGxlVmlydHVhbEZvY3VzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdHJlZS5ldmVudHMub2ZmKCd2aXJ0dWFsZm9jdXMnLCBoYW5kbGVWaXJ0dWFsRm9jdXMpO1xuICAgIH07XG4gIH0sIFtlbmFibGVkLCB0cmVlLCB2aXJ0dWFsLCBwYXJlbnRJZCwgdmlydHVhbEl0ZW1SZWZdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIHByZXZpb3VzT25OYXZpZ2F0ZVJlZi5jdXJyZW50ID0gb25OYXZpZ2F0ZTtcbiAgICBwcmV2aW91c01vdW50ZWRSZWYuY3VycmVudCA9ICEhZmxvYXRpbmc7XG4gIH0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICBrZXlSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9LCBbb3Blbl0pO1xuICBjb25zdCBoYXNBY3RpdmVJbmRleCA9IGFjdGl2ZUluZGV4ICE9IG51bGw7XG4gIGNvbnN0IGl0ZW0gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBmdW5jdGlvbiBzeW5jQ3VycmVudFRhcmdldChjdXJyZW50VGFyZ2V0KSB7XG4gICAgICBpZiAoIW9wZW4pIHJldHVybjtcbiAgICAgIGNvbnN0IGluZGV4ID0gbGlzdFJlZi5jdXJyZW50LmluZGV4T2YoY3VycmVudFRhcmdldCk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIG9uTmF2aWdhdGUoaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgIG9uRm9jdXMoX3JlZikge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGN1cnJlbnRUYXJnZXRcbiAgICAgICAgfSA9IF9yZWY7XG4gICAgICAgIHN5bmNDdXJyZW50VGFyZ2V0KGN1cnJlbnRUYXJnZXQpO1xuICAgICAgfSxcbiAgICAgIG9uQ2xpY2s6IF9yZWYyID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBjdXJyZW50VGFyZ2V0XG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRUYXJnZXQuZm9jdXMoe1xuICAgICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgLy8gU2FmYXJpXG4gICAgICAuLi4oZm9jdXNJdGVtT25Ib3ZlciAmJiB7XG4gICAgICAgIG9uTW91c2VNb3ZlKF9yZWYzKSB7XG4gICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgIGN1cnJlbnRUYXJnZXRcbiAgICAgICAgICB9ID0gX3JlZjM7XG4gICAgICAgICAgc3luY0N1cnJlbnRUYXJnZXQoY3VycmVudFRhcmdldCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUG9pbnRlckxlYXZlKF9yZWY0KSB7XG4gICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlXG4gICAgICAgICAgfSA9IF9yZWY0O1xuICAgICAgICAgIGlmICghaXNQb2ludGVyTW9kYWxpdHlSZWYuY3VycmVudCB8fCBwb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gLTE7XG4gICAgICAgICAgZm9jdXNJdGVtKGxpc3RSZWYsIGluZGV4UmVmKTtcbiAgICAgICAgICBvbk5hdmlnYXRlKG51bGwpO1xuICAgICAgICAgIGlmICghdmlydHVhbCkge1xuICAgICAgICAgICAgZW5xdWV1ZUZvY3VzKHJlZnMuZmxvYXRpbmcuY3VycmVudCwge1xuICAgICAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfTtcbiAgICByZXR1cm4gcHJvcHM7XG4gIH0sIFtvcGVuLCByZWZzLCBmb2N1c0l0ZW0sIGZvY3VzSXRlbU9uSG92ZXIsIGxpc3RSZWYsIG9uTmF2aWdhdGUsIHZpcnR1YWxdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBkaXNhYmxlZEluZGljZXMgPSBkaXNhYmxlZEluZGljZXNSZWYuY3VycmVudDtcbiAgICBmdW5jdGlvbiBvbktleURvd24oZXZlbnQpIHtcbiAgICAgIGlzUG9pbnRlck1vZGFsaXR5UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIGZvcmNlU3luY0ZvY3VzLmN1cnJlbnQgPSB0cnVlO1xuXG4gICAgICAvLyBJZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpcyBhbmltYXRpbmcgb3V0LCBpZ25vcmUgbmF2aWdhdGlvbi4gT3RoZXJ3aXNlLFxuICAgICAgLy8gdGhlIGBhY3RpdmVJbmRleGAgZ2V0cyBzZXQgdG8gMCBkZXNwaXRlIG5vdCBiZWluZyBvcGVuIHNvIHRoZSBuZXh0IHRpbWVcbiAgICAgIC8vIHRoZSB1c2VyIEFycm93RG93bnMsIHRoZSBmaXJzdCBpdGVtIHdvbid0IGJlIGZvY3VzZWQuXG4gICAgICBpZiAoIWxhdGVzdE9wZW5SZWYuY3VycmVudCAmJiBldmVudC5jdXJyZW50VGFyZ2V0ID09PSByZWZzLmZsb2F0aW5nLmN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG5lc3RlZCAmJiBpc0Nyb3NzT3JpZW50YXRpb25DbG9zZUtleShldmVudC5rZXksIG9yaWVudGF0aW9uLCBydGwpKSB7XG4gICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQsICdsaXN0LW5hdmlnYXRpb24nKTtcbiAgICAgICAgaWYgKGlzSFRNTEVsZW1lbnQoZG9tUmVmZXJlbmNlKSAmJiAhdmlydHVhbCkge1xuICAgICAgICAgIGRvbVJlZmVyZW5jZS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGluZGV4UmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBtaW5JbmRleCA9IGdldE1pbkluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlcyk7XG4gICAgICBjb25zdCBtYXhJbmRleCA9IGdldE1heEluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlcyk7XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSAnSG9tZScpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IG1pbkluZGV4O1xuICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VuZCcpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IG1heEluZGV4O1xuICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBHcmlkIG5hdmlnYXRpb24uXG4gICAgICBpZiAoY29scyA+IDEpIHtcbiAgICAgICAgY29uc3Qgc2l6ZXMgPSBpdGVtU2l6ZXMgfHwgQXJyYXkuZnJvbSh7XG4gICAgICAgICAgbGVuZ3RoOiBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoXG4gICAgICAgIH0sICgpID0+ICh7XG4gICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgaGVpZ2h0OiAxXG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gVG8gY2FsY3VsYXRlIG1vdmVtZW50cyBvbiB0aGUgZ3JpZCwgd2UgdXNlIGh5cG90aGV0aWNhbCBjZWxsIGluZGljZXNcbiAgICAgICAgLy8gYXMgaWYgZXZlcnkgaXRlbSB3YXMgMXgxLCB0aGVuIGNvbnZlcnQgYmFjayB0byByZWFsIGluZGljZXMuXG4gICAgICAgIGNvbnN0IGNlbGxNYXAgPSBidWlsZENlbGxNYXAoc2l6ZXMsIGNvbHMsIGRlbnNlKTtcbiAgICAgICAgY29uc3QgbWluR3JpZEluZGV4ID0gY2VsbE1hcC5maW5kSW5kZXgoaW5kZXggPT4gaW5kZXggIT0gbnVsbCAmJiAhKGRpc2FibGVkSW5kaWNlcyAhPSBudWxsICYmIGRpc2FibGVkSW5kaWNlcy5pbmNsdWRlcyhpbmRleCkpKTtcbiAgICAgICAgLy8gbGFzdCBlbmFibGVkIGluZGV4XG4gICAgICAgIGNvbnN0IG1heEdyaWRJbmRleCA9IGNlbGxNYXAucmVkdWNlKChmb3VuZEluZGV4LCBpbmRleCwgY2VsbEluZGV4KSA9PiBpbmRleCAhPSBudWxsICYmICEoZGlzYWJsZWRJbmRpY2VzICE9IG51bGwgJiYgZGlzYWJsZWRJbmRpY2VzLmluY2x1ZGVzKGluZGV4KSkgPyBjZWxsSW5kZXggOiBmb3VuZEluZGV4LCAtMSk7XG4gICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBjZWxsTWFwW2dldEdyaWROYXZpZ2F0ZWRJbmRleCh7XG4gICAgICAgICAgY3VycmVudDogY2VsbE1hcC5tYXAoaXRlbUluZGV4ID0+IGl0ZW1JbmRleCAhPSBudWxsID8gbGlzdFJlZi5jdXJyZW50W2l0ZW1JbmRleF0gOiBudWxsKVxuICAgICAgICB9LCB7XG4gICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgICAgbG9vcCxcbiAgICAgICAgICBjb2xzLFxuICAgICAgICAgIC8vIHRyZWF0IHVuZGVmaW5lZCAoZW1wdHkgZ3JpZCBzcGFjZXMpIGFzIGRpc2FibGVkIGluZGljZXMgc28gd2VcbiAgICAgICAgICAvLyBkb24ndCBlbmQgdXAgaW4gdGhlbVxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlczogZ2V0Q2VsbEluZGljZXMoWy4uLihkaXNhYmxlZEluZGljZXMgfHwgW10pLCB1bmRlZmluZWRdLCBjZWxsTWFwKSxcbiAgICAgICAgICBtaW5JbmRleDogbWluR3JpZEluZGV4LFxuICAgICAgICAgIG1heEluZGV4OiBtYXhHcmlkSW5kZXgsXG4gICAgICAgICAgcHJldkluZGV4OiBnZXRDZWxsSW5kZXhPZkNvcm5lcihpbmRleFJlZi5jdXJyZW50LCBzaXplcywgY2VsbE1hcCwgY29scyxcbiAgICAgICAgICAvLyB1c2UgYSBjb3JuZXIgbWF0Y2hpbmcgdGhlIGVkZ2UgY2xvc2VzdCB0byB0aGUgZGlyZWN0aW9uXG4gICAgICAgICAgLy8gd2UncmUgbW92aW5nIGluIHNvIHdlIGRvbid0IGVuZCB1cCBpbiB0aGUgc2FtZSBpdGVtLiBQcmVmZXJcbiAgICAgICAgICAvLyB0b3AvbGVmdCBvdmVyIGJvdHRvbS9yaWdodC5cbiAgICAgICAgICBldmVudC5rZXkgPT09IEFSUk9XX0RPV04gPyAnYmwnIDogZXZlbnQua2V5ID09PSBBUlJPV19SSUdIVCA/ICd0cicgOiAndGwnKSxcbiAgICAgICAgICBzdG9wRXZlbnQ6IHRydWVcbiAgICAgICAgfSldOyAvLyBuYXZpZ2F0ZWQgY2VsbCB3aWxsIG5ldmVyIGJlIG51bGxpc2hcblxuICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgICBpZiAob3JpZW50YXRpb24gPT09ICdib3RoJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzTWFpbk9yaWVudGF0aW9uS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24pKSB7XG4gICAgICAgIHN0b3BFdmVudChldmVudCk7XG5cbiAgICAgICAgLy8gUmVzZXQgdGhlIGluZGV4IGlmIG5vIGl0ZW0gaXMgZm9jdXNlZC5cbiAgICAgICAgaWYgKG9wZW4gJiYgIXZpcnR1YWwgJiYgYWN0aXZlRWxlbWVudChldmVudC5jdXJyZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQpID09PSBldmVudC5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGlzTWFpbk9yaWVudGF0aW9uVG9FbmRLZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbiwgcnRsKSA/IG1pbkluZGV4IDogbWF4SW5kZXg7XG4gICAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTWFpbk9yaWVudGF0aW9uVG9FbmRLZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbiwgcnRsKSkge1xuICAgICAgICAgIGlmIChsb29wKSB7XG4gICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gY3VycmVudEluZGV4ID49IG1heEluZGV4ID8gYWxsb3dFc2NhcGUgJiYgY3VycmVudEluZGV4ICE9PSBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoID8gLTEgOiBtaW5JbmRleCA6IGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogY3VycmVudEluZGV4LFxuICAgICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gTWF0aC5taW4obWF4SW5kZXgsIGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogY3VycmVudEluZGV4LFxuICAgICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGxvb3ApIHtcbiAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBjdXJyZW50SW5kZXggPD0gbWluSW5kZXggPyBhbGxvd0VzY2FwZSAmJiBjdXJyZW50SW5kZXggIT09IC0xID8gbGlzdFJlZi5jdXJyZW50Lmxlbmd0aCA6IG1heEluZGV4IDogZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgICAgICBzdGFydGluZ0luZGV4OiBjdXJyZW50SW5kZXgsXG4gICAgICAgICAgICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IE1hdGgubWF4KG1pbkluZGV4LCBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IGN1cnJlbnRJbmRleCxcbiAgICAgICAgICAgICAgZGVjcmVtZW50OiB0cnVlLFxuICAgICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSW5kZXhPdXRPZkJvdW5kcyhsaXN0UmVmLCBpbmRleFJlZi5jdXJyZW50KSkge1xuICAgICAgICAgIG9uTmF2aWdhdGUobnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1ZpcnR1YWxNb3VzZShldmVudCkge1xuICAgICAgaWYgKGZvY3VzSXRlbU9uT3BlbiA9PT0gJ2F1dG8nICYmIGlzVmlydHVhbENsaWNrKGV2ZW50Lm5hdGl2ZUV2ZW50KSkge1xuICAgICAgICBmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVmlydHVhbFBvaW50ZXIoZXZlbnQpIHtcbiAgICAgIC8vIGBwb2ludGVyZG93bmAgZmlyZXMgZmlyc3QsIHJlc2V0IHRoZSBzdGF0ZSB0aGVuIHBlcmZvcm0gdGhlIGNoZWNrcy5cbiAgICAgIGZvY3VzSXRlbU9uT3BlblJlZi5jdXJyZW50ID0gZm9jdXNJdGVtT25PcGVuO1xuICAgICAgaWYgKGZvY3VzSXRlbU9uT3BlbiA9PT0gJ2F1dG8nICYmIGlzVmlydHVhbFBvaW50ZXJFdmVudChldmVudC5uYXRpdmVFdmVudCkpIHtcbiAgICAgICAgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhcmlhQWN0aXZlRGVzY2VuZGFudFByb3AgPSB2aXJ0dWFsICYmIG9wZW4gJiYgaGFzQWN0aXZlSW5kZXggJiYge1xuICAgICAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IHZpcnR1YWxJZCB8fCBhY3RpdmVJZFxuICAgIH07XG4gICAgY29uc3QgYWN0aXZlSXRlbSA9IGxpc3RSZWYuY3VycmVudC5maW5kKGl0ZW0gPT4gKGl0ZW0gPT0gbnVsbCA/IHZvaWQgMCA6IGl0ZW0uaWQpID09PSBhY3RpdmVJZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICAuLi5hcmlhQWN0aXZlRGVzY2VuZGFudFByb3AsXG4gICAgICAgIG9uS2V5RG93bihldmVudCkge1xuICAgICAgICAgIGlzUG9pbnRlck1vZGFsaXR5UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBpc0Fycm93S2V5ID0gZXZlbnQua2V5LmluZGV4T2YoJ0Fycm93JykgPT09IDA7XG4gICAgICAgICAgY29uc3QgaXNDcm9zc09wZW5LZXkgPSBpc0Nyb3NzT3JpZW50YXRpb25PcGVuS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24sIHJ0bCk7XG4gICAgICAgICAgY29uc3QgaXNDcm9zc0Nsb3NlS2V5ID0gaXNDcm9zc09yaWVudGF0aW9uQ2xvc2VLZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbiwgcnRsKTtcbiAgICAgICAgICBjb25zdCBpc01haW5LZXkgPSBpc01haW5PcmllbnRhdGlvbktleShldmVudC5rZXksIG9yaWVudGF0aW9uKTtcbiAgICAgICAgICBjb25zdCBpc05hdmlnYXRpb25LZXkgPSAobmVzdGVkID8gaXNDcm9zc09wZW5LZXkgOiBpc01haW5LZXkpIHx8IGV2ZW50LmtleSA9PT0gJ0VudGVyJyB8fCBldmVudC5rZXkudHJpbSgpID09PSAnJztcbiAgICAgICAgICBpZiAodmlydHVhbCAmJiBvcGVuKSB7XG4gICAgICAgICAgICBjb25zdCByb290Tm9kZSA9IHRyZWUgPT0gbnVsbCA/IHZvaWQgMCA6IHRyZWUubm9kZXNSZWYuY3VycmVudC5maW5kKG5vZGUgPT4gbm9kZS5wYXJlbnRJZCA9PSBudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IGRlZXBlc3ROb2RlID0gdHJlZSAmJiByb290Tm9kZSA/IGdldERlZXBlc3ROb2RlKHRyZWUubm9kZXNSZWYuY3VycmVudCwgcm9vdE5vZGUuaWQpIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChpc0Fycm93S2V5ICYmIGRlZXBlc3ROb2RlICYmIHZpcnR1YWxJdGVtUmVmKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGV2ZW50T2JqZWN0ID0gbmV3IEtleWJvYXJkRXZlbnQoJ2tleWRvd24nLCB7XG4gICAgICAgICAgICAgICAga2V5OiBldmVudC5rZXksXG4gICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGlzQ3Jvc3NPcGVuS2V5IHx8IGlzQ3Jvc3NDbG9zZUtleSkge1xuICAgICAgICAgICAgICAgIHZhciBfZGVlcGVzdE5vZGUkY29udGV4dCwgX2RlZXBlc3ROb2RlJGNvbnRleHQyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ3VycmVudFRhcmdldCA9ICgoX2RlZXBlc3ROb2RlJGNvbnRleHQgPSBkZWVwZXN0Tm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2RlZXBlc3ROb2RlJGNvbnRleHQuZWxlbWVudHMuZG9tUmVmZXJlbmNlKSA9PT0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXNwYXRjaEl0ZW0gPSBpc0Nyb3NzQ2xvc2VLZXkgJiYgIWlzQ3VycmVudFRhcmdldCA/IChfZGVlcGVzdE5vZGUkY29udGV4dDIgPSBkZWVwZXN0Tm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2RlZXBlc3ROb2RlJGNvbnRleHQyLmVsZW1lbnRzLmRvbVJlZmVyZW5jZSA6IGlzQ3Jvc3NPcGVuS2V5ID8gYWN0aXZlSXRlbSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3BhdGNoSXRlbSkge1xuICAgICAgICAgICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgIGRpc3BhdGNoSXRlbS5kaXNwYXRjaEV2ZW50KGV2ZW50T2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgIHNldFZpcnR1YWxJZCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNNYWluS2V5ICYmIGRlZXBlc3ROb2RlLmNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVlcGVzdE5vZGUuY29udGV4dC5vcGVuICYmIGRlZXBlc3ROb2RlLnBhcmVudElkICYmIGV2ZW50LmN1cnJlbnRUYXJnZXQgIT09IGRlZXBlc3ROb2RlLmNvbnRleHQuZWxlbWVudHMuZG9tUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2RlZXBlc3ROb2RlJGNvbnRleHQkO1xuICAgICAgICAgICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgIChfZGVlcGVzdE5vZGUkY29udGV4dCQgPSBkZWVwZXN0Tm9kZS5jb250ZXh0LmVsZW1lbnRzLmRvbVJlZmVyZW5jZSkgPT0gbnVsbCB8fCBfZGVlcGVzdE5vZGUkY29udGV4dCQuZGlzcGF0Y2hFdmVudChldmVudE9iamVjdCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb25LZXlEb3duKGV2ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiBhIGZsb2F0aW5nIGVsZW1lbnQgc2hvdWxkIG5vdCBvcGVuIG9uIGFycm93IGtleSBkb3duLCBhdm9pZFxuICAgICAgICAgIC8vIHNldHRpbmcgYGFjdGl2ZUluZGV4YCB3aGlsZSBpdCdzIGNsb3NlZC5cbiAgICAgICAgICBpZiAoIW9wZW4gJiYgIW9wZW5PbkFycm93S2V5RG93biAmJiBpc0Fycm93S2V5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc05hdmlnYXRpb25LZXkpIHtcbiAgICAgICAgICAgIGtleVJlZi5jdXJyZW50ID0gbmVzdGVkICYmIGlzTWFpbktleSA/IG51bGwgOiBldmVudC5rZXk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgICAgICAgIGlmIChpc0Nyb3NzT3BlbktleSkge1xuICAgICAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBnZXRNaW5JbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXMpO1xuICAgICAgICAgICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnbGlzdC1uYXZpZ2F0aW9uJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzTWFpbktleSkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgICBpZiAoIW9wZW4gJiYgb3Blbk9uQXJyb3dLZXlEb3duKSB7XG4gICAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2xpc3QtbmF2aWdhdGlvbicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb25LZXlEb3duKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkZvY3VzKCkge1xuICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICBvbk5hdmlnYXRlKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25Qb2ludGVyRG93bjogY2hlY2tWaXJ0dWFsUG9pbnRlcixcbiAgICAgICAgb25Nb3VzZURvd246IGNoZWNrVmlydHVhbE1vdXNlLFxuICAgICAgICBvbkNsaWNrOiBjaGVja1ZpcnR1YWxNb3VzZVxuICAgICAgfSxcbiAgICAgIGZsb2F0aW5nOiB7XG4gICAgICAgICdhcmlhLW9yaWVudGF0aW9uJzogb3JpZW50YXRpb24gPT09ICdib3RoJyA/IHVuZGVmaW5lZCA6IG9yaWVudGF0aW9uLFxuICAgICAgICAuLi4oIWlzVHlwZWFibGVDb21ib2JveChkb21SZWZlcmVuY2UpICYmIGFyaWFBY3RpdmVEZXNjZW5kYW50UHJvcCksXG4gICAgICAgIG9uS2V5RG93bixcbiAgICAgICAgb25Qb2ludGVyTW92ZSgpIHtcbiAgICAgICAgICBpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGl0ZW1cbiAgICB9O1xuICB9LCBbZG9tUmVmZXJlbmNlLCByZWZzLCBhY3RpdmVJZCwgdmlydHVhbElkLCBkaXNhYmxlZEluZGljZXNSZWYsIGxhdGVzdE9wZW5SZWYsIGxpc3RSZWYsIGVuYWJsZWQsIG9yaWVudGF0aW9uLCBydGwsIHZpcnR1YWwsIG9wZW4sIGhhc0FjdGl2ZUluZGV4LCBuZXN0ZWQsIHNlbGVjdGVkSW5kZXgsIG9wZW5PbkFycm93S2V5RG93biwgYWxsb3dFc2NhcGUsIGNvbHMsIGxvb3AsIGZvY3VzSXRlbU9uT3Blbiwgb25OYXZpZ2F0ZSwgb25PcGVuQ2hhbmdlLCBpdGVtLCB0cmVlLCB2aXJ0dWFsSXRlbVJlZiwgaXRlbVNpemVzLCBkZW5zZV0pO1xufVxuXG5jb25zdCBjb21wb25lbnRSb2xlVG9BcmlhUm9sZU1hcCA9IC8qI19fUFVSRV9fKi9uZXcgTWFwKFtbJ3NlbGVjdCcsICdsaXN0Ym94J10sIFsnY29tYm9ib3gnLCAnbGlzdGJveCddLCBbJ2xhYmVsJywgZmFsc2VdXSk7XG5cbi8qKlxuICogQWRkcyBiYXNlIHNjcmVlbiByZWFkZXIgcHJvcHMgdG8gdGhlIHJlZmVyZW5jZSBhbmQgZmxvYXRpbmcgZWxlbWVudHMgZm9yIGFcbiAqIGdpdmVuIGZsb2F0aW5nIGVsZW1lbnQgYHJvbGVgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZVJvbGVcbiAqL1xuZnVuY3Rpb24gdXNlUm9sZShjb250ZXh0LCBwcm9wcykge1xuICB2YXIgX2NvbXBvbmVudFJvbGVUb0FyaWFSO1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgZmxvYXRpbmdJZFxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIHJvbGUgPSAnZGlhbG9nJ1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGFyaWFSb2xlID0gKF9jb21wb25lbnRSb2xlVG9BcmlhUiA9IGNvbXBvbmVudFJvbGVUb0FyaWFSb2xlTWFwLmdldChyb2xlKSkgIT0gbnVsbCA/IF9jb21wb25lbnRSb2xlVG9BcmlhUiA6IHJvbGU7XG4gIGNvbnN0IHJlZmVyZW5jZUlkID0gdXNlSWQoKTtcbiAgY29uc3QgcGFyZW50SWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpO1xuICBjb25zdCBpc05lc3RlZCA9IHBhcmVudElkICE9IG51bGw7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybiB7fTtcbiAgICBjb25zdCBmbG9hdGluZ1Byb3BzID0ge1xuICAgICAgaWQ6IGZsb2F0aW5nSWQsXG4gICAgICAuLi4oYXJpYVJvbGUgJiYge1xuICAgICAgICByb2xlOiBhcmlhUm9sZVxuICAgICAgfSlcbiAgICB9O1xuICAgIGlmIChhcmlhUm9sZSA9PT0gJ3Rvb2x0aXAnIHx8IHJvbGUgPT09ICdsYWJlbCcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICAgIFtcImFyaWEtXCIgKyAocm9sZSA9PT0gJ2xhYmVsJyA/ICdsYWJlbGxlZGJ5JyA6ICdkZXNjcmliZWRieScpXTogb3BlbiA/IGZsb2F0aW5nSWQgOiB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXRpbmc6IGZsb2F0aW5nUHJvcHNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBvcGVuID8gJ3RydWUnIDogJ2ZhbHNlJyxcbiAgICAgICAgJ2FyaWEtaGFzcG9wdXAnOiBhcmlhUm9sZSA9PT0gJ2FsZXJ0ZGlhbG9nJyA/ICdkaWFsb2cnIDogYXJpYVJvbGUsXG4gICAgICAgICdhcmlhLWNvbnRyb2xzJzogb3BlbiA/IGZsb2F0aW5nSWQgOiB1bmRlZmluZWQsXG4gICAgICAgIC4uLihhcmlhUm9sZSA9PT0gJ2xpc3Rib3gnICYmIHtcbiAgICAgICAgICByb2xlOiAnY29tYm9ib3gnXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4oYXJpYVJvbGUgPT09ICdtZW51JyAmJiB7XG4gICAgICAgICAgaWQ6IHJlZmVyZW5jZUlkXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4oYXJpYVJvbGUgPT09ICdtZW51JyAmJiBpc05lc3RlZCAmJiB7XG4gICAgICAgICAgcm9sZTogJ21lbnVpdGVtJ1xuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJvbGUgPT09ICdzZWxlY3QnICYmIHtcbiAgICAgICAgICAnYXJpYS1hdXRvY29tcGxldGUnOiAnbm9uZSdcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihyb2xlID09PSAnY29tYm9ib3gnICYmIHtcbiAgICAgICAgICAnYXJpYS1hdXRvY29tcGxldGUnOiAnbGlzdCdcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICBmbG9hdGluZzoge1xuICAgICAgICAuLi5mbG9hdGluZ1Byb3BzLFxuICAgICAgICAuLi4oYXJpYVJvbGUgPT09ICdtZW51JyAmJiB7XG4gICAgICAgICAgJ2FyaWEtbGFiZWxsZWRieSc6IHJlZmVyZW5jZUlkXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgaXRlbShfcmVmKSB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgYWN0aXZlLFxuICAgICAgICAgIHNlbGVjdGVkXG4gICAgICAgIH0gPSBfcmVmO1xuICAgICAgICBjb25zdCBjb21tb25Qcm9wcyA9IHtcbiAgICAgICAgICByb2xlOiAnb3B0aW9uJyxcbiAgICAgICAgICAuLi4oYWN0aXZlICYmIHtcbiAgICAgICAgICAgIGlkOiBmbG9hdGluZ0lkICsgXCItb3B0aW9uXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEZvciBgbWVudWAsIHdlIGFyZSB1bmFibGUgdG8gdGVsbCBpZiB0aGUgaXRlbSBpcyBhIGBtZW51aXRlbXJhZGlvYFxuICAgICAgICAvLyBvciBgbWVudWl0ZW1jaGVja2JveGAuIEZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSByZWFzb25zLCBhbHNvXG4gICAgICAgIC8vIGF2b2lkIGRlZmF1bHRpbmcgdG8gYG1lbnVpdGVtYCBhcyBpdCBtYXkgb3ZlcndyaXRlIGN1c3RvbSByb2xlIHByb3BzLlxuICAgICAgICBzd2l0Y2ggKHJvbGUpIHtcbiAgICAgICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uY29tbW9uUHJvcHMsXG4gICAgICAgICAgICAgICdhcmlhLXNlbGVjdGVkJzogYWN0aXZlICYmIHNlbGVjdGVkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGNhc2UgJ2NvbWJvYm94JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5jb21tb25Qcm9wcyxcbiAgICAgICAgICAgICAgICAuLi4oYWN0aXZlICYmIHtcbiAgICAgICAgICAgICAgICAgICdhcmlhLXNlbGVjdGVkJzogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbmFibGVkLCByb2xlLCBhcmlhUm9sZSwgb3BlbiwgZmxvYXRpbmdJZCwgcmVmZXJlbmNlSWQsIGlzTmVzdGVkXSk7XG59XG5cbi8vIENvbnZlcnRzIGEgSlMgc3R5bGUga2V5IGxpa2UgYGJhY2tncm91bmRDb2xvcmAgdG8gYSBDU1MgdHJhbnNpdGlvbi1wcm9wZXJ0eVxuLy8gbGlrZSBgYmFja2dyb3VuZC1jb2xvcmAuXG5jb25zdCBjYW1lbENhc2VUb0tlYmFiQ2FzZSA9IHN0ciA9PiBzdHIucmVwbGFjZSgvW0EtWl0rKD8hW2Etel0pfFtBLVpdL2csICgkLCBvZnMpID0+IChvZnMgPyAnLScgOiAnJykgKyAkLnRvTG93ZXJDYXNlKCkpO1xuZnVuY3Rpb24gZXhlY1dpdGhBcmdzT3JSZXR1cm4odmFsdWVPckZuLCBhcmdzKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWVPckZuID09PSAnZnVuY3Rpb24nID8gdmFsdWVPckZuKGFyZ3MpIDogdmFsdWVPckZuO1xufVxuZnVuY3Rpb24gdXNlRGVsYXlVbm1vdW50KG9wZW4sIGR1cmF0aW9uTXMpIHtcbiAgY29uc3QgW2lzTW91bnRlZCwgc2V0SXNNb3VudGVkXSA9IFJlYWN0LnVzZVN0YXRlKG9wZW4pO1xuICBpZiAob3BlbiAmJiAhaXNNb3VudGVkKSB7XG4gICAgc2V0SXNNb3VudGVkKHRydWUpO1xuICB9XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBzZXRJc01vdW50ZWQoZmFsc2UpLCBkdXJhdGlvbk1zKTtcbiAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgfVxuICB9LCBbb3BlbiwgZHVyYXRpb25Nc10pO1xuICByZXR1cm4gaXNNb3VudGVkO1xufVxuLyoqXG4gKiBQcm92aWRlcyBhIHN0YXR1cyBzdHJpbmcgdG8gYXBwbHkgQ1NTIHRyYW5zaXRpb25zIHRvIGEgZmxvYXRpbmcgZWxlbWVudCxcbiAqIGNvcnJlY3RseSBoYW5kbGluZyBwbGFjZW1lbnQtYXdhcmUgdHJhbnNpdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlVHJhbnNpdGlvbiN1c2V0cmFuc2l0aW9uc3RhdHVzXG4gKi9cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb25TdGF0dXMoY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBmbG9hdGluZ1xuICAgIH1cbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBkdXJhdGlvbiA9IDI1MFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGlzTnVtYmVyRHVyYXRpb24gPSB0eXBlb2YgZHVyYXRpb24gPT09ICdudW1iZXInO1xuICBjb25zdCBjbG9zZUR1cmF0aW9uID0gKGlzTnVtYmVyRHVyYXRpb24gPyBkdXJhdGlvbiA6IGR1cmF0aW9uLmNsb3NlKSB8fCAwO1xuICBjb25zdCBbaW5pdGlhdGVkLCBzZXRJbml0aWF0ZWRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc3RhdHVzLCBzZXRTdGF0dXNdID0gUmVhY3QudXNlU3RhdGUoJ3VubW91bnRlZCcpO1xuICBjb25zdCBpc01vdW50ZWQgPSB1c2VEZWxheVVubW91bnQob3BlbiwgY2xvc2VEdXJhdGlvbik7XG5cbiAgLy8gYGluaXRpYXRlZGAgY2hlY2sgcHJldmVudHMgdGhpcyBgc2V0U3RhdGVgIGNhbGwgZnJvbSBicmVha2luZ1xuICAvLyA8RmxvYXRpbmdQb3J0YWwgLz4uIFRoaXMgY2FsbCBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIHN1YnNlcXVlbnQgb3BlbnNcbiAgLy8gYWZ0ZXIgdGhlIGluaXRpYWwgb25lIGFsbG93cyB0aGUgY29ycmVjdCBzaWRlIGFuaW1hdGlvbiB0byBwbGF5IHdoZW4gdGhlXG4gIC8vIHBsYWNlbWVudCBoYXMgY2hhbmdlZC5cbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChpbml0aWF0ZWQgJiYgIWlzTW91bnRlZCkge1xuICAgICAgc2V0U3RhdHVzKCd1bm1vdW50ZWQnKTtcbiAgICB9XG4gIH0sIFtpbml0aWF0ZWQsIGlzTW91bnRlZF0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKCFmbG9hdGluZykgcmV0dXJuO1xuICAgIGlmIChvcGVuKSB7XG4gICAgICBzZXRTdGF0dXMoJ2luaXRpYWwnKTtcbiAgICAgIGNvbnN0IGZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgc2V0U3RhdHVzKCdvcGVuJyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHNldEluaXRpYXRlZCh0cnVlKTtcbiAgICBzZXRTdGF0dXMoJ2Nsb3NlJyk7XG4gIH0sIFtvcGVuLCBmbG9hdGluZ10pO1xuICByZXR1cm4ge1xuICAgIGlzTW91bnRlZCxcbiAgICBzdGF0dXNcbiAgfTtcbn1cbi8qKlxuICogUHJvdmlkZXMgc3R5bGVzIHRvIGFwcGx5IENTUyB0cmFuc2l0aW9ucyB0byBhIGZsb2F0aW5nIGVsZW1lbnQsIGNvcnJlY3RseVxuICogaGFuZGxpbmcgcGxhY2VtZW50LWF3YXJlIHRyYW5zaXRpb25zLiBXcmFwcGVyIGFyb3VuZCBgdXNlVHJhbnNpdGlvblN0YXR1c2AuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlVHJhbnNpdGlvbiN1c2V0cmFuc2l0aW9uc3R5bGVzXG4gKi9cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb25TdHlsZXMoY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBpbml0aWFsOiB1bnN0YWJsZV9pbml0aWFsID0ge1xuICAgICAgb3BhY2l0eTogMFxuICAgIH0sXG4gICAgb3BlbjogdW5zdGFibGVfb3BlbixcbiAgICBjbG9zZTogdW5zdGFibGVfY2xvc2UsXG4gICAgY29tbW9uOiB1bnN0YWJsZV9jb21tb24sXG4gICAgZHVyYXRpb24gPSAyNTBcbiAgfSA9IHByb3BzO1xuICBjb25zdCBwbGFjZW1lbnQgPSBjb250ZXh0LnBsYWNlbWVudDtcbiAgY29uc3Qgc2lkZSA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICBjb25zdCBmbkFyZ3MgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgc2lkZSxcbiAgICBwbGFjZW1lbnRcbiAgfSksIFtzaWRlLCBwbGFjZW1lbnRdKTtcbiAgY29uc3QgaXNOdW1iZXJEdXJhdGlvbiA9IHR5cGVvZiBkdXJhdGlvbiA9PT0gJ251bWJlcic7XG4gIGNvbnN0IG9wZW5EdXJhdGlvbiA9IChpc051bWJlckR1cmF0aW9uID8gZHVyYXRpb24gOiBkdXJhdGlvbi5vcGVuKSB8fCAwO1xuICBjb25zdCBjbG9zZUR1cmF0aW9uID0gKGlzTnVtYmVyRHVyYXRpb24gPyBkdXJhdGlvbiA6IGR1cmF0aW9uLmNsb3NlKSB8fCAwO1xuICBjb25zdCBbc3R5bGVzLCBzZXRTdHlsZXNdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gKHtcbiAgICAuLi5leGVjV2l0aEFyZ3NPclJldHVybih1bnN0YWJsZV9jb21tb24sIGZuQXJncyksXG4gICAgLi4uZXhlY1dpdGhBcmdzT3JSZXR1cm4odW5zdGFibGVfaW5pdGlhbCwgZm5BcmdzKVxuICB9KSk7XG4gIGNvbnN0IHtcbiAgICBpc01vdW50ZWQsXG4gICAgc3RhdHVzXG4gIH0gPSB1c2VUcmFuc2l0aW9uU3RhdHVzKGNvbnRleHQsIHtcbiAgICBkdXJhdGlvblxuICB9KTtcbiAgY29uc3QgaW5pdGlhbFJlZiA9IHVzZUxhdGVzdFJlZih1bnN0YWJsZV9pbml0aWFsKTtcbiAgY29uc3Qgb3BlblJlZiA9IHVzZUxhdGVzdFJlZih1bnN0YWJsZV9vcGVuKTtcbiAgY29uc3QgY2xvc2VSZWYgPSB1c2VMYXRlc3RSZWYodW5zdGFibGVfY2xvc2UpO1xuICBjb25zdCBjb21tb25SZWYgPSB1c2VMYXRlc3RSZWYodW5zdGFibGVfY29tbW9uKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGNvbnN0IGluaXRpYWxTdHlsZXMgPSBleGVjV2l0aEFyZ3NPclJldHVybihpbml0aWFsUmVmLmN1cnJlbnQsIGZuQXJncyk7XG4gICAgY29uc3QgY2xvc2VTdHlsZXMgPSBleGVjV2l0aEFyZ3NPclJldHVybihjbG9zZVJlZi5jdXJyZW50LCBmbkFyZ3MpO1xuICAgIGNvbnN0IGNvbW1vblN0eWxlcyA9IGV4ZWNXaXRoQXJnc09yUmV0dXJuKGNvbW1vblJlZi5jdXJyZW50LCBmbkFyZ3MpO1xuICAgIGNvbnN0IG9wZW5TdHlsZXMgPSBleGVjV2l0aEFyZ3NPclJldHVybihvcGVuUmVmLmN1cnJlbnQsIGZuQXJncykgfHwgT2JqZWN0LmtleXMoaW5pdGlhbFN0eWxlcykucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgYWNjW2tleV0gPSAnJztcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIGlmIChzdGF0dXMgPT09ICdpbml0aWFsJykge1xuICAgICAgc2V0U3R5bGVzKHN0eWxlcyA9PiAoe1xuICAgICAgICB0cmFuc2l0aW9uUHJvcGVydHk6IHN0eWxlcy50cmFuc2l0aW9uUHJvcGVydHksXG4gICAgICAgIC4uLmNvbW1vblN0eWxlcyxcbiAgICAgICAgLi4uaW5pdGlhbFN0eWxlc1xuICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAnb3BlbicpIHtcbiAgICAgIHNldFN0eWxlcyh7XG4gICAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogT2JqZWN0LmtleXMob3BlblN0eWxlcykubWFwKGNhbWVsQ2FzZVRvS2ViYWJDYXNlKS5qb2luKCcsJyksXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogb3BlbkR1cmF0aW9uICsgXCJtc1wiLFxuICAgICAgICAuLi5jb21tb25TdHlsZXMsXG4gICAgICAgIC4uLm9wZW5TdHlsZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAnY2xvc2UnKSB7XG4gICAgICBjb25zdCBzdHlsZXMgPSBjbG9zZVN0eWxlcyB8fCBpbml0aWFsU3R5bGVzO1xuICAgICAgc2V0U3R5bGVzKHtcbiAgICAgICAgdHJhbnNpdGlvblByb3BlcnR5OiBPYmplY3Qua2V5cyhzdHlsZXMpLm1hcChjYW1lbENhc2VUb0tlYmFiQ2FzZSkuam9pbignLCcpLFxuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGNsb3NlRHVyYXRpb24gKyBcIm1zXCIsXG4gICAgICAgIC4uLmNvbW1vblN0eWxlcyxcbiAgICAgICAgLi4uc3R5bGVzXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtjbG9zZUR1cmF0aW9uLCBjbG9zZVJlZiwgaW5pdGlhbFJlZiwgb3BlblJlZiwgY29tbW9uUmVmLCBvcGVuRHVyYXRpb24sIHN0YXR1cywgZm5BcmdzXSk7XG4gIHJldHVybiB7XG4gICAgaXNNb3VudGVkLFxuICAgIHN0eWxlc1xuICB9O1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGEgbWF0Y2hpbmcgY2FsbGJhY2sgdGhhdCBjYW4gYmUgdXNlZCB0byBmb2N1cyBhbiBpdGVtIGFzIHRoZSB1c2VyXG4gKiB0eXBlcywgb2Z0ZW4gdXNlZCBpbiB0YW5kZW0gd2l0aCBgdXNlTGlzdE5hdmlnYXRpb24oKWAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlVHlwZWFoZWFkXG4gKi9cbmZ1bmN0aW9uIHVzZVR5cGVhaGVhZChjb250ZXh0LCBwcm9wcykge1xuICB2YXIgX3JlZjtcbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgZGF0YVJlZlxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGxpc3RSZWYsXG4gICAgYWN0aXZlSW5kZXgsXG4gICAgb25NYXRjaDogdW5zdGFibGVfb25NYXRjaCxcbiAgICBvblR5cGluZ0NoYW5nZTogdW5zdGFibGVfb25UeXBpbmdDaGFuZ2UsXG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgZmluZE1hdGNoID0gbnVsbCxcbiAgICByZXNldE1zID0gNzUwLFxuICAgIGlnbm9yZUtleXMgPSBbXSxcbiAgICBzZWxlY3RlZEluZGV4ID0gbnVsbFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHRpbWVvdXRJZFJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBzdHJpbmdSZWYgPSBSZWFjdC51c2VSZWYoJycpO1xuICBjb25zdCBwcmV2SW5kZXhSZWYgPSBSZWFjdC51c2VSZWYoKF9yZWYgPSBzZWxlY3RlZEluZGV4ICE9IG51bGwgPyBzZWxlY3RlZEluZGV4IDogYWN0aXZlSW5kZXgpICE9IG51bGwgPyBfcmVmIDogLTEpO1xuICBjb25zdCBtYXRjaEluZGV4UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBvbk1hdGNoID0gdXNlRWZmZWN0RXZlbnQodW5zdGFibGVfb25NYXRjaCk7XG4gIGNvbnN0IG9uVHlwaW5nQ2hhbmdlID0gdXNlRWZmZWN0RXZlbnQodW5zdGFibGVfb25UeXBpbmdDaGFuZ2UpO1xuICBjb25zdCBmaW5kTWF0Y2hSZWYgPSB1c2VMYXRlc3RSZWYoZmluZE1hdGNoKTtcbiAgY29uc3QgaWdub3JlS2V5c1JlZiA9IHVzZUxhdGVzdFJlZihpZ25vcmVLZXlzKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChvcGVuKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkUmVmLmN1cnJlbnQpO1xuICAgICAgbWF0Y2hJbmRleFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHN0cmluZ1JlZi5jdXJyZW50ID0gJyc7XG4gICAgfVxuICB9LCBbb3Blbl0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgLy8gU3luYyBhcnJvdyBrZXkgbmF2aWdhdGlvbiBidXQgbm90IHR5cGVhaGVhZCBuYXZpZ2F0aW9uLlxuICAgIGlmIChvcGVuICYmIHN0cmluZ1JlZi5jdXJyZW50ID09PSAnJykge1xuICAgICAgdmFyIF9yZWYyO1xuICAgICAgcHJldkluZGV4UmVmLmN1cnJlbnQgPSAoX3JlZjIgPSBzZWxlY3RlZEluZGV4ICE9IG51bGwgPyBzZWxlY3RlZEluZGV4IDogYWN0aXZlSW5kZXgpICE9IG51bGwgPyBfcmVmMiA6IC0xO1xuICAgIH1cbiAgfSwgW29wZW4sIHNlbGVjdGVkSW5kZXgsIGFjdGl2ZUluZGV4XSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0VHlwaW5nQ2hhbmdlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCFkYXRhUmVmLmN1cnJlbnQudHlwaW5nKSB7XG4gICAgICAgICAgZGF0YVJlZi5jdXJyZW50LnR5cGluZyA9IHZhbHVlO1xuICAgICAgICAgIG9uVHlwaW5nQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRhdGFSZWYuY3VycmVudC50eXBpbmcpIHtcbiAgICAgICAgICBkYXRhUmVmLmN1cnJlbnQudHlwaW5nID0gdmFsdWU7XG4gICAgICAgICAgb25UeXBpbmdDaGFuZ2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE1hdGNoaW5nSW5kZXgobGlzdCwgb3JkZXJlZExpc3QsIHN0cmluZykge1xuICAgICAgY29uc3Qgc3RyID0gZmluZE1hdGNoUmVmLmN1cnJlbnQgPyBmaW5kTWF0Y2hSZWYuY3VycmVudChvcmRlcmVkTGlzdCwgc3RyaW5nKSA6IG9yZGVyZWRMaXN0LmZpbmQodGV4dCA9PiAodGV4dCA9PSBudWxsID8gdm9pZCAwIDogdGV4dC50b0xvY2FsZUxvd2VyQ2FzZSgpLmluZGV4T2Yoc3RyaW5nLnRvTG9jYWxlTG93ZXJDYXNlKCkpKSA9PT0gMCk7XG4gICAgICByZXR1cm4gc3RyID8gbGlzdC5pbmRleE9mKHN0cikgOiAtMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICBjb25zdCBsaXN0Q29udGVudCA9IGxpc3RSZWYuY3VycmVudDtcbiAgICAgIGlmIChzdHJpbmdSZWYuY3VycmVudC5sZW5ndGggPiAwICYmIHN0cmluZ1JlZi5jdXJyZW50WzBdICE9PSAnICcpIHtcbiAgICAgICAgaWYgKGdldE1hdGNoaW5nSW5kZXgobGlzdENvbnRlbnQsIGxpc3RDb250ZW50LCBzdHJpbmdSZWYuY3VycmVudCkgPT09IC0xKSB7XG4gICAgICAgICAgc2V0VHlwaW5nQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09ICcgJykge1xuICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsaXN0Q29udGVudCA9PSBudWxsIHx8IGlnbm9yZUtleXNSZWYuY3VycmVudC5pbmNsdWRlcyhldmVudC5rZXkpIHx8XG4gICAgICAvLyBDaGFyYWN0ZXIga2V5LlxuICAgICAgZXZlbnQua2V5Lmxlbmd0aCAhPT0gMSB8fFxuICAgICAgLy8gTW9kaWZpZXIga2V5LlxuICAgICAgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAob3BlbiAmJiBldmVudC5rZXkgIT09ICcgJykge1xuICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICBzZXRUeXBpbmdDaGFuZ2UodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEJhaWwgb3V0IGlmIHRoZSBsaXN0IGNvbnRhaW5zIGEgd29yZCBsaWtlIFwibGxhbWFcIiBvciBcImFhcm9uXCIuIFRPRE86XG4gICAgICAvLyBhbGxvdyBpdCBpbiB0aGlzIGNhc2UsIHRvby5cbiAgICAgIGNvbnN0IGFsbG93UmFwaWRTdWNjZXNzaW9uT2ZGaXJzdExldHRlciA9IGxpc3RDb250ZW50LmV2ZXJ5KHRleHQgPT4ge1xuICAgICAgICB2YXIgX3RleHQkLCBfdGV4dCQyO1xuICAgICAgICByZXR1cm4gdGV4dCA/ICgoX3RleHQkID0gdGV4dFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90ZXh0JC50b0xvY2FsZUxvd2VyQ2FzZSgpKSAhPT0gKChfdGV4dCQyID0gdGV4dFsxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90ZXh0JDIudG9Mb2NhbGVMb3dlckNhc2UoKSkgOiB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEFsbG93cyB0aGUgdXNlciB0byBjeWNsZSB0aHJvdWdoIGl0ZW1zIHRoYXQgc3RhcnQgd2l0aCB0aGUgc2FtZSBsZXR0ZXJcbiAgICAgIC8vIGluIHJhcGlkIHN1Y2Nlc3Npb24uXG4gICAgICBpZiAoYWxsb3dSYXBpZFN1Y2Nlc3Npb25PZkZpcnN0TGV0dGVyICYmIHN0cmluZ1JlZi5jdXJyZW50ID09PSBldmVudC5rZXkpIHtcbiAgICAgICAgc3RyaW5nUmVmLmN1cnJlbnQgPSAnJztcbiAgICAgICAgcHJldkluZGV4UmVmLmN1cnJlbnQgPSBtYXRjaEluZGV4UmVmLmN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBzdHJpbmdSZWYuY3VycmVudCArPSBldmVudC5rZXk7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkUmVmLmN1cnJlbnQpO1xuICAgICAgdGltZW91dElkUmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc3RyaW5nUmVmLmN1cnJlbnQgPSAnJztcbiAgICAgICAgcHJldkluZGV4UmVmLmN1cnJlbnQgPSBtYXRjaEluZGV4UmVmLmN1cnJlbnQ7XG4gICAgICAgIHNldFR5cGluZ0NoYW5nZShmYWxzZSk7XG4gICAgICB9LCByZXNldE1zKTtcbiAgICAgIGNvbnN0IHByZXZJbmRleCA9IHByZXZJbmRleFJlZi5jdXJyZW50O1xuICAgICAgY29uc3QgaW5kZXggPSBnZXRNYXRjaGluZ0luZGV4KGxpc3RDb250ZW50LCBbLi4ubGlzdENvbnRlbnQuc2xpY2UoKHByZXZJbmRleCB8fCAwKSArIDEpLCAuLi5saXN0Q29udGVudC5zbGljZSgwLCAocHJldkluZGV4IHx8IDApICsgMSldLCBzdHJpbmdSZWYuY3VycmVudCk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIG9uTWF0Y2goaW5kZXgpO1xuICAgICAgICBtYXRjaEluZGV4UmVmLmN1cnJlbnQgPSBpbmRleDtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ICE9PSAnICcpIHtcbiAgICAgICAgc3RyaW5nUmVmLmN1cnJlbnQgPSAnJztcbiAgICAgICAgc2V0VHlwaW5nQ2hhbmdlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICBvbktleURvd25cbiAgICAgIH0sXG4gICAgICBmbG9hdGluZzoge1xuICAgICAgICBvbktleURvd24sXG4gICAgICAgIG9uS2V5VXAoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnICcpIHtcbiAgICAgICAgICAgIHNldFR5cGluZ0NoYW5nZShmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIG9wZW4sIGRhdGFSZWYsIGxpc3RSZWYsIHJlc2V0TXMsIGlnbm9yZUtleXNSZWYsIGZpbmRNYXRjaFJlZiwgb25NYXRjaCwgb25UeXBpbmdDaGFuZ2VdKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXJnc1dpdGhDdXN0b21GbG9hdGluZ0hlaWdodChzdGF0ZSwgaGVpZ2h0KSB7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgcmVjdHM6IHtcbiAgICAgIC4uLnN0YXRlLnJlY3RzLFxuICAgICAgZmxvYXRpbmc6IHtcbiAgICAgICAgLi4uc3RhdGUucmVjdHMuZmxvYXRpbmcsXG4gICAgICAgIGhlaWdodFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbi8qKlxuICogUG9zaXRpb25zIHRoZSBmbG9hdGluZyBlbGVtZW50IHN1Y2ggdGhhdCBhbiBpbm5lciBlbGVtZW50IGluc2lkZVxuICogb2YgaXQgaXMgYW5jaG9yZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubmVyXG4gKi9cbmNvbnN0IGlubmVyID0gcHJvcHMgPT4gKHtcbiAgbmFtZTogJ2lubmVyJyxcbiAgb3B0aW9uczogcHJvcHMsXG4gIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGlzdFJlZixcbiAgICAgIG92ZXJmbG93UmVmLFxuICAgICAgb25GYWxsYmFja0NoYW5nZSxcbiAgICAgIG9mZnNldDogaW5uZXJPZmZzZXQgPSAwLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgbWluSXRlbXNWaXNpYmxlID0gNCxcbiAgICAgIHJlZmVyZW5jZU92ZXJmbG93VGhyZXNob2xkID0gMCxcbiAgICAgIHNjcm9sbFJlZixcbiAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgIH0gPSBwcm9wcztcbiAgICBjb25zdCB7XG4gICAgICByZWN0cyxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGZsb2F0aW5nXG4gICAgICB9XG4gICAgfSA9IHN0YXRlO1xuICAgIGNvbnN0IGl0ZW0gPSBsaXN0UmVmLmN1cnJlbnRbaW5kZXhdO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghc3RhdGUucGxhY2VtZW50LnN0YXJ0c1dpdGgoJ2JvdHRvbScpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihbJ0Zsb2F0aW5nIFVJOiBgcGxhY2VtZW50YCBzaWRlIG11c3QgYmUgXCJib3R0b21cIiB3aGVuIHVzaW5nIHRoZScsICdgaW5uZXJgIG1pZGRsZXdhcmUuJ10uam9pbignICcpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IG5leHRBcmdzID0ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICAuLi4oYXdhaXQgb2Zmc2V0KC1pdGVtLm9mZnNldFRvcCAtIGZsb2F0aW5nLmNsaWVudFRvcCAtIHJlY3RzLnJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gaXRlbS5vZmZzZXRIZWlnaHQgLyAyIC0gaW5uZXJPZmZzZXQpLmZuKHN0YXRlKSlcbiAgICB9O1xuICAgIGNvbnN0IGVsID0gKHNjcm9sbFJlZiA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsUmVmLmN1cnJlbnQpIHx8IGZsb2F0aW5nO1xuICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coZ2V0QXJnc1dpdGhDdXN0b21GbG9hdGluZ0hlaWdodChuZXh0QXJncywgZWwuc2Nyb2xsSGVpZ2h0KSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICBjb25zdCByZWZPdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KG5leHRBcmdzLCB7XG4gICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnMsXG4gICAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgICB9KTtcbiAgICBjb25zdCBkaWZmWSA9IE1hdGgubWF4KDAsIG92ZXJmbG93LnRvcCk7XG4gICAgY29uc3QgbmV4dFkgPSBuZXh0QXJncy55ICsgZGlmZlk7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gTWF0aC5tYXgoMCwgZWwuc2Nyb2xsSGVpZ2h0IC0gZGlmZlkgLSBNYXRoLm1heCgwLCBvdmVyZmxvdy5ib3R0b20pKTtcbiAgICBlbC5zdHlsZS5tYXhIZWlnaHQgPSBtYXhIZWlnaHQgKyBcInB4XCI7XG4gICAgZWwuc2Nyb2xsVG9wID0gZGlmZlk7XG5cbiAgICAvLyBUaGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlLCBmYWxsYmFjayB0byBzdGFuZGFyZCBhbmNob3JlZCBwb3NpdGlvbmluZ1xuICAgIGlmIChvbkZhbGxiYWNrQ2hhbmdlKSB7XG4gICAgICBpZiAoZWwub2Zmc2V0SGVpZ2h0IDwgaXRlbS5vZmZzZXRIZWlnaHQgKiBNYXRoLm1pbihtaW5JdGVtc1Zpc2libGUsIGxpc3RSZWYuY3VycmVudC5sZW5ndGggLSAxKSAtIDEgfHwgcmVmT3ZlcmZsb3cudG9wID49IC1yZWZlcmVuY2VPdmVyZmxvd1RocmVzaG9sZCB8fCByZWZPdmVyZmxvdy5ib3R0b20gPj0gLXJlZmVyZW5jZU92ZXJmbG93VGhyZXNob2xkKSB7XG4gICAgICAgIGZsdXNoU3luYygoKSA9PiBvbkZhbGxiYWNrQ2hhbmdlKHRydWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZsdXNoU3luYygoKSA9PiBvbkZhbGxiYWNrQ2hhbmdlKGZhbHNlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvdmVyZmxvd1JlZikge1xuICAgICAgb3ZlcmZsb3dSZWYuY3VycmVudCA9IGF3YWl0IGRldGVjdE92ZXJmbG93KGdldEFyZ3NXaXRoQ3VzdG9tRmxvYXRpbmdIZWlnaHQoe1xuICAgICAgICAuLi5uZXh0QXJncyxcbiAgICAgICAgeTogbmV4dFlcbiAgICAgIH0sIGVsLm9mZnNldEhlaWdodCksIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB5OiBuZXh0WVxuICAgIH07XG4gIH1cbn0pO1xuLyoqXG4gKiBDaGFuZ2VzIHRoZSBgaW5uZXJgIG1pZGRsZXdhcmUncyBgb2Zmc2V0YCB1cG9uIGEgYHdoZWVsYCBldmVudCB0b1xuICogZXhwYW5kIHRoZSBmbG9hdGluZyBlbGVtZW50J3MgaGVpZ2h0LCByZXZlYWxpbmcgbW9yZSBsaXN0IGl0ZW1zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubmVyXG4gKi9cbmZ1bmN0aW9uIHVzZUlubmVyT2Zmc2V0KGNvbnRleHQsIHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIGVsZW1lbnRzXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgb3ZlcmZsb3dSZWYsXG4gICAgc2Nyb2xsUmVmLFxuICAgIG9uQ2hhbmdlOiB1bnN0YWJsZV9vbkNoYW5nZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IG9uQ2hhbmdlID0gdXNlRWZmZWN0RXZlbnQodW5zdGFibGVfb25DaGFuZ2UpO1xuICBjb25zdCBjb250cm9sbGVkU2Nyb2xsaW5nUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgcHJldlNjcm9sbFRvcFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgaW5pdGlhbE92ZXJmbG93UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbldoZWVsKGUpIHtcbiAgICAgIGlmIChlLmN0cmxLZXkgfHwgIWVsIHx8IG92ZXJmbG93UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkWSA9IGUuZGVsdGFZO1xuICAgICAgY29uc3QgaXNBdFRvcCA9IG92ZXJmbG93UmVmLmN1cnJlbnQudG9wID49IC0wLjU7XG4gICAgICBjb25zdCBpc0F0Qm90dG9tID0gb3ZlcmZsb3dSZWYuY3VycmVudC5ib3R0b20gPj0gLTAuNTtcbiAgICAgIGNvbnN0IHJlbWFpbmluZ1Njcm9sbCA9IGVsLnNjcm9sbEhlaWdodCAtIGVsLmNsaWVudEhlaWdodDtcbiAgICAgIGNvbnN0IHNpZ24gPSBkWSA8IDAgPyAtMSA6IDE7XG4gICAgICBjb25zdCBtZXRob2QgPSBkWSA8IDAgPyAnbWF4JyA6ICdtaW4nO1xuICAgICAgaWYgKGVsLnNjcm9sbEhlaWdodCA8PSBlbC5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0F0VG9wICYmIGRZID4gMCB8fCAhaXNBdEJvdHRvbSAmJiBkWSA8IDApIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBmbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICAgIG9uQ2hhbmdlKGQgPT4gZCArIE1hdGhbbWV0aG9kXShkWSwgcmVtYWluaW5nU2Nyb2xsICogc2lnbikpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoL2ZpcmVmb3gvaS50ZXN0KGdldFVzZXJBZ2VudCgpKSkge1xuICAgICAgICAvLyBOZWVkZWQgdG8gcHJvcGFnYXRlIHNjcm9sbGluZyBkdXJpbmcgbW9tZW50dW0gc2Nyb2xsaW5nIHBoYXNlIG9uY2VcbiAgICAgICAgLy8gaXQgZ2V0cyBsaW1pdGVkIGJ5IHRoZSBib3VuZGFyeS4gVVggaW1wcm92ZW1lbnQsIG5vdCBjcml0aWNhbC5cbiAgICAgICAgZWwuc2Nyb2xsVG9wICs9IGRZO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlbCA9IChzY3JvbGxSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IHNjcm9sbFJlZi5jdXJyZW50KSB8fCBlbGVtZW50cy5mbG9hdGluZztcbiAgICBpZiAob3BlbiAmJiBlbCkge1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBvbldoZWVsKTtcblxuICAgICAgLy8gV2FpdCBmb3IgdGhlIHBvc2l0aW9uIHRvIGJlIHJlYWR5LlxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgcHJldlNjcm9sbFRvcFJlZi5jdXJyZW50ID0gZWwuc2Nyb2xsVG9wO1xuICAgICAgICBpZiAob3ZlcmZsb3dSZWYuY3VycmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgaW5pdGlhbE92ZXJmbG93UmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAuLi5vdmVyZmxvd1JlZi5jdXJyZW50XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBpbml0aWFsT3ZlcmZsb3dSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgb25XaGVlbCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIG9wZW4sIGVsZW1lbnRzLmZsb2F0aW5nLCBvdmVyZmxvd1JlZiwgc2Nyb2xsUmVmLCBvbkNoYW5nZV0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBmbG9hdGluZzoge1xuICAgICAgICBvbktleURvd24oKSB7XG4gICAgICAgICAgY29udHJvbGxlZFNjcm9sbGluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25XaGVlbCgpIHtcbiAgICAgICAgICBjb250cm9sbGVkU2Nyb2xsaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Qb2ludGVyTW92ZSgpIHtcbiAgICAgICAgICBjb250cm9sbGVkU2Nyb2xsaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TY3JvbGwoKSB7XG4gICAgICAgICAgY29uc3QgZWwgPSAoc2Nyb2xsUmVmID09IG51bGwgPyB2b2lkIDAgOiBzY3JvbGxSZWYuY3VycmVudCkgfHwgZWxlbWVudHMuZmxvYXRpbmc7XG4gICAgICAgICAgaWYgKCFvdmVyZmxvd1JlZi5jdXJyZW50IHx8ICFlbCB8fCAhY29udHJvbGxlZFNjcm9sbGluZ1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbERpZmYgPSBlbC5zY3JvbGxUb3AgLSBwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAob3ZlcmZsb3dSZWYuY3VycmVudC5ib3R0b20gPCAtMC41ICYmIHNjcm9sbERpZmYgPCAtMSB8fCBvdmVyZmxvd1JlZi5jdXJyZW50LnRvcCA8IC0wLjUgJiYgc2Nyb2xsRGlmZiA+IDEpIHtcbiAgICAgICAgICAgICAgZmx1c2hTeW5jKCgpID0+IG9uQ2hhbmdlKGQgPT4gZCArIHNjcm9sbERpZmYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBbRmlyZWZveF0gV2FpdCBmb3IgdGhlIGhlaWdodCBjaGFuZ2UgdG8gaGF2ZSBiZWVuIGFwcGxpZWQuXG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHByZXZTY3JvbGxUb3BSZWYuY3VycmVudCA9IGVsLnNjcm9sbFRvcDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbmFibGVkLCBvdmVyZmxvd1JlZiwgZWxlbWVudHMuZmxvYXRpbmcsIHNjcm9sbFJlZiwgb25DaGFuZ2VdKTtcbn1cblxuZnVuY3Rpb24gaXNQb2ludEluUG9seWdvbihwb2ludCwgcG9seWdvbikge1xuICBjb25zdCBbeCwgeV0gPSBwb2ludDtcbiAgbGV0IGlzSW5zaWRlID0gZmFsc2U7XG4gIGNvbnN0IGxlbmd0aCA9IHBvbHlnb24ubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IGxlbmd0aCAtIDE7IGkgPCBsZW5ndGg7IGogPSBpKyspIHtcbiAgICBjb25zdCBbeGksIHlpXSA9IHBvbHlnb25baV0gfHwgWzAsIDBdO1xuICAgIGNvbnN0IFt4aiwgeWpdID0gcG9seWdvbltqXSB8fCBbMCwgMF07XG4gICAgY29uc3QgaW50ZXJzZWN0ID0geWkgPj0geSAhPT0geWogPj0geSAmJiB4IDw9ICh4aiAtIHhpKSAqICh5IC0geWkpIC8gKHlqIC0geWkpICsgeGk7XG4gICAgaWYgKGludGVyc2VjdCkge1xuICAgICAgaXNJbnNpZGUgPSAhaXNJbnNpZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBpc0luc2lkZTtcbn1cbmZ1bmN0aW9uIGlzSW5zaWRlKHBvaW50LCByZWN0KSB7XG4gIHJldHVybiBwb2ludFswXSA+PSByZWN0LnggJiYgcG9pbnRbMF0gPD0gcmVjdC54ICsgcmVjdC53aWR0aCAmJiBwb2ludFsxXSA+PSByZWN0LnkgJiYgcG9pbnRbMV0gPD0gcmVjdC55ICsgcmVjdC5oZWlnaHQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHNhZmUgcG9seWdvbiBhcmVhIHRoYXQgdGhlIHVzZXIgY2FuIHRyYXZlcnNlIHdpdGhvdXQgY2xvc2luZyB0aGVcbiAqIGZsb2F0aW5nIGVsZW1lbnQgb25jZSBsZWF2aW5nIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VIb3ZlciNzYWZlcG9seWdvblxuICovXG5mdW5jdGlvbiBzYWZlUG9seWdvbihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIGJ1ZmZlciA9IDAuNSxcbiAgICBibG9ja1BvaW50ZXJFdmVudHMgPSBmYWxzZSxcbiAgICByZXF1aXJlSW50ZW50ID0gdHJ1ZVxuICB9ID0gb3B0aW9ucztcbiAgbGV0IHRpbWVvdXRJZDtcbiAgbGV0IGhhc0xhbmRlZCA9IGZhbHNlO1xuICBsZXQgbGFzdFggPSBudWxsO1xuICBsZXQgbGFzdFkgPSBudWxsO1xuICBsZXQgbGFzdEN1cnNvclRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgZnVuY3Rpb24gZ2V0Q3Vyc29yU3BlZWQoeCwgeSkge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgZWxhcHNlZFRpbWUgPSBjdXJyZW50VGltZSAtIGxhc3RDdXJzb3JUaW1lO1xuICAgIGlmIChsYXN0WCA9PT0gbnVsbCB8fCBsYXN0WSA9PT0gbnVsbCB8fCBlbGFwc2VkVGltZSA9PT0gMCkge1xuICAgICAgbGFzdFggPSB4O1xuICAgICAgbGFzdFkgPSB5O1xuICAgICAgbGFzdEN1cnNvclRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBkZWx0YVggPSB4IC0gbGFzdFg7XG4gICAgY29uc3QgZGVsdGFZID0geSAtIGxhc3RZO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWSk7XG4gICAgY29uc3Qgc3BlZWQgPSBkaXN0YW5jZSAvIGVsYXBzZWRUaW1lOyAvLyBweCAvIG1zXG5cbiAgICBsYXN0WCA9IHg7XG4gICAgbGFzdFkgPSB5O1xuICAgIGxhc3RDdXJzb3JUaW1lID0gY3VycmVudFRpbWU7XG4gICAgcmV0dXJuIHNwZWVkO1xuICB9XG4gIGNvbnN0IGZuID0gX3JlZiA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcGxhY2VtZW50LFxuICAgICAgZWxlbWVudHMsXG4gICAgICBvbkNsb3NlLFxuICAgICAgbm9kZUlkLFxuICAgICAgdHJlZVxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiBmdW5jdGlvbiBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBvbkNsb3NlKCk7XG4gICAgICB9XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIGlmICghZWxlbWVudHMuZG9tUmVmZXJlbmNlIHx8ICFlbGVtZW50cy5mbG9hdGluZyB8fCBwbGFjZW1lbnQgPT0gbnVsbCB8fCB4ID09IG51bGwgfHwgeSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2xpZW50WCxcbiAgICAgICAgY2xpZW50WVxuICAgICAgfSA9IGV2ZW50O1xuICAgICAgY29uc3QgY2xpZW50UG9pbnQgPSBbY2xpZW50WCwgY2xpZW50WV07XG4gICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQoZXZlbnQpO1xuICAgICAgY29uc3QgaXNMZWF2ZSA9IGV2ZW50LnR5cGUgPT09ICdtb3VzZWxlYXZlJztcbiAgICAgIGNvbnN0IGlzT3ZlckZsb2F0aW5nRWwgPSBjb250YWlucyhlbGVtZW50cy5mbG9hdGluZywgdGFyZ2V0KTtcbiAgICAgIGNvbnN0IGlzT3ZlclJlZmVyZW5jZUVsID0gY29udGFpbnMoZWxlbWVudHMuZG9tUmVmZXJlbmNlLCB0YXJnZXQpO1xuICAgICAgY29uc3QgcmVmUmVjdCA9IGVsZW1lbnRzLmRvbVJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHJlY3QgPSBlbGVtZW50cy5mbG9hdGluZy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHNpZGUgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgICAgIGNvbnN0IGN1cnNvckxlYXZlRnJvbVJpZ2h0ID0geCA+IHJlY3QucmlnaHQgLSByZWN0LndpZHRoIC8gMjtcbiAgICAgIGNvbnN0IGN1cnNvckxlYXZlRnJvbUJvdHRvbSA9IHkgPiByZWN0LmJvdHRvbSAtIHJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgIGNvbnN0IGlzT3ZlclJlZmVyZW5jZVJlY3QgPSBpc0luc2lkZShjbGllbnRQb2ludCwgcmVmUmVjdCk7XG4gICAgICBjb25zdCBpc0Zsb2F0aW5nV2lkZXIgPSByZWN0LndpZHRoID4gcmVmUmVjdC53aWR0aDtcbiAgICAgIGNvbnN0IGlzRmxvYXRpbmdUYWxsZXIgPSByZWN0LmhlaWdodCA+IHJlZlJlY3QuaGVpZ2h0O1xuICAgICAgY29uc3QgbGVmdCA9IChpc0Zsb2F0aW5nV2lkZXIgPyByZWZSZWN0IDogcmVjdCkubGVmdDtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gKGlzRmxvYXRpbmdXaWRlciA/IHJlZlJlY3QgOiByZWN0KS5yaWdodDtcbiAgICAgIGNvbnN0IHRvcCA9IChpc0Zsb2F0aW5nVGFsbGVyID8gcmVmUmVjdCA6IHJlY3QpLnRvcDtcbiAgICAgIGNvbnN0IGJvdHRvbSA9IChpc0Zsb2F0aW5nVGFsbGVyID8gcmVmUmVjdCA6IHJlY3QpLmJvdHRvbTtcbiAgICAgIGlmIChpc092ZXJGbG9hdGluZ0VsKSB7XG4gICAgICAgIGhhc0xhbmRlZCA9IHRydWU7XG4gICAgICAgIGlmICghaXNMZWF2ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzT3ZlclJlZmVyZW5jZUVsKSB7XG4gICAgICAgIGhhc0xhbmRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzT3ZlclJlZmVyZW5jZUVsICYmICFpc0xlYXZlKSB7XG4gICAgICAgIGhhc0xhbmRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUHJldmVudCBvdmVybGFwcGluZyBmbG9hdGluZyBlbGVtZW50IGZyb20gYmVpbmcgc3R1Y2sgaW4gYW4gb3Blbi1jbG9zZVxuICAgICAgLy8gbG9vcDogaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8xOTEwXG4gICAgICBpZiAoaXNMZWF2ZSAmJiBpc0VsZW1lbnQoZXZlbnQucmVsYXRlZFRhcmdldCkgJiYgY29udGFpbnMoZWxlbWVudHMuZmxvYXRpbmcsIGV2ZW50LnJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYW55IG5lc3RlZCBjaGlsZCBpcyBvcGVuLCBhYm9ydC5cbiAgICAgIGlmICh0cmVlICYmIGdldENoaWxkcmVuKHRyZWUubm9kZXNSZWYuY3VycmVudCwgbm9kZUlkKS5zb21lKF9yZWYyID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRleHQub3BlbjtcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIHBvaW50ZXIgaXMgbGVhdmluZyBmcm9tIHRoZSBvcHBvc2l0ZSBzaWRlLCB0aGUgXCJidWZmZXJcIiBsb2dpY1xuICAgICAgLy8gY3JlYXRlcyBhIHBvaW50IHdoZXJlIHRoZSBmbG9hdGluZyBlbGVtZW50IHJlbWFpbnMgb3BlbiwgYnV0IHNob3VsZCBiZVxuICAgICAgLy8gaWdub3JlZC5cbiAgICAgIC8vIEEgY29uc3RhbnQgb2YgMSBoYW5kbGVzIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycy5cbiAgICAgIGlmIChzaWRlID09PSAndG9wJyAmJiB5ID49IHJlZlJlY3QuYm90dG9tIC0gMSB8fCBzaWRlID09PSAnYm90dG9tJyAmJiB5IDw9IHJlZlJlY3QudG9wICsgMSB8fCBzaWRlID09PSAnbGVmdCcgJiYgeCA+PSByZWZSZWN0LnJpZ2h0IC0gMSB8fCBzaWRlID09PSAncmlnaHQnICYmIHggPD0gcmVmUmVjdC5sZWZ0ICsgMSkge1xuICAgICAgICByZXR1cm4gY2xvc2UoKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWdub3JlIHdoZW4gdGhlIGN1cnNvciBpcyB3aXRoaW4gdGhlIHJlY3Rhbmd1bGFyIHRyb3VnaCBiZXR3ZWVuIHRoZVxuICAgICAgLy8gdHdvIGVsZW1lbnRzLiBTaW5jZSB0aGUgdHJpYW5nbGUgaXMgY3JlYXRlZCBmcm9tIHRoZSBjdXJzb3IgcG9pbnQsXG4gICAgICAvLyB3aGljaCBjYW4gc3RhcnQgYmV5b25kIHRoZSByZWYgZWxlbWVudCdzIGVkZ2UsIHRyYXZlcnNpbmcgYmFjayBhbmRcbiAgICAgIC8vIGZvcnRoIGZyb20gdGhlIHJlZiB0byB0aGUgZmxvYXRpbmcgZWxlbWVudCBjYW4gY2F1c2UgaXQgdG8gY2xvc2UuIFRoaXNcbiAgICAgIC8vIGVuc3VyZXMgaXQgYWx3YXlzIHJlbWFpbnMgb3BlbiBpbiB0aGF0IGNhc2UuXG4gICAgICBsZXQgcmVjdFBvbHkgPSBbXTtcbiAgICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIHJlY3RQb2x5ID0gW1tsZWZ0LCByZWZSZWN0LnRvcCArIDFdLCBbbGVmdCwgcmVjdC5ib3R0b20gLSAxXSwgW3JpZ2h0LCByZWN0LmJvdHRvbSAtIDFdLCBbcmlnaHQsIHJlZlJlY3QudG9wICsgMV1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIHJlY3RQb2x5ID0gW1tsZWZ0LCByZWN0LnRvcCArIDFdLCBbbGVmdCwgcmVmUmVjdC5ib3R0b20gLSAxXSwgW3JpZ2h0LCByZWZSZWN0LmJvdHRvbSAtIDFdLCBbcmlnaHQsIHJlY3QudG9wICsgMV1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICByZWN0UG9seSA9IFtbcmVjdC5yaWdodCAtIDEsIGJvdHRvbV0sIFtyZWN0LnJpZ2h0IC0gMSwgdG9wXSwgW3JlZlJlY3QubGVmdCArIDEsIHRvcF0sIFtyZWZSZWN0LmxlZnQgKyAxLCBib3R0b21dXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIHJlY3RQb2x5ID0gW1tyZWZSZWN0LnJpZ2h0IC0gMSwgYm90dG9tXSwgW3JlZlJlY3QucmlnaHQgLSAxLCB0b3BdLCBbcmVjdC5sZWZ0ICsgMSwgdG9wXSwgW3JlY3QubGVmdCArIDEsIGJvdHRvbV1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZ2V0UG9seWdvbihfcmVmMykge1xuICAgICAgICBsZXQgW3gsIHldID0gX3JlZjM7XG4gICAgICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50T25lID0gW2lzRmxvYXRpbmdXaWRlciA/IHggKyBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyB4ICsgYnVmZmVyICogNCA6IHggLSBidWZmZXIgKiA0LCB5ICsgYnVmZmVyICsgMV07XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50VHdvID0gW2lzRmxvYXRpbmdXaWRlciA/IHggLSBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyB4ICsgYnVmZmVyICogNCA6IHggLSBidWZmZXIgKiA0LCB5ICsgYnVmZmVyICsgMV07XG4gICAgICAgICAgICAgIGNvbnN0IGNvbW1vblBvaW50cyA9IFtbcmVjdC5sZWZ0LCBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IHJlY3QuYm90dG9tIC0gYnVmZmVyIDogaXNGbG9hdGluZ1dpZGVyID8gcmVjdC5ib3R0b20gLSBidWZmZXIgOiByZWN0LnRvcF0sIFtyZWN0LnJpZ2h0LCBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IGlzRmxvYXRpbmdXaWRlciA/IHJlY3QuYm90dG9tIC0gYnVmZmVyIDogcmVjdC50b3AgOiByZWN0LmJvdHRvbSAtIGJ1ZmZlcl1dO1xuICAgICAgICAgICAgICByZXR1cm4gW2N1cnNvclBvaW50T25lLCBjdXJzb3JQb2ludFR3bywgLi4uY29tbW9uUG9pbnRzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludE9uZSA9IFtpc0Zsb2F0aW5nV2lkZXIgPyB4ICsgYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8geCArIGJ1ZmZlciAqIDQgOiB4IC0gYnVmZmVyICogNCwgeSAtIGJ1ZmZlcl07XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50VHdvID0gW2lzRmxvYXRpbmdXaWRlciA/IHggLSBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyB4ICsgYnVmZmVyICogNCA6IHggLSBidWZmZXIgKiA0LCB5IC0gYnVmZmVyXTtcbiAgICAgICAgICAgICAgY29uc3QgY29tbW9uUG9pbnRzID0gW1tyZWN0LmxlZnQsIGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8gcmVjdC50b3AgKyBidWZmZXIgOiBpc0Zsb2F0aW5nV2lkZXIgPyByZWN0LnRvcCArIGJ1ZmZlciA6IHJlY3QuYm90dG9tXSwgW3JlY3QucmlnaHQsIGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8gaXNGbG9hdGluZ1dpZGVyID8gcmVjdC50b3AgKyBidWZmZXIgOiByZWN0LmJvdHRvbSA6IHJlY3QudG9wICsgYnVmZmVyXV07XG4gICAgICAgICAgICAgIHJldHVybiBbY3Vyc29yUG9pbnRPbmUsIGN1cnNvclBvaW50VHdvLCAuLi5jb21tb25Qb2ludHNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludE9uZSA9IFt4ICsgYnVmZmVyICsgMSwgaXNGbG9hdGluZ1RhbGxlciA/IHkgKyBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tQm90dG9tID8geSArIGJ1ZmZlciAqIDQgOiB5IC0gYnVmZmVyICogNF07XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50VHdvID0gW3ggKyBidWZmZXIgKyAxLCBpc0Zsb2F0aW5nVGFsbGVyID8geSAtIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyB5ICsgYnVmZmVyICogNCA6IHkgLSBidWZmZXIgKiA0XTtcbiAgICAgICAgICAgICAgY29uc3QgY29tbW9uUG9pbnRzID0gW1tjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyByZWN0LnJpZ2h0IC0gYnVmZmVyIDogaXNGbG9hdGluZ1RhbGxlciA/IHJlY3QucmlnaHQgLSBidWZmZXIgOiByZWN0LmxlZnQsIHJlY3QudG9wXSwgW2N1cnNvckxlYXZlRnJvbUJvdHRvbSA/IGlzRmxvYXRpbmdUYWxsZXIgPyByZWN0LnJpZ2h0IC0gYnVmZmVyIDogcmVjdC5sZWZ0IDogcmVjdC5yaWdodCAtIGJ1ZmZlciwgcmVjdC5ib3R0b21dXTtcbiAgICAgICAgICAgICAgcmV0dXJuIFsuLi5jb21tb25Qb2ludHMsIGN1cnNvclBvaW50T25lLCBjdXJzb3JQb2ludFR3b107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludE9uZSA9IFt4IC0gYnVmZmVyLCBpc0Zsb2F0aW5nVGFsbGVyID8geSArIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyB5ICsgYnVmZmVyICogNCA6IHkgLSBidWZmZXIgKiA0XTtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRUd28gPSBbeCAtIGJ1ZmZlciwgaXNGbG9hdGluZ1RhbGxlciA/IHkgLSBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tQm90dG9tID8geSArIGJ1ZmZlciAqIDQgOiB5IC0gYnVmZmVyICogNF07XG4gICAgICAgICAgICAgIGNvbnN0IGNvbW1vblBvaW50cyA9IFtbY3Vyc29yTGVhdmVGcm9tQm90dG9tID8gcmVjdC5sZWZ0ICsgYnVmZmVyIDogaXNGbG9hdGluZ1RhbGxlciA/IHJlY3QubGVmdCArIGJ1ZmZlciA6IHJlY3QucmlnaHQsIHJlY3QudG9wXSwgW2N1cnNvckxlYXZlRnJvbUJvdHRvbSA/IGlzRmxvYXRpbmdUYWxsZXIgPyByZWN0LmxlZnQgKyBidWZmZXIgOiByZWN0LnJpZ2h0IDogcmVjdC5sZWZ0ICsgYnVmZmVyLCByZWN0LmJvdHRvbV1dO1xuICAgICAgICAgICAgICByZXR1cm4gW2N1cnNvclBvaW50T25lLCBjdXJzb3JQb2ludFR3bywgLi4uY29tbW9uUG9pbnRzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzUG9pbnRJblBvbHlnb24oW2NsaWVudFgsIGNsaWVudFldLCByZWN0UG9seSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0xhbmRlZCAmJiAhaXNPdmVyUmVmZXJlbmNlUmVjdCkge1xuICAgICAgICByZXR1cm4gY2xvc2UoKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNMZWF2ZSAmJiByZXF1aXJlSW50ZW50KSB7XG4gICAgICAgIGNvbnN0IGN1cnNvclNwZWVkID0gZ2V0Q3Vyc29yU3BlZWQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICAgIGNvbnN0IGN1cnNvclNwZWVkVGhyZXNob2xkID0gMC4xO1xuICAgICAgICBpZiAoY3Vyc29yU3BlZWQgIT09IG51bGwgJiYgY3Vyc29yU3BlZWQgPCBjdXJzb3JTcGVlZFRocmVzaG9sZCkge1xuICAgICAgICAgIHJldHVybiBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzUG9pbnRJblBvbHlnb24oW2NsaWVudFgsIGNsaWVudFldLCBnZXRQb2x5Z29uKFt4LCB5XSkpKSB7XG4gICAgICAgIGNsb3NlKCk7XG4gICAgICB9IGVsc2UgaWYgKCFoYXNMYW5kZWQgJiYgcmVxdWlyZUludGVudCkge1xuICAgICAgICB0aW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dChjbG9zZSwgNDApO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIGZuLl9fb3B0aW9ucyA9IHtcbiAgICBibG9ja1BvaW50ZXJFdmVudHNcbiAgfTtcbiAgcmV0dXJuIGZuO1xufVxuXG5leHBvcnQgeyBDb21wb3NpdGUsIENvbXBvc2l0ZUl0ZW0sIEZsb2F0aW5nQXJyb3csIEZsb2F0aW5nRGVsYXlHcm91cCwgRmxvYXRpbmdGb2N1c01hbmFnZXIsIEZsb2F0aW5nTGlzdCwgRmxvYXRpbmdOb2RlLCBGbG9hdGluZ092ZXJsYXksIEZsb2F0aW5nUG9ydGFsLCBGbG9hdGluZ1RyZWUsIGlubmVyLCBzYWZlUG9seWdvbiwgdXNlQ2xpY2ssIHVzZUNsaWVudFBvaW50LCB1c2VEZWxheUdyb3VwLCB1c2VEZWxheUdyb3VwQ29udGV4dCwgdXNlRGlzbWlzcywgdXNlRmxvYXRpbmcsIHVzZUZsb2F0aW5nTm9kZUlkLCB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCwgdXNlRmxvYXRpbmdQb3J0YWxOb2RlLCB1c2VGbG9hdGluZ1RyZWUsIHVzZUZvY3VzLCB1c2VIb3ZlciwgdXNlSWQsIHVzZUlubmVyT2Zmc2V0LCB1c2VJbnRlcmFjdGlvbnMsIHVzZUxpc3RJdGVtLCB1c2VMaXN0TmF2aWdhdGlvbiwgdXNlTWVyZ2VSZWZzLCB1c2VSb2xlLCB1c2VUcmFuc2l0aW9uU3RhdHVzLCB1c2VUcmFuc2l0aW9uU3R5bGVzLCB1c2VUeXBlYWhlYWQgfTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsInN0b3BFdmVudCIsImdldERvY3VtZW50IiwiaXNNb3VzZUxpa2VQb2ludGVyVHlwZSIsImNvbnRhaW5zIiwiYWN0aXZlRWxlbWVudCIsImlzU2FmYXJpIiwiaXNUeXBlYWJsZUNvbWJvYm94IiwiaXNWaXJ0dWFsQ2xpY2siLCJpc1ZpcnR1YWxQb2ludGVyRXZlbnQiLCJnZXRUYXJnZXQiLCJnZXRQbGF0Zm9ybSIsImlzVHlwZWFibGVFbGVtZW50IiwiaXNSZWFjdEV2ZW50IiwiaXNSb290RWxlbWVudCIsImlzRXZlbnRUYXJnZXRXaXRoaW4iLCJpc01hYyIsImdldFVzZXJBZ2VudCIsImZsb29yIiwicGxhdGZvcm0iLCJnZXRPdmVyZmxvd0FuY2VzdG9ycyIsInVzZUZsb2F0aW5nIiwidXNlRmxvYXRpbmckMSIsIm9mZnNldCIsImRldGVjdE92ZXJmbG93IiwiYXJyb3ciLCJhdXRvUGxhY2VtZW50IiwiYXV0b1VwZGF0ZSIsImNvbXB1dGVQb3NpdGlvbiIsImZsaXAiLCJoaWRlIiwiaW5saW5lIiwibGltaXRTaGlmdCIsInNoaWZ0Iiwic2l6ZSIsImlzRWxlbWVudCIsImlzSFRNTEVsZW1lbnQiLCJnZXROb2RlTmFtZSIsImdldFdpbmRvdyIsImlzTGFzdFRyYXZlcnNhYmxlTm9kZSIsImdldFBhcmVudE5vZGUiLCJnZXRDb21wdXRlZFN0eWxlIiwidGFiYmFibGUiLCJjcmVhdGVQb3J0YWwiLCJmbHVzaFN5bmMiLCJ1c2VNZXJnZVJlZnMiLCJyZWZzIiwidXNlTWVtbyIsImV2ZXJ5IiwicmVmIiwidmFsdWUiLCJmb3JFYWNoIiwiY3VycmVudCIsInVzZUluc2VydGlvbkVmZmVjdCIsInRvU3RyaW5nIiwidXNlU2FmZUluc2VydGlvbkVmZmVjdCIsImZuIiwidXNlRWZmZWN0RXZlbnQiLCJjYWxsYmFjayIsIkVycm9yIiwidXNlQ2FsbGJhY2siLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJncyIsIkFycmF5IiwiX2tleSIsIkFSUk9XX1VQIiwiQVJST1dfRE9XTiIsIkFSUk9XX0xFRlQiLCJBUlJPV19SSUdIVCIsImlzRGlmZmVyZW50Um93IiwiaW5kZXgiLCJjb2xzIiwicHJldlJvdyIsIk1hdGgiLCJpc0luZGV4T3V0T2ZCb3VuZHMiLCJsaXN0UmVmIiwiZ2V0TWluSW5kZXgiLCJkaXNhYmxlZEluZGljZXMiLCJmaW5kTm9uRGlzYWJsZWRJbmRleCIsImdldE1heEluZGV4IiwiZGVjcmVtZW50Iiwic3RhcnRpbmdJbmRleCIsIl90ZW1wIiwiYW1vdW50IiwibGlzdCIsImlzRGlzYWJsZWRJbmRleCIsImluY2x1ZGVzIiwiZWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsImdldEdyaWROYXZpZ2F0ZWRJbmRleCIsImVsZW1lbnRzUmVmIiwiX3JlZiIsImV2ZW50Iiwib3JpZW50YXRpb24iLCJsb29wIiwibWluSW5kZXgiLCJtYXhJbmRleCIsInByZXZJbmRleCIsInN0b3AiLCJuZXh0SW5kZXgiLCJrZXkiLCJjb2wiLCJtYXhDb2wiLCJsYXN0Um93IiwiYnVpbGRDZWxsTWFwIiwic2l6ZXMiLCJkZW5zZSIsImNlbGxNYXAiLCJzdGFydEluZGV4IiwiX3JlZjIiLCJ3aWR0aCIsImhlaWdodCIsIml0ZW1QbGFjZWQiLCJ0YXJnZXRDZWxscyIsImkiLCJqIiwicHVzaCIsImNlbGwiLCJnZXRDZWxsSW5kZXhPZkNvcm5lciIsImNvcm5lciIsImZpcnN0Q2VsbEluZGV4IiwiaW5kZXhPZiIsImxhc3RJbmRleE9mIiwiZ2V0Q2VsbEluZGljZXMiLCJpbmRpY2VzIiwiZmxhdE1hcCIsImNlbGxJbmRleCIsInJhZklkIiwiZW5xdWV1ZUZvY3VzIiwiZWwiLCJvcHRpb25zIiwicHJldmVudFNjcm9sbCIsImNhbmNlbFByZXZpb3VzIiwic3luYyIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiZXhlYyIsImZvY3VzIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZG9jdW1lbnQiLCJzb3J0QnlEb2N1bWVudFBvc2l0aW9uIiwiYSIsImIiLCJwb3NpdGlvbiIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiTm9kZSIsIkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyIsIkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSIsIkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyIsIkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5TIiwiYXJlTWFwc0VxdWFsIiwibWFwMSIsIm1hcDIiLCJlbnRyaWVzIiwiZ2V0IiwiRmxvYXRpbmdMaXN0Q29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJyZWdpc3RlciIsInVucmVnaXN0ZXIiLCJtYXAiLCJNYXAiLCJGbG9hdGluZ0xpc3QiLCJjaGlsZHJlbiIsImxhYmVsc1JlZiIsInNldE1hcCIsInVzZVN0YXRlIiwibm9kZSIsInByZXZNYXAiLCJzZXQiLCJkZWxldGUiLCJuZXdNYXAiLCJub2RlcyIsImZyb20iLCJrZXlzIiwic29ydCIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsInVzZUxpc3RJdGVtIiwibGFiZWwiLCJpbmRleCQxIiwic2V0SW5kZXgiLCJjb21wb25lbnRSZWYiLCJ1c2VDb250ZXh0IiwiX25vZGUkdGV4dENvbnRlbnQiLCJpc0xhYmVsRGVmaW5lZCIsInVuZGVmaW5lZCIsInRleHRDb250ZW50IiwicmVuZGVySnN4IiwicmVuZGVyIiwiY29tcHV0ZWRQcm9wcyIsImNsb25lRWxlbWVudCIsIkNvbXBvc2l0ZUNvbnRleHQiLCJhY3RpdmVJbmRleCIsIm9uTmF2aWdhdGUiLCJob3Jpem9udGFsS2V5cyIsInZlcnRpY2FsS2V5cyIsImFsbEtleXMiLCJDb21wb3NpdGUiLCJmb3J3YXJkUmVmIiwiZm9yd2FyZGVkUmVmIiwiZXh0ZXJuYWxBY3RpdmVJbmRleCIsImV4dGVybmFsU2V0QWN0aXZlSW5kZXgiLCJpdGVtU2l6ZXMiLCJwcm9wcyIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsIl9leGNsdWRlZCIsImludGVybmFsQWN0aXZlSW5kZXgiLCJpbnRlcm5hbFNldEFjdGl2ZUluZGV4IiwicmVuZGVyRWxlbWVudFByb3BzIiwiY29udGV4dFZhbHVlIiwiaXNHcmlkIiwiaGFuZGxlS2V5RG93biIsIm1pbkdyaWRJbmRleCIsImZpbmRJbmRleCIsIm1heEdyaWRJbmRleCIsInJlZHVjZSIsImZvdW5kSW5kZXgiLCJpdGVtSW5kZXgiLCJ0b0VuZEtleXMiLCJob3Jpem9udGFsIiwidmVydGljYWwiLCJib3RoIiwidG9TdGFydEtleXMiLCJwcmV2ZW50ZWRLZXlzIiwic3RvcFByb3BhZ2F0aW9uIiwicHJldmVudERlZmF1bHQiLCJxdWV1ZU1pY3JvdGFzayIsIl9vYmplY3RTcHJlYWQiLCJvbktleURvd24iLCJlIiwiQ29tcG9zaXRlSXRlbSIsIl9leGNsdWRlZDIiLCJtZXJnZWRSZWYiLCJpc0FjdGl2ZSIsInRhYkluZGV4Iiwib25Gb2N1cyIsIl9leHRlbmRzIiwiT2JqZWN0IiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsInNvdXJjZSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5Iiwic2VydmVySGFuZG9mZkNvbXBsZXRlIiwiY291bnQiLCJnZW5JZCIsInVzZUZsb2F0aW5nSWQiLCJpZCIsInNldElkIiwidXNlUmVhY3RJZCIsInVzZUlkIiwiRmxvYXRpbmdBcnJvdyIsImNvbnRleHQiLCJwbGFjZW1lbnQiLCJlbGVtZW50cyIsImZsb2F0aW5nIiwibWlkZGxld2FyZURhdGEiLCJ0aXBSYWRpdXMiLCJzdHJva2VXaWR0aCIsInN0YXRpY09mZnNldCIsInN0cm9rZSIsImQiLCJzdHlsZSIsInRyYW5zZm9ybSIsInJlc3RTdHlsZSIsIl9leGNsdWRlZDMiLCJyZXN0IiwiX2V4Y2x1ZGVkNCIsImNvbnNvbGUiLCJ3YXJuIiwiY2xpcFBhdGhJZCIsImhhbGZTdHJva2VXaWR0aCIsInN2Z1giLCJzdmdZIiwic2lkZSIsImFsaWdubWVudCIsInNwbGl0IiwiaXNSVEwiLCJpc0N1c3RvbVNoYXBlIiwiaXNWZXJ0aWNhbFNpZGUiLCJ5T2Zmc2V0UHJvcCIsInhPZmZzZXRQcm9wIiwiYXJyb3dYIiwieCIsImFycm93WSIsInkiLCJkVmFsdWUiLCJyb3RhdGlvbiIsInRvcCIsImxlZnQiLCJib3R0b20iLCJyaWdodCIsInZpZXdCb3giLCJwb2ludGVyRXZlbnRzIiwiY2xpcFBhdGgiLCJmaWxsIiwiY3JlYXRlUHViU3ViIiwiZW1pdCIsImRhdGEiLCJfbWFwJGdldCIsImhhbmRsZXIiLCJvbiIsImxpc3RlbmVyIiwib2ZmIiwiX21hcCRnZXQyIiwiZmlsdGVyIiwibCIsIkZsb2F0aW5nTm9kZUNvbnRleHQiLCJGbG9hdGluZ1RyZWVDb250ZXh0IiwidXNlRmxvYXRpbmdQYXJlbnROb2RlSWQiLCJfUmVhY3QkdXNlQ29udGV4dCIsInVzZUZsb2F0aW5nVHJlZSIsInVzZUZsb2F0aW5nTm9kZUlkIiwiY3VzdG9tUGFyZW50SWQiLCJ0cmVlIiwicmVhY3RQYXJlbnRJZCIsInBhcmVudElkIiwiYWRkTm9kZSIsInJlbW92ZU5vZGUiLCJGbG9hdGluZ05vZGUiLCJGbG9hdGluZ1RyZWUiLCJub2Rlc1JlZiIsIm4iLCJldmVudHMiLCJjcmVhdGVBdHRyaWJ1dGUiLCJuYW1lIiwidXNlTGF0ZXN0UmVmIiwic2FmZVBvbHlnb25JZGVudGlmaWVyIiwiZ2V0RGVsYXkiLCJwcm9wIiwicG9pbnRlclR5cGUiLCJ1c2VIb3ZlciIsIm9wZW4iLCJvbk9wZW5DaGFuZ2UiLCJkYXRhUmVmIiwiZG9tUmVmZXJlbmNlIiwiZW5hYmxlZCIsImRlbGF5IiwiaGFuZGxlQ2xvc2UiLCJtb3VzZU9ubHkiLCJyZXN0TXMiLCJtb3ZlIiwiaGFuZGxlQ2xvc2VSZWYiLCJkZWxheVJlZiIsInBvaW50ZXJUeXBlUmVmIiwidGltZW91dFJlZiIsImhhbmRsZXJSZWYiLCJyZXN0VGltZW91dFJlZiIsImJsb2NrTW91c2VNb3ZlUmVmIiwicGVyZm9ybWVkUG9pbnRlckV2ZW50c011dGF0aW9uUmVmIiwidW5iaW5kTW91c2VNb3ZlUmVmIiwiaXNIb3Zlck9wZW4iLCJfZGF0YVJlZiRjdXJyZW50JG9wZW4iLCJ0eXBlIiwib3BlbkV2ZW50IiwiY2xlYXJUaW1lb3V0Iiwib25MZWF2ZSIsImh0bWwiLCJkb2N1bWVudEVsZW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNsb3NlV2l0aERlbGF5IiwicnVuRWxzZUJyYW5jaCIsInJlYXNvbiIsImNsb3NlRGVsYXkiLCJzZXRUaW1lb3V0IiwiY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIiLCJjbGVhclBvaW50ZXJFdmVudHMiLCJib2R5IiwicmVtb3ZlQXR0cmlidXRlIiwiaXNDbGlja0xpa2VPcGVuRXZlbnQiLCJvbk1vdXNlRW50ZXIiLCJvcGVuRGVsYXkiLCJvbk1vdXNlTGVhdmUiLCJkb2MiLCJjbGllbnRYIiwiY2xpZW50WSIsIm9uQ2xvc2UiLCJzaG91bGRDbG9zZSIsInJlbGF0ZWRUYXJnZXQiLCJvblNjcm9sbE1vdXNlTGVhdmUiLCJvbmNlIiwiX2hhbmRsZUNsb3NlUmVmJGN1cnJlIiwiX19vcHRpb25zIiwiYmxvY2tQb2ludGVyRXZlbnRzIiwic2V0QXR0cmlidXRlIiwiX3RyZWUkbm9kZXNSZWYkY3VycmVuIiwicGFyZW50RmxvYXRpbmciLCJmaW5kIiwic2V0UG9pbnRlclJlZiIsInJlZmVyZW5jZSIsIm9uUG9pbnRlckRvd24iLCJvblBvaW50ZXJFbnRlciIsIm9uTW91c2VNb3ZlIiwibmF0aXZlRXZlbnQiLCJGbG9hdGluZ0RlbGF5R3JvdXBDb250ZXh0IiwiaW5pdGlhbERlbGF5IiwidGltZW91dE1zIiwiY3VycmVudElkIiwic2V0Q3VycmVudElkIiwic2V0U3RhdGUiLCJpc0luc3RhbnRQaGFzZSIsInVzZURlbGF5R3JvdXBDb250ZXh0IiwiRmxvYXRpbmdEZWxheUdyb3VwIiwic3RhdGUiLCJ1c2VSZWR1Y2VyIiwicHJldiIsIm5leHQiLCJpbml0aWFsQ3VycmVudElkUmVmIiwidXNlRGVsYXlHcm91cCIsIl9yZWYzIiwiY2xvc2UiLCJ1bnNldCIsInRpbWVvdXQiLCJ3aW5kb3ciLCJnZXRBbmNlc3RvcnMiLCJfbm9kZXMkZmluZCIsImFsbEFuY2VzdG9ycyIsImN1cnJlbnRQYXJlbnRJZCIsImN1cnJlbnROb2RlIiwiY29uY2F0IiwiZ2V0Q2hpbGRyZW4iLCJhbGxDaGlsZHJlbiIsIl9ub2RlJGNvbnRleHQiLCJjdXJyZW50Q2hpbGRyZW4iLCJfY3VycmVudENoaWxkcmVuIiwic29tZSIsIl9ub2RlJGNvbnRleHQyIiwiZ2V0RGVlcGVzdE5vZGUiLCJkZWVwZXN0Tm9kZUlkIiwibWF4RGVwdGgiLCJmaW5kRGVlcGVzdCIsIm5vZGVJZCIsImRlcHRoIiwiY2hpbGQiLCJjb3VudGVyTWFwIiwiV2Vha01hcCIsInVuY29udHJvbGxlZEVsZW1lbnRzU2V0IiwiV2Vha1NldCIsIm1hcmtlck1hcCIsImxvY2tDb3VudCIsInN1cHBvcnRzSW5lcnQiLCJIVE1MRWxlbWVudCIsInVud3JhcEhvc3QiLCJob3N0IiwicGFyZW50Tm9kZSIsImNvcnJlY3RFbGVtZW50cyIsInBhcmVudCIsInRhcmdldHMiLCJjb3JyZWN0ZWRUYXJnZXQiLCJhcHBseUF0dHJpYnV0ZVRvT3RoZXJzIiwidW5jb3JyZWN0ZWRBdm9pZEVsZW1lbnRzIiwiYXJpYUhpZGRlbiIsImluZXJ0IiwibWFya2VyTmFtZSIsImNvbnRyb2xBdHRyaWJ1dGUiLCJhdm9pZEVsZW1lbnRzIiwiZWxlbWVudHNUb0tlZXAiLCJTZXQiLCJlbGVtZW50c1RvU3RvcCIsImhpZGRlbkVsZW1lbnRzIiwibWFya2VyQ291bnRlciIsImtlZXAiLCJkZWVwIiwiY2xlYXIiLCJoYXMiLCJhZGQiLCJhdHRyIiwiYWxyZWFkeUhpZGRlbiIsImNvdW50ZXJWYWx1ZSIsIm1hcmtlclZhbHVlIiwibWFya090aGVycyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJnZXRUYWJiYWJsZU9wdGlvbnMiLCJnZXRTaGFkb3dSb290IiwiZGlzcGxheUNoZWNrIiwiUmVzaXplT2JzZXJ2ZXIiLCJnZXRUYWJiYWJsZUluIiwiY29udGFpbmVyIiwiZGlyZWN0aW9uIiwiYWxsVGFiYmFibGUiLCJyZXZlcnNlIiwibmV4dFRhYmJhYmxlRWxlbWVudHMiLCJzbGljZSIsImdldE5leHRUYWJiYWJsZSIsImdldFByZXZpb3VzVGFiYmFibGUiLCJpc091dHNpZGVFdmVudCIsImNvbnRhaW5lckVsZW1lbnQiLCJjdXJyZW50VGFyZ2V0IiwiZGlzYWJsZUZvY3VzSW5zaWRlIiwidGFiYmFibGVFbGVtZW50cyIsImRhdGFzZXQiLCJ0YWJpbmRleCIsImVuYWJsZUZvY3VzSW5zaWRlIiwiSElEREVOX1NUWUxFUyIsImJvcmRlciIsImNsaXAiLCJtYXJnaW4iLCJvdmVyZmxvdyIsInBhZGRpbmciLCJ3aGl0ZVNwYWNlIiwidGltZW91dElkIiwic2V0QWN0aXZlRWxlbWVudE9uVGFiIiwiRm9jdXNHdWFyZCIsInJvbGUiLCJzZXRSb2xlIiwicmVzdFByb3BzIiwiUG9ydGFsQ29udGV4dCIsInVzZUZsb2F0aW5nUG9ydGFsTm9kZSIsInJvb3QiLCJwb3J0YWxOb2RlIiwic2V0UG9ydGFsTm9kZSIsInVuaXF1ZUlkIiwicG9ydGFsQ29udGV4dCIsInVzZVBvcnRhbENvbnRleHQiLCJwb3J0YWxOb2RlUmVmIiwicmVtb3ZlIiwiZXhpc3RpbmdJZFJvb3QiLCJnZXRFbGVtZW50QnlJZCIsInN1YlJvb3QiLCJhcHBlbmRDaGlsZCIsImlkV3JhcHBlciIsIkZsb2F0aW5nUG9ydGFsIiwicHJlc2VydmVUYWJPcmRlciIsImZvY3VzTWFuYWdlclN0YXRlIiwic2V0Rm9jdXNNYW5hZ2VyU3RhdGUiLCJiZWZvcmVPdXRzaWRlUmVmIiwiYWZ0ZXJPdXRzaWRlUmVmIiwiYmVmb3JlSW5zaWRlUmVmIiwiYWZ0ZXJJbnNpZGVSZWYiLCJzaG91bGRSZW5kZXJHdWFyZHMiLCJtb2RhbCIsImZvY3VzaW5nIiwibWFuYWdlRm9jdXMiLCJfYmVmb3JlSW5zaWRlUmVmJGN1cnIiLCJwcmV2VGFiYmFibGUiLCJfYWZ0ZXJJbnNpZGVSZWYkY3VycmUiLCJuZXh0VGFiYmFibGUiLCJjbG9zZU9uRm9jdXNPdXQiLCJMSVNUX0xJTUlUIiwicHJldmlvdXNseUZvY3VzZWRFbGVtZW50cyIsImFkZFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCIsImlzQ29ubmVjdGVkIiwiZ2V0UHJldmlvdXNseUZvY3VzZWRFbGVtZW50IiwiVmlzdWFsbHlIaWRkZW5EaXNtaXNzIiwiRmxvYXRpbmdGb2N1c01hbmFnZXIiLCJkaXNhYmxlZCIsIm9yZGVyIiwiZ3VhcmRzIiwiX2d1YXJkcyIsImluaXRpYWxGb2N1cyIsInJldHVybkZvY3VzIiwidmlzdWFsbHlIaWRkZW5EaXNtaXNzIiwiaWdub3JlSW5pdGlhbEZvY3VzIiwiaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94Iiwib3JkZXJSZWYiLCJpbml0aWFsRm9jdXNSZWYiLCJyZXR1cm5Gb2N1c1JlZiIsInN0YXJ0RGlzbWlzc0J1dHRvblJlZiIsImVuZERpc21pc3NCdXR0b25SZWYiLCJwcmV2ZW50UmV0dXJuRm9jdXNSZWYiLCJpc1BvaW50ZXJEb3duUmVmIiwiaXNJbnNpZGVQb3J0YWwiLCJnZXRUYWJiYWJsZUNvbnRlbnQiLCJnZXRUYWJiYWJsZUVsZW1lbnRzIiwiY29udGVudCIsIkJvb2xlYW4iLCJmbGF0IiwiZWxzIiwic2hpZnRLZXkiLCJoYW5kbGVQb2ludGVyRG93biIsImhhbmRsZUZvY3VzT3V0c2lkZSIsIm1vdmVkVG9VbnJlbGF0ZWROb2RlIiwiX25vZGUkY29udGV4dDMiLCJfbm9kZSRjb250ZXh0NCIsIl9wb3J0YWxDb250ZXh0JHBvcnRhbCIsInBvcnRhbE5vZGVzIiwiaW5zaWRlRWxlbWVudHMiLCJjbGVhbnVwIiwicHJldmlvdXNseUZvY3VzZWRFbGVtZW50IiwiZm9jdXNhYmxlRWxlbWVudHMiLCJpbml0aWFsRm9jdXNWYWx1ZSIsImVsVG9Gb2N1cyIsImZvY3VzQWxyZWFkeUluc2lkZUZsb2F0aW5nRWwiLCJwcmV2ZW50UmV0dXJuRm9jdXNTY3JvbGwiLCJjb250ZXh0RGF0YSIsIm5lc3RlZCIsImFjdGl2ZUVsIiwiaXNGb2N1c0luc2lkZUZsb2F0aW5nVHJlZSIsIl9ub2RlJGNvbnRleHQ1Iiwic2hvdWxkRm9jdXNSZWZlcmVuY2UiLCJyZXR1cm5FbGVtZW50IiwiTXV0YXRpb25PYnNlcnZlciIsImhhbmRsZU11dGF0aW9uIiwib2JzZXJ2ZXIiLCJvYnNlcnZlIiwiY2hpbGRMaXN0Iiwic3VidHJlZSIsImF0dHJpYnV0ZXMiLCJkaXNjb25uZWN0IiwicmVuZGVyRGlzbWlzc0J1dHRvbiIsImxvY2F0aW9uIiwib25DbGljayIsIkZyYWdtZW50IiwiX3BvcnRhbENvbnRleHQkYmVmb3JlIiwiX3BvcnRhbENvbnRleHQkYWZ0ZXJPIiwiYWN0aXZlTG9ja3MiLCJGbG9hdGluZ092ZXJsYXkiLCJsb2NrU2Nyb2xsIiwiX2V4Y2x1ZGVkNSIsImxvY2tJZCIsImlzSU9TIiwidGVzdCIsImJvZHlTdHlsZSIsInNjcm9sbGJhclgiLCJyb3VuZCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNjcm9sbExlZnQiLCJwYWRkaW5nUHJvcCIsInNjcm9sbGJhcldpZHRoIiwiaW5uZXJXaWR0aCIsImNsaWVudFdpZHRoIiwic2Nyb2xsWCIsInBhcnNlRmxvYXQiLCJwYWdlWE9mZnNldCIsInNjcm9sbFkiLCJwYWdlWU9mZnNldCIsIl93aW5kb3ckdmlzdWFsVmlld3BvciIsIl93aW5kb3ckdmlzdWFsVmlld3BvcjIiLCJvZmZzZXRMZWZ0IiwidmlzdWFsVmlld3BvcnQiLCJvZmZzZXRUb3AiLCJzY3JvbGxUbyIsImlzQnV0dG9uVGFyZ2V0IiwidGFnTmFtZSIsImlzU3BhY2VJZ25vcmVkIiwidXNlQ2xpY2siLCJldmVudE9wdGlvbiIsInRvZ2dsZSIsImlnbm9yZU1vdXNlIiwia2V5Ym9hcmRIYW5kbGVycyIsImRpZEtleURvd25SZWYiLCJvbk1vdXNlRG93biIsImJ1dHRvbiIsImRlZmF1bHRQcmV2ZW50ZWQiLCJvbktleVVwIiwiY3JlYXRlVmlydHVhbEVsZW1lbnQiLCJkb21SZWYiLCJvZmZzZXRYIiwib2Zmc2V0WSIsImlzQXV0b1VwZGF0ZUV2ZW50IiwiY29udGV4dEVsZW1lbnQiLCJfZG9tUmVmJGN1cnJlbnQiLCJfZGF0YSRkYXRhUmVmJGN1cnJlbnQiLCJkb21SZWN0IiwiaXNYQXhpcyIsImF4aXMiLCJpc1lBeGlzIiwiY2FuVHJhY2tDdXJzb3JPbkF1dG9VcGRhdGUiLCJpc01vdXNlQmFzZWRFdmVudCIsInVzZUNsaWVudFBvaW50IiwiaW5pdGlhbFJlZiIsImNsZWFudXBMaXN0ZW5lclJlZiIsInNldFBvaW50ZXJUeXBlIiwicmVhY3RpdmUiLCJzZXRSZWFjdGl2ZSIsInNldFJlZmVyZW5jZSIsInNldFBvc2l0aW9uUmVmZXJlbmNlIiwiaGFuZGxlUmVmZXJlbmNlRW50ZXJPck1vdmUiLCJvcGVuQ2hlY2siLCJhZGRMaXN0ZW5lciIsIndpbiIsImhhbmRsZU1vdXNlTW92ZSIsInNldFBvaW50ZXJUeXBlUmVmIiwiYnViYmxlSGFuZGxlcktleXMiLCJwb2ludGVyZG93biIsIm1vdXNlZG93biIsImNsaWNrIiwiY2FwdHVyZUhhbmRsZXJLZXlzIiwibm9ybWFsaXplUHJvcCIsIm5vcm1hbGl6YWJsZSIsIl9ub3JtYWxpemFibGUkZXNjYXBlSyIsIl9ub3JtYWxpemFibGUkb3V0c2lkZSIsImVzY2FwZUtleSIsIm91dHNpZGVQcmVzcyIsInVzZURpc21pc3MiLCJ1bnN0YWJsZV9vdXRzaWRlUHJlc3MiLCJvdXRzaWRlUHJlc3NFdmVudCIsInJlZmVyZW5jZVByZXNzIiwicmVmZXJlbmNlUHJlc3NFdmVudCIsImFuY2VzdG9yU2Nyb2xsIiwiYnViYmxlcyIsImNhcHR1cmUiLCJvdXRzaWRlUHJlc3NGbiIsImluc2lkZVJlYWN0VHJlZVJlZiIsImVuZGVkT3JTdGFydGVkSW5zaWRlUmVmIiwiZXNjYXBlS2V5QnViYmxlcyIsIm91dHNpZGVQcmVzc0J1YmJsZXMiLCJlc2NhcGVLZXlDYXB0dXJlIiwib3V0c2lkZVByZXNzQ2FwdHVyZSIsImNsb3NlT25Fc2NhcGVLZXlEb3duIiwic2hvdWxkRGlzbWlzcyIsIl9jaGlsZCRjb250ZXh0IiwiX19lc2NhcGVLZXlCdWJibGVzIiwiY2xvc2VPbkVzY2FwZUtleURvd25DYXB0dXJlIiwiX2dldFRhcmdldDIiLCJfZ2V0VGFyZ2V0IiwiY2xvc2VPblByZXNzT3V0c2lkZSIsImluc2lkZVJlYWN0VHJlZSIsImVuZGVkT3JTdGFydGVkSW5zaWRlIiwiaW5lcnRTZWxlY3RvciIsIm1hcmtlcnMiLCJ0YXJnZXRSb290QW5jZXN0b3IiLCJuZXh0UGFyZW50IiwibWFya2VyIiwiY2FuU2Nyb2xsWCIsInNjcm9sbFdpZHRoIiwiY2FuU2Nyb2xsWSIsImNsaWVudEhlaWdodCIsInNjcm9sbEhlaWdodCIsInhDb25kIiwib2Zmc2V0V2lkdGgiLCJ0YXJnZXRJc0luc2lkZUNoaWxkcmVuIiwiX2NoaWxkJGNvbnRleHQyIiwiX19vdXRzaWRlUHJlc3NCdWJibGVzIiwiY2xvc2VPblByZXNzT3V0c2lkZUNhcHR1cmUiLCJfZ2V0VGFyZ2V0NCIsIl9nZXRUYXJnZXQzIiwib25TY3JvbGwiLCJhbmNlc3RvcnMiLCJhbmNlc3RvciIsIl9kb2MkZGVmYXVsdFZpZXciLCJkZWZhdWx0VmlldyIsInBhc3NpdmUiLCJvbk1vdXNlVXAiLCJkZXZNZXNzYWdlU2V0IiwiX29wdGlvbnMkZWxlbWVudHMyIiwidW5zdGFibGVfb25PcGVuQ2hhbmdlIiwiX29wdGlvbnMkZWxlbWVudHMiLCJlcnIiLCJfZGV2TWVzc2FnZVNldCIsIl9kZXZNZXNzYWdlU2V0MiIsImVycm9yIiwiX2RvbVJlZmVyZW5jZSIsInNldERvbVJlZmVyZW5jZSIsImRvbVJlZmVyZW5jZVJlZiIsImZsb2F0aW5nSWQiLCJwb3NpdGlvblJlZmVyZW5jZSIsInVzZUZvY3VzIiwidmlzaWJsZU9ubHkiLCJibG9ja0ZvY3VzUmVmIiwia2V5Ym9hcmRNb2RhbGl0eVJlZiIsIm9uQmx1ciIsIm1hdGNoZXMiLCJtb3ZlZFRvRm9jdXNHdWFyZCIsIm93bmVyRG9jdW1lbnQiLCJBQ1RJVkVfS0VZIiwiU0VMRUNURURfS0VZIiwibWVyZ2VQcm9wcyIsInVzZXJQcm9wcyIsInByb3BzTGlzdCIsImVsZW1lbnRLZXkiLCJpc0l0ZW0iLCJkb21Vc2VyUHJvcHMiLCJfIiwiX18iLCJ2YWxpZFByb3BzIiwiX3RvUHJvcGVydHlLZXkiLCJwcm9wc09yR2V0UHJvcHMiLCJhY2MiLCJ2YWwiLCJ1c2VJbnRlcmFjdGlvbnMiLCJkZXBzIiwiZ2V0UmVmZXJlbmNlUHJvcHMiLCJnZXRGbG9hdGluZ1Byb3BzIiwiZ2V0SXRlbVByb3BzIiwiaXRlbSIsImlzUHJldmVudFNjcm9sbFN1cHBvcnRlZCIsImRvU3dpdGNoIiwiaXNNYWluT3JpZW50YXRpb25LZXkiLCJpc01haW5PcmllbnRhdGlvblRvRW5kS2V5IiwicnRsIiwiaXNDcm9zc09yaWVudGF0aW9uT3BlbktleSIsImlzQ3Jvc3NPcmllbnRhdGlvbkNsb3NlS2V5IiwidXNlTGlzdE5hdmlnYXRpb24iLCJ1bnN0YWJsZV9vbk5hdmlnYXRlIiwic2VsZWN0ZWRJbmRleCIsImFsbG93RXNjYXBlIiwidmlydHVhbCIsImZvY3VzSXRlbU9uT3BlbiIsImZvY3VzSXRlbU9uSG92ZXIiLCJvcGVuT25BcnJvd0tleURvd24iLCJzY3JvbGxJdGVtSW50b1ZpZXciLCJ2aXJ0dWFsSXRlbVJlZiIsImpvaW4iLCJmb2N1c0l0ZW1Pbk9wZW5SZWYiLCJpbmRleFJlZiIsImtleVJlZiIsImlzUG9pbnRlck1vZGFsaXR5UmVmIiwicHJldmlvdXNPbk5hdmlnYXRlUmVmIiwicHJldmlvdXNNb3VudGVkUmVmIiwiZm9yY2VTeW5jRm9jdXMiLCJmb3JjZVNjcm9sbEludG9WaWV3UmVmIiwiZGlzYWJsZWRJbmRpY2VzUmVmIiwibGF0ZXN0T3BlblJlZiIsInNjcm9sbEl0ZW1JbnRvVmlld1JlZiIsImFjdGl2ZUlkIiwic2V0QWN0aXZlSWQiLCJ2aXJ0dWFsSWQiLCJzZXRWaXJ0dWFsSWQiLCJmb2N1c0l0ZW0iLCJmb3JjZVNjcm9sbEludG9WaWV3Iiwic2Nyb2xsSW50b1ZpZXdPcHRpb25zIiwic2hvdWxkU2Nyb2xsSW50b1ZpZXciLCJzY3JvbGxJbnRvVmlldyIsImJsb2NrIiwicnVucyIsIndhaXRGb3JMaXN0UG9wdWxhdGVkIiwic2NoZWR1bGVyIiwidHJlZUNvbnRhaW5zQWN0aXZlRWwiLCJoYW5kbGVWaXJ0dWFsRm9jdXMiLCJoYXNBY3RpdmVJbmRleCIsInN5bmNDdXJyZW50VGFyZ2V0Iiwib25Qb2ludGVyTGVhdmUiLCJfcmVmNCIsImN1cnJlbnRJbmRleCIsIm1pbiIsIm1heCIsImNoZWNrVmlydHVhbE1vdXNlIiwiY2hlY2tWaXJ0dWFsUG9pbnRlciIsImFyaWFBY3RpdmVEZXNjZW5kYW50UHJvcCIsImFjdGl2ZUl0ZW0iLCJpc0Fycm93S2V5IiwiaXNDcm9zc09wZW5LZXkiLCJpc0Nyb3NzQ2xvc2VLZXkiLCJpc01haW5LZXkiLCJpc05hdmlnYXRpb25LZXkiLCJ0cmltIiwicm9vdE5vZGUiLCJkZWVwZXN0Tm9kZSIsImV2ZW50T2JqZWN0IiwiS2V5Ym9hcmRFdmVudCIsIl9kZWVwZXN0Tm9kZSRjb250ZXh0IiwiX2RlZXBlc3ROb2RlJGNvbnRleHQyIiwiaXNDdXJyZW50VGFyZ2V0IiwiZGlzcGF0Y2hJdGVtIiwiZGlzcGF0Y2hFdmVudCIsIl9kZWVwZXN0Tm9kZSRjb250ZXh0JCIsIm9uUG9pbnRlck1vdmUiLCJjb21wb25lbnRSb2xlVG9BcmlhUm9sZU1hcCIsInVzZVJvbGUiLCJfY29tcG9uZW50Um9sZVRvQXJpYVIiLCJhcmlhUm9sZSIsInJlZmVyZW5jZUlkIiwiaXNOZXN0ZWQiLCJmbG9hdGluZ1Byb3BzIiwiYWN0aXZlIiwic2VsZWN0ZWQiLCJjb21tb25Qcm9wcyIsImNhbWVsQ2FzZVRvS2ViYWJDYXNlIiwic3RyIiwicmVwbGFjZSIsIiQiLCJvZnMiLCJ0b0xvd2VyQ2FzZSIsImV4ZWNXaXRoQXJnc09yUmV0dXJuIiwidmFsdWVPckZuIiwidXNlRGVsYXlVbm1vdW50IiwiZHVyYXRpb25NcyIsImlzTW91bnRlZCIsInNldElzTW91bnRlZCIsInVzZVRyYW5zaXRpb25TdGF0dXMiLCJkdXJhdGlvbiIsImlzTnVtYmVyRHVyYXRpb24iLCJjbG9zZUR1cmF0aW9uIiwiaW5pdGlhdGVkIiwic2V0SW5pdGlhdGVkIiwic3RhdHVzIiwic2V0U3RhdHVzIiwiZnJhbWUiLCJ1c2VUcmFuc2l0aW9uU3R5bGVzIiwiaW5pdGlhbCIsInVuc3RhYmxlX2luaXRpYWwiLCJvcGFjaXR5IiwidW5zdGFibGVfb3BlbiIsInVuc3RhYmxlX2Nsb3NlIiwiY29tbW9uIiwidW5zdGFibGVfY29tbW9uIiwiZm5BcmdzIiwib3BlbkR1cmF0aW9uIiwic3R5bGVzIiwic2V0U3R5bGVzIiwib3BlblJlZiIsImNsb3NlUmVmIiwiY29tbW9uUmVmIiwiaW5pdGlhbFN0eWxlcyIsImNsb3NlU3R5bGVzIiwiY29tbW9uU3R5bGVzIiwib3BlblN0eWxlcyIsInRyYW5zaXRpb25Qcm9wZXJ0eSIsInRyYW5zaXRpb25EdXJhdGlvbiIsInVzZVR5cGVhaGVhZCIsIm9uTWF0Y2giLCJ1bnN0YWJsZV9vbk1hdGNoIiwib25UeXBpbmdDaGFuZ2UiLCJ1bnN0YWJsZV9vblR5cGluZ0NoYW5nZSIsImZpbmRNYXRjaCIsInJlc2V0TXMiLCJpZ25vcmVLZXlzIiwidGltZW91dElkUmVmIiwic3RyaW5nUmVmIiwicHJldkluZGV4UmVmIiwibWF0Y2hJbmRleFJlZiIsImZpbmRNYXRjaFJlZiIsImlnbm9yZUtleXNSZWYiLCJzZXRUeXBpbmdDaGFuZ2UiLCJ0eXBpbmciLCJnZXRNYXRjaGluZ0luZGV4Iiwib3JkZXJlZExpc3QiLCJzdHJpbmciLCJ0ZXh0IiwidG9Mb2NhbGVMb3dlckNhc2UiLCJsaXN0Q29udGVudCIsImN0cmxLZXkiLCJtZXRhS2V5IiwiYWx0S2V5IiwiYWxsb3dSYXBpZFN1Y2Nlc3Npb25PZkZpcnN0TGV0dGVyIiwiX3RleHQkIiwiX3RleHQkMiIsImdldEFyZ3NXaXRoQ3VzdG9tRmxvYXRpbmdIZWlnaHQiLCJyZWN0cyIsImlubmVyIiwib3ZlcmZsb3dSZWYiLCJvbkZhbGxiYWNrQ2hhbmdlIiwiaW5uZXJPZmZzZXQiLCJtaW5JdGVtc1Zpc2libGUiLCJyZWZlcmVuY2VPdmVyZmxvd1RocmVzaG9sZCIsInNjcm9sbFJlZiIsImRldGVjdE92ZXJmbG93T3B0aW9ucyIsIl9leGNsdWRlZDYiLCJzdGFydHNXaXRoIiwibmV4dEFyZ3MiLCJjbGllbnRUb3AiLCJvZmZzZXRIZWlnaHQiLCJyZWZPdmVyZmxvdyIsImVsZW1lbnRDb250ZXh0IiwiZGlmZlkiLCJuZXh0WSIsIm1heEhlaWdodCIsInNjcm9sbFRvcCIsInVzZUlubmVyT2Zmc2V0Iiwib25DaGFuZ2UiLCJ1bnN0YWJsZV9vbkNoYW5nZSIsImNvbnRyb2xsZWRTY3JvbGxpbmdSZWYiLCJwcmV2U2Nyb2xsVG9wUmVmIiwiaW5pdGlhbE92ZXJmbG93UmVmIiwib25XaGVlbCIsImRZIiwiZGVsdGFZIiwiaXNBdFRvcCIsImlzQXRCb3R0b20iLCJyZW1haW5pbmdTY3JvbGwiLCJzaWduIiwibWV0aG9kIiwic2Nyb2xsRGlmZiIsImlzUG9pbnRJblBvbHlnb24iLCJwb2ludCIsInBvbHlnb24iLCJpc0luc2lkZSIsInhpIiwieWkiLCJ4aiIsInlqIiwiaW50ZXJzZWN0IiwicmVjdCIsInNhZmVQb2x5Z29uIiwiYnVmZmVyIiwicmVxdWlyZUludGVudCIsImhhc0xhbmRlZCIsImxhc3RYIiwibGFzdFkiLCJsYXN0Q3Vyc29yVGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiZ2V0Q3Vyc29yU3BlZWQiLCJjdXJyZW50VGltZSIsImVsYXBzZWRUaW1lIiwiZGVsdGFYIiwiZGlzdGFuY2UiLCJzcXJ0Iiwic3BlZWQiLCJjbGllbnRQb2ludCIsImlzTGVhdmUiLCJpc092ZXJGbG9hdGluZ0VsIiwiaXNPdmVyUmVmZXJlbmNlRWwiLCJyZWZSZWN0IiwiY3Vyc29yTGVhdmVGcm9tUmlnaHQiLCJjdXJzb3JMZWF2ZUZyb21Cb3R0b20iLCJpc092ZXJSZWZlcmVuY2VSZWN0IiwiaXNGbG9hdGluZ1dpZGVyIiwiaXNGbG9hdGluZ1RhbGxlciIsInJlY3RQb2x5IiwiZ2V0UG9seWdvbiIsImN1cnNvclBvaW50T25lIiwiY3Vyc29yUG9pbnRUd28iLCJjb21tb25Qb2ludHMiLCJjdXJzb3JTcGVlZCIsImN1cnNvclNwZWVkVGhyZXNob2xkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TYPEABLE_SELECTOR: () => (/* binding */ TYPEABLE_SELECTOR),\n/* harmony export */   activeElement: () => (/* binding */ activeElement),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   getDocument: () => (/* binding */ getDocument),\n/* harmony export */   getPlatform: () => (/* binding */ getPlatform),\n/* harmony export */   getTarget: () => (/* binding */ getTarget),\n/* harmony export */   getUserAgent: () => (/* binding */ getUserAgent),\n/* harmony export */   isAndroid: () => (/* binding */ isAndroid),\n/* harmony export */   isEventTargetWithin: () => (/* binding */ isEventTargetWithin),\n/* harmony export */   isJSDOM: () => (/* binding */ isJSDOM),\n/* harmony export */   isMac: () => (/* binding */ isMac),\n/* harmony export */   isMouseLikePointerType: () => (/* binding */ isMouseLikePointerType),\n/* harmony export */   isReactEvent: () => (/* binding */ isReactEvent),\n/* harmony export */   isRootElement: () => (/* binding */ isRootElement),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isTypeableCombobox: () => (/* binding */ isTypeableCombobox),\n/* harmony export */   isTypeableElement: () => (/* binding */ isTypeableElement),\n/* harmony export */   isVirtualClick: () => (/* binding */ isVirtualClick),\n/* harmony export */   isVirtualPointerEvent: () => (/* binding */ isVirtualPointerEvent),\n/* harmony export */   stopEvent: () => (/* binding */ stopEvent)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n\nfunction activeElement(doc) {\n  let activeElement = doc.activeElement;\n  while (((_activeElement = activeElement) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null) {\n    var _activeElement;\n    activeElement = activeElement.shadowRoot.activeElement;\n  }\n  return activeElement;\n}\nfunction contains(parent, child) {\n  if (!parent || !child) {\n    return false;\n  }\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();\n\n  // First, attempt with faster native method\n  if (parent.contains(child)) {\n    return true;\n  }\n\n  // then fallback to custom implementation with Shadow DOM support\n  if (rootNode && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(rootNode)) {\n    let next = child;\n    while (next) {\n      if (parent === next) {\n        return true;\n      }\n      // @ts-ignore\n      next = next.parentNode || next.host;\n    }\n  }\n\n  // Give up, the result is false\n  return false;\n}\n// Avoid Chrome DevTools blue warning.\nfunction getPlatform() {\n  const uaData = navigator.userAgentData;\n  if (uaData != null && uaData.platform) {\n    return uaData.platform;\n  }\n  return navigator.platform;\n}\nfunction getUserAgent() {\n  const uaData = navigator.userAgentData;\n  if (uaData && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(_ref => {\n      let {\n        brand,\n        version\n      } = _ref;\n      return brand + \"/\" + version;\n    }).join(' ');\n  }\n  return navigator.userAgent;\n}\n\n// License: https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/utils/src/isVirtualEvent.ts\nfunction isVirtualClick(event) {\n  // FIXME: Firefox is now emitting a deprecation warning for `mozInputSource`.\n  // Try to find a workaround for this. `react-aria` source still has the check.\n  if (event.mozInputSource === 0 && event.isTrusted) {\n    return true;\n  }\n  if (isAndroid() && event.pointerType) {\n    return event.type === 'click' && event.buttons === 1;\n  }\n  return event.detail === 0 && !event.pointerType;\n}\nfunction isVirtualPointerEvent(event) {\n  if (isJSDOM()) return false;\n  return !isAndroid() && event.width === 0 && event.height === 0 || isAndroid() && event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === 'mouse' ||\n  // iOS VoiceOver returns 0.333• for width/height.\n  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === 'touch';\n}\nfunction isSafari() {\n  // Chrome DevTools does not complain about navigator.vendor\n  return /apple/i.test(navigator.vendor);\n}\nfunction isAndroid() {\n  const re = /android/i;\n  return re.test(getPlatform()) || re.test(getUserAgent());\n}\nfunction isMac() {\n  return getPlatform().toLowerCase().startsWith('mac') && !navigator.maxTouchPoints;\n}\nfunction isJSDOM() {\n  return getUserAgent().includes('jsdom/');\n}\nfunction isMouseLikePointerType(pointerType, strict) {\n  // On some Linux machines with Chromium, mouse inputs return a `pointerType`\n  // of \"pen\": https://github.com/floating-ui/floating-ui/issues/2015\n  const values = ['mouse', 'pen'];\n  if (!strict) {\n    values.push('', undefined);\n  }\n  return values.includes(pointerType);\n}\nfunction isReactEvent(event) {\n  return 'nativeEvent' in event;\n}\nfunction isRootElement(element) {\n  return element.matches('html,body');\n}\nfunction getDocument(node) {\n  return (node == null ? void 0 : node.ownerDocument) || document;\n}\nfunction isEventTargetWithin(event, node) {\n  if (node == null) {\n    return false;\n  }\n  if ('composedPath' in event) {\n    return event.composedPath().includes(node);\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n  const e = event;\n  return e.target != null && node.contains(e.target);\n}\nfunction getTarget(event) {\n  if ('composedPath' in event) {\n    return event.composedPath()[0];\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support\n  // `composedPath()`, but browsers without shadow DOM don't.\n  return event.target;\n}\nconst TYPEABLE_SELECTOR = \"input:not([type='hidden']):not([disabled]),\" + \"[contenteditable]:not([contenteditable='false']),textarea:not([disabled])\";\nfunction isTypeableElement(element) {\n  return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) && element.matches(TYPEABLE_SELECTOR);\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopPropagation();\n}\nfunction isTypeableCombobox(element) {\n  if (!element) return false;\n  return element.getAttribute('role') === 'combobox' && isTypeableElement(element);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L2Rpc3QvZmxvYXRpbmctdWkucmVhY3QudXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxRTtBQUVyRSxTQUFTRSxhQUFhQSxDQUFDQyxHQUFHLEVBQUU7RUFDMUIsSUFBSUQsYUFBYSxHQUFHQyxHQUFHLENBQUNELGFBQWE7RUFDckMsT0FBTyxDQUFDLENBQUNFLGNBQWMsR0FBR0YsYUFBYSxLQUFLLElBQUksSUFBSSxDQUFDRSxjQUFjLEdBQUdBLGNBQWMsQ0FBQ0MsVUFBVSxLQUFLLElBQUksR0FBRyxLQUFLLENBQUMsR0FBR0QsY0FBYyxDQUFDRixhQUFhLEtBQUssSUFBSSxFQUFFO0lBQ3pKLElBQUlFLGNBQWM7SUFDbEJGLGFBQWEsR0FBR0EsYUFBYSxDQUFDRyxVQUFVLENBQUNILGFBQWE7RUFDeEQ7RUFDQSxPQUFPQSxhQUFhO0FBQ3RCO0FBQ0EsU0FBU0ksUUFBUUEsQ0FBQ0MsTUFBTSxFQUFFQyxLQUFLLEVBQUU7RUFDL0IsSUFBSSxDQUFDRCxNQUFNLElBQUksQ0FBQ0MsS0FBSyxFQUFFO0lBQ3JCLE9BQU8sS0FBSztFQUNkO0VBQ0EsTUFBTUMsUUFBUSxHQUFHRCxLQUFLLENBQUNFLFdBQVcsSUFBSSxJQUFJLEdBQUcsS0FBSyxDQUFDLEdBQUdGLEtBQUssQ0FBQ0UsV0FBVyxDQUFDLENBQUM7O0VBRXpFO0VBQ0EsSUFBSUgsTUFBTSxDQUFDRCxRQUFRLENBQUNFLEtBQUssQ0FBQyxFQUFFO0lBQzFCLE9BQU8sSUFBSTtFQUNiOztFQUVBO0VBQ0EsSUFBSUMsUUFBUSxJQUFJVCxvRUFBWSxDQUFDUyxRQUFRLENBQUMsRUFBRTtJQUN0QyxJQUFJRSxJQUFJLEdBQUdILEtBQUs7SUFDaEIsT0FBT0csSUFBSSxFQUFFO01BQ1gsSUFBSUosTUFBTSxLQUFLSSxJQUFJLEVBQUU7UUFDbkIsT0FBTyxJQUFJO01BQ2I7TUFDQTtNQUNBQSxJQUFJ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QUFNSyxDQUFDLEdBQUdyQyxLQUFLO0VBQ2YsT0FBT3FDLENBQUMsQ0FBQ0MsTUFBTSxJQUFJLElBQUksSUFBSU4sSUFBSSxDQUFDeEQsUUFBUSxDQUFDNkQsQ0FBQyxDQUFDQyxNQUFNLENBQUM7QUFDcEQ7QUFDQSxTQUFTQyxTQUFTQSxDQUFDdkMsS0FBSyxFQUFFO0VBQ3hCLElBQUksY0FBYyxJQUFJQSxLQUFLLEVBQUU7SUFDM0IsT0FBT0EsS0FBSyxDQUFDb0MsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDaEM7O0VBRUE7RUFDQTtFQUNBLE9BQU9wQyxLQUFLLENBQUNzQyxNQUFNO0FBQ3JCO0FBQ0EsTUFBTUUsaUJBQWlCLEdBQUcsNkNBQTZDLEdBQUcsMkVBQTJFO0FBQ3JKLFNBQVNDLGlCQUFpQkEsQ0FBQ1osT0FBTyxFQUFFO0VBQ2xDLE9BQU8xRCxxRUFBYSxDQUFDMEQsT0FBTyxDQUFDLElBQUlBLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDVSxpQkFBaUIsQ0FBQztBQUNyRTtBQUNBLFNBQVNFLFNBQVNBLENBQUMxQyxLQUFLLEVBQUU7RUFDeEJBLEtBQUssQ0FBQzJDLGNBQWMsQ0FBQyxDQUFDO0VBQ3RCM0MsS0FBSyxDQUFDNEMsZUFBZSxDQUFDLENBQUM7QUFDekI7QUFDQSxTQUFTQyxrQkFBa0JBLENBQUNoQixPQUFPLEVBQUU7RUFDbkMsSUFBSSxDQUFDQSxPQUFPLEVBQUUsT0FBTyxLQUFLO0VBQzFCLE9BQU9BLE9BQU8sQ0FBQ2lCLFlBQVksQ0FBQyxNQUFNLENBQUMsS0FBSyxVQUFVLElBQUlMLGlCQUFpQixDQUFDWixPQUFPLENBQUM7QUFDbEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xLWdlbmllLy4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9yZWFjdC9kaXN0L2Zsb2F0aW5nLXVpLnJlYWN0LnV0aWxzLm1qcz8wZWM1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzU2hhZG93Um9vdCwgaXNIVE1MRWxlbWVudCB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscy9kb20nO1xuXG5mdW5jdGlvbiBhY3RpdmVFbGVtZW50KGRvYykge1xuICBsZXQgYWN0aXZlRWxlbWVudCA9IGRvYy5hY3RpdmVFbGVtZW50O1xuICB3aGlsZSAoKChfYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQpID09IG51bGwgfHwgKF9hY3RpdmVFbGVtZW50ID0gX2FjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hY3RpdmVFbGVtZW50LmFjdGl2ZUVsZW1lbnQpICE9IG51bGwpIHtcbiAgICB2YXIgX2FjdGl2ZUVsZW1lbnQ7XG4gICAgYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xuICB9XG4gIHJldHVybiBhY3RpdmVFbGVtZW50O1xufVxuZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICBpZiAoIXBhcmVudCB8fCAhY2hpbGQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgcm9vdE5vZGUgPSBjaGlsZC5nZXRSb290Tm9kZSA9PSBudWxsID8gdm9pZCAwIDogY2hpbGQuZ2V0Um9vdE5vZGUoKTtcblxuICAvLyBGaXJzdCwgYXR0ZW1wdCB3aXRoIGZhc3RlciBuYXRpdmUgbWV0aG9kXG4gIGlmIChwYXJlbnQuY29udGFpbnMoY2hpbGQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyB0aGVuIGZhbGxiYWNrIHRvIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB3aXRoIFNoYWRvdyBET00gc3VwcG9ydFxuICBpZiAocm9vdE5vZGUgJiYgaXNTaGFkb3dSb290KHJvb3ROb2RlKSkge1xuICAgIGxldCBuZXh0ID0gY2hpbGQ7XG4gICAgd2hpbGUgKG5leHQpIHtcbiAgICAgIGlmIChwYXJlbnQgPT09IG5leHQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBuZXh0ID0gbmV4dC5wYXJlbnROb2RlIHx8IG5leHQuaG9zdDtcbiAgICB9XG4gIH1cblxuICAvLyBHaXZlIHVwLCB0aGUgcmVzdWx0IGlzIGZhbHNlXG4gIHJldHVybiBmYWxzZTtcbn1cbi8vIEF2b2lkIENocm9tZSBEZXZUb29scyBibHVlIHdhcm5pbmcuXG5mdW5jdGlvbiBnZXRQbGF0Zm9ybSgpIHtcbiAgY29uc3QgdWFEYXRhID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG4gIGlmICh1YURhdGEgIT0gbnVsbCAmJiB1YURhdGEucGxhdGZvcm0pIHtcbiAgICByZXR1cm4gdWFEYXRhLnBsYXRmb3JtO1xuICB9XG4gIHJldHVybiBuYXZpZ2F0b3IucGxhdGZvcm07XG59XG5mdW5jdGlvbiBnZXRVc2VyQWdlbnQoKSB7XG4gIGNvbnN0IHVhRGF0YSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhO1xuICBpZiAodWFEYXRhICYmIEFycmF5LmlzQXJyYXkodWFEYXRhLmJyYW5kcykpIHtcbiAgICByZXR1cm4gdWFEYXRhLmJyYW5kcy5tYXAoX3JlZiA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBicmFuZCxcbiAgICAgICAgdmVyc2lvblxuICAgICAgfSA9IF9yZWY7XG4gICAgICByZXR1cm4gYnJhbmQgKyBcIi9cIiArIHZlcnNpb247XG4gICAgfSkuam9pbignICcpO1xuICB9XG4gIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xufVxuXG4vLyBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vYWRvYmUvcmVhY3Qtc3BlY3RydW0vYmxvYi9iMzVkNWMwMmZlOTAwYmFkY2NkMGNmMWE4ZjIzYmI1OTM0MTlmMjM4L3BhY2thZ2VzL0ByZWFjdC1hcmlhL3V0aWxzL3NyYy9pc1ZpcnR1YWxFdmVudC50c1xuZnVuY3Rpb24gaXNWaXJ0dWFsQ2xpY2soZXZlbnQpIHtcbiAgLy8gRklYTUU6IEZpcmVmb3ggaXMgbm93IGVtaXR0aW5nIGEgZGVwcmVjYXRpb24gd2FybmluZyBmb3IgYG1veklucHV0U291cmNlYC5cbiAgLy8gVHJ5IHRvIGZpbmQgYSB3b3JrYXJvdW5kIGZvciB0aGlzLiBgcmVhY3QtYXJpYWAgc291cmNlIHN0aWxsIGhhcyB0aGUgY2hlY2suXG4gIGlmIChldmVudC5tb3pJbnB1dFNvdXJjZSA9PT0gMCAmJiBldmVudC5pc1RydXN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNBbmRyb2lkKCkgJiYgZXZlbnQucG9pbnRlclR5cGUpIHtcbiAgICByZXR1cm4gZXZlbnQudHlwZSA9PT0gJ2NsaWNrJyAmJiBldmVudC5idXR0b25zID09PSAxO1xuICB9XG4gIHJldHVybiBldmVudC5kZXRhaWwgPT09IDAgJiYgIWV2ZW50LnBvaW50ZXJUeXBlO1xufVxuZnVuY3Rpb24gaXNWaXJ0dWFsUG9pbnRlckV2ZW50KGV2ZW50KSB7XG4gIGlmIChpc0pTRE9NKCkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuICFpc0FuZHJvaWQoKSAmJiBldmVudC53aWR0aCA9PT0gMCAmJiBldmVudC5oZWlnaHQgPT09IDAgfHwgaXNBbmRyb2lkKCkgJiYgZXZlbnQud2lkdGggPT09IDEgJiYgZXZlbnQuaGVpZ2h0ID09PSAxICYmIGV2ZW50LnByZXNzdXJlID09PSAwICYmIGV2ZW50LmRldGFpbCA9PT0gMCAmJiBldmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fFxuICAvLyBpT1MgVm9pY2VPdmVyIHJldHVybnMgMC4zMzPigKIgZm9yIHdpZHRoL2hlaWdodC5cbiAgZXZlbnQud2lkdGggPCAxICYmIGV2ZW50LmhlaWdodCA8IDEgJiYgZXZlbnQucHJlc3N1cmUgPT09IDAgJiYgZXZlbnQuZGV0YWlsID09PSAwICYmIGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnO1xufVxuZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gIC8vIENocm9tZSBEZXZUb29scyBkb2VzIG5vdCBjb21wbGFpbiBhYm91dCBuYXZpZ2F0b3IudmVuZG9yXG4gIHJldHVybiAvYXBwbGUvaS50ZXN0KG5hdmlnYXRvci52ZW5kb3IpO1xufVxuZnVuY3Rpb24gaXNBbmRyb2lkKCkge1xuICBjb25zdCByZSA9IC9hbmRyb2lkL2k7XG4gIHJldHVybiByZS50ZXN0KGdldFBsYXRmb3JtKCkpIHx8IHJlLnRlc3QoZ2V0VXNlckFnZW50KCkpO1xufVxuZnVuY3Rpb24gaXNNYWMoKSB7XG4gIHJldHVybiBnZXRQbGF0Zm9ybSgpLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnbWFjJykgJiYgIW5hdmlnYXRvci5tYXhUb3VjaFBvaW50cztcbn1cbmZ1bmN0aW9uIGlzSlNET00oKSB7XG4gIHJldHVybiBnZXRVc2VyQWdlbnQoKS5pbmNsdWRlcygnanNkb20vJyk7XG59XG5mdW5jdGlvbiBpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlLCBzdHJpY3QpIHtcbiAgLy8gT24gc29tZSBMaW51eCBtYWNoaW5lcyB3aXRoIENocm9taXVtLCBtb3VzZSBpbnB1dHMgcmV0dXJuIGEgYHBvaW50ZXJUeXBlYFxuICAvLyBvZiBcInBlblwiOiBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzIwMTVcbiAgY29uc3QgdmFsdWVzID0gWydtb3VzZScsICdwZW4nXTtcbiAgaWYgKCFzdHJpY3QpIHtcbiAgICB2YWx1ZXMucHVzaCgnJywgdW5kZWZpbmVkKTtcbiAgfVxuICByZXR1cm4gdmFsdWVzLmluY2x1ZGVzKHBvaW50ZXJUeXBlKTtcbn1cbmZ1bmN0aW9uIGlzUmVhY3RFdmVudChldmVudCkge1xuICByZXR1cm4gJ25hdGl2ZUV2ZW50JyBpbiBldmVudDtcbn1cbmZ1bmN0aW9uIGlzUm9vdEVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC5tYXRjaGVzKCdodG1sLGJvZHknKTtcbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50KG5vZGUpIHtcbiAgcmV0dXJuIChub2RlID09IG51bGwgPyB2b2lkIDAgOiBub2RlLm93bmVyRG9jdW1lbnQpIHx8IGRvY3VtZW50O1xufVxuZnVuY3Rpb24gaXNFdmVudFRhcmdldFdpdGhpbihldmVudCwgbm9kZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgnY29tcG9zZWRQYXRoJyBpbiBldmVudCkge1xuICAgIHJldHVybiBldmVudC5jb21wb3NlZFBhdGgoKS5pbmNsdWRlcyhub2RlKTtcbiAgfVxuXG4gIC8vIFRTIHRoaW5rcyBgZXZlbnRgIGlzIG9mIHR5cGUgbmV2ZXIgYXMgaXQgYXNzdW1lcyBhbGwgYnJvd3NlcnMgc3VwcG9ydCBjb21wb3NlZFBhdGgsIGJ1dCBicm93c2VycyB3aXRob3V0IHNoYWRvdyBkb20gZG9uJ3RcbiAgY29uc3QgZSA9IGV2ZW50O1xuICByZXR1cm4gZS50YXJnZXQgIT0gbnVsbCAmJiBub2RlLmNvbnRhaW5zKGUudGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGdldFRhcmdldChldmVudCkge1xuICBpZiAoJ2NvbXBvc2VkUGF0aCcgaW4gZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuY29tcG9zZWRQYXRoKClbMF07XG4gIH1cblxuICAvLyBUUyB0aGlua3MgYGV2ZW50YCBpcyBvZiB0eXBlIG5ldmVyIGFzIGl0IGFzc3VtZXMgYWxsIGJyb3dzZXJzIHN1cHBvcnRcbiAgLy8gYGNvbXBvc2VkUGF0aCgpYCwgYnV0IGJyb3dzZXJzIHdpdGhvdXQgc2hhZG93IERPTSBkb24ndC5cbiAgcmV0dXJuIGV2ZW50LnRhcmdldDtcbn1cbmNvbnN0IFRZUEVBQkxFX1NFTEVDVE9SID0gXCJpbnB1dDpub3QoW3R5cGU9J2hpZGRlbiddKTpub3QoW2Rpc2FibGVkXSksXCIgKyBcIltjb250ZW50ZWRpdGFibGVdOm5vdChbY29udGVudGVkaXRhYmxlPSdmYWxzZSddKSx0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSlcIjtcbmZ1bmN0aW9uIGlzVHlwZWFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgJiYgZWxlbWVudC5tYXRjaGVzKFRZUEVBQkxFX1NFTEVDVE9SKTtcbn1cbmZ1bmN0aW9uIHN0b3BFdmVudChldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cbmZ1bmN0aW9uIGlzVHlwZWFibGVDb21ib2JveChlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSA9PT0gJ2NvbWJvYm94JyAmJiBpc1R5cGVhYmxlRWxlbWVudChlbGVtZW50KTtcbn1cblxuZXhwb3J0IHsgVFlQRUFCTEVfU0VMRUNUT1IsIGFjdGl2ZUVsZW1lbnQsIGNvbnRhaW5zLCBnZXREb2N1bWVudCwgZ2V0UGxhdGZvcm0sIGdldFRhcmdldCwgZ2V0VXNlckFnZW50LCBpc0FuZHJvaWQsIGlzRXZlbnRUYXJnZXRXaXRoaW4sIGlzSlNET00sIGlzTWFjLCBpc01vdXNlTGlrZVBvaW50ZXJUeXBlLCBpc1JlYWN0RXZlbnQsIGlzUm9vdEVsZW1lbnQsIGlzU2FmYXJpLCBpc1R5cGVhYmxlQ29tYm9ib3gsIGlzVHlwZWFibGVFbGVtZW50LCBpc1ZpcnR1YWxDbGljaywgaXNWaXJ0dWFsUG9pbnRlckV2ZW50LCBzdG9wRXZlbnQgfTtcbiJdLCJuYW1lcyI6WyJpc1NoYWRvd1Jvb3QiLCJpc0hUTUxFbGVtZW50IiwiYWN0aXZlRWxlbWVudCIsImRvYyIsIl9hY3RpdmVFbGVtZW50Iiwic2hhZG93Um9vdCIsImNvbnRhaW5zIiwicGFyZW50IiwiY2hpbGQiLCJyb290Tm9kZSIsImdldFJvb3ROb2RlIiwibmV4dCIsInBhcmVudE5vZGUiLCJob3N0IiwiZ2V0UGxhdGZvcm0iLCJ1YURhdGEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnREYXRhIiwicGxhdGZvcm0iLCJnZXRVc2VyQWdlbnQiLCJBcnJheSIsImlzQXJyYXkiLCJicmFuZHMiLCJtYXAiLCJfcmVmIiwiYnJhbmQiLCJ2ZXJzaW9uIiwiam9pbiIsInVzZXJBZ2VudCIsImlzVmlydHVhbENsaWNrIiwiZXZlbnQiLCJtb3pJbnB1dFNvdXJjZSIsImlzVHJ1c3RlZCIsImlzQW5kcm9pZCIsInBvaW50ZXJUeXBlIiwidHlwZSIsImJ1dHRvbnMiLCJkZXRhaWwiLCJpc1ZpcnR1YWxQb2ludGVyRXZlbnQiLCJpc0pTRE9NIiwid2lkdGgiLCJoZWlnaHQiLCJwcmVzc3VyZSIsImlzU2FmYXJpIiwidGVzdCIsInZlbmRvciIsInJlIiwiaXNNYWMiLCJ0b0xvd2VyQ2FzZSIsInN0YXJ0c1dpdGgiLCJtYXhUb3VjaFBvaW50cyIsImluY2x1ZGVzIiwiaXNNb3VzZUxpa2VQb2ludGVyVHlwZSIsInN0cmljdCIsInZhbHVlcyIsInB1c2giLCJ1bmRlZmluZWQiLCJpc1JlYWN0RXZlbnQiLCJpc1Jvb3RFbGVtZW50IiwiZWxlbWVudCIsIm1hdGNoZXMiLCJnZXREb2N1bWVudCIsIm5vZGUiLCJvd25lckRvY3VtZW50IiwiZG9jdW1lbnQiLCJpc0V2ZW50VGFyZ2V0V2l0aGluIiwiY29tcG9zZWRQYXRoIiwiZSIsInRhcmdldCIsImdldFRhcmdldCIsIlRZUEVBQkxFX1NFTEVDVE9SIiwiaXNUeXBlYWJsZUVsZW1lbnQiLCJzdG9wRXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsImlzVHlwZWFibGVDb21ib2JveCIsImdldEF0dHJpYnV0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getComputedStyle: () => (/* binding */ getComputedStyle),\n/* harmony export */   getContainingBlock: () => (/* binding */ getContainingBlock),\n/* harmony export */   getDocumentElement: () => (/* binding */ getDocumentElement),\n/* harmony export */   getNearestOverflowAncestor: () => (/* binding */ getNearestOverflowAncestor),\n/* harmony export */   getNodeName: () => (/* binding */ getNodeName),\n/* harmony export */   getNodeScroll: () => (/* binding */ getNodeScroll),\n/* harmony export */   getOverflowAncestors: () => (/* binding */ getOverflowAncestors),\n/* harmony export */   getParentNode: () => (/* binding */ getParentNode),\n/* harmony export */   getWindow: () => (/* binding */ getWindow),\n/* harmony export */   isContainingBlock: () => (/* binding */ isContainingBlock),\n/* harmony export */   isElement: () => (/* binding */ isElement),\n/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),\n/* harmony export */   isLastTraversableNode: () => (/* binding */ isLastTraversableNode),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isOverflowElement: () => (/* binding */ isOverflowElement),\n/* harmony export */   isShadowRoot: () => (/* binding */ isShadowRoot),\n/* harmony export */   isTableElement: () => (/* binding */ isTableElement),\n/* harmony export */   isWebKit: () => (/* binding */ isWebKit)\n/* harmony export */ });\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  const webkit = isWebKit();\n  const css = getComputedStyle(element);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMuZG9tLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxTQUFTQSxXQUFXQSxDQUFDQyxJQUFJLEVBQUU7RUFDekIsSUFBSUMsTUFBTSxDQUFDRCxJQUFJLENBQUMsRUFBRTtJQUNoQixPQUFPLENBQUNBLElBQUksQ0FBQ0UsUUFBUSxJQUFJLEVBQUUsRUFBRUMsV0FBVyxDQUFDLENBQUM7RUFDNUM7RUFDQTtFQUNBO0VBQ0E7RUFDQSxPQUFPLFdBQVc7QUFDcEI7QUFDQSxTQUFTQyxTQUFTQSxDQUFDSixJQUFJLEVBQUU7RUFDdkIsSUFBSUssbUJBQW1CO0VBQ3ZCLE9BQU8sQ0FBQ0wsSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDSyxtQkFBbUIsR0FBR0wsSUFBSSxDQUFDTSxhQUFhLEtBQUssSUFBSSxHQUFHLEtBQUssQ0FBQyxHQUFHRCxtQkFBbUIsQ0FBQ0UsV0FBVyxLQUFLQyxNQUFNO0FBQ2xJO0FBQ0EsU0FBU0Msa0JBQWtCQSxDQUFDVCxJQUFJLEVBQUU7RUFDaEMsSUFBSVUsSUFBSTtFQUNSLE9BQU8sQ0FBQ0EsSUFBSSxHQUFHLENBQUNULE1BQU0sQ0FBQ0QsSUFBSSxDQUFDLEdBQUdBLElBQUksQ0FBQ00sYUFBYSxHQUFHTixJQUFJLENBQUNXLFFBQVEsS0FBS0gsTUFBTSxDQUFDRyxRQUFRLEtBQUssSUFBSSxHQUFHLEtBQUssQ0FBQyxHQUFHRCxJQUFJLENBQUNFLGVBQWU7QUFDaEk7QUFDQSxTQUFTWCxNQUFNQSxDQUFDWSxLQUFLLEVBQUU7RUFDckIsT0FBT0EsS0FBSyxZQUFZQyxJQUFJLElBQUlELEtBQUssWUFBWVQsU0FBUyxDQUFDUyxLQUFLLENBQUMsQ0FBQ0MsSUFBSTtBQUN4RTtBQUNBLFNBQVNDLFNBQVNBLENBQUNGLEtBQUssRUFBRTtFQUN4QixPQUFPQSxLQUFLLFlBQVlHLE9BQU8sSUFBSUgs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R0FBRyxDQUFDRSxjQUFjLElBQUksRUFBRSxFQUFFL0MsaUJBQWlCLENBQUMyQyxrQkFBa0IsQ0FBQyxHQUFHQSxrQkFBa0IsR0FBRyxFQUFFLEVBQUVFLEdBQUcsQ0FBQ0csWUFBWSxJQUFJUCxlQUFlLEdBQUdGLG9CQUFvQixDQUFDTSxHQUFHLENBQUNHLFlBQVksQ0FBQyxHQUFHLEVBQUUsQ0FBQztFQUN2TTtFQUNBLE9BQU9SLElBQUksQ0FBQ00sTUFBTSxDQUFDSCxrQkFBa0IsRUFBRUosb0JBQW9CLENBQUNJLGtCQUFrQixFQUFFLEVBQUUsRUFBRUYsZUFBZSxDQUFDLENBQUM7QUFDdkciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xLWdlbmllLy4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS91dGlscy9kaXN0L2Zsb2F0aW5nLXVpLnV0aWxzLmRvbS5tanM/MjRlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBnZXROb2RlTmFtZShub2RlKSB7XG4gIGlmIChpc05vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gKG5vZGUubm9kZU5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgLy8gTW9ja2VkIG5vZGVzIGluIHRlc3RpbmcgZW52aXJvbm1lbnRzIG1heSBub3QgYmUgaW5zdGFuY2VzIG9mIE5vZGUuIEJ5XG4gIC8vIHJldHVybmluZyBgI2RvY3VtZW50YCBhbiBpbmZpbml0ZSBsb29wIHdvbid0IG9jY3VyLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzIzMTdcbiAgcmV0dXJuICcjZG9jdW1lbnQnO1xufVxuZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgdmFyIF9ub2RlJG93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiAobm9kZSA9PSBudWxsIHx8IChfbm9kZSRvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgfHwgd2luZG93O1xufVxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRFbGVtZW50KG5vZGUpIHtcbiAgdmFyIF9yZWY7XG4gIHJldHVybiAoX3JlZiA9IChpc05vZGUobm9kZSkgPyBub2RlLm93bmVyRG9jdW1lbnQgOiBub2RlLmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVmLmRvY3VtZW50RWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzTm9kZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBOb2RlIHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5Ob2RlO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVsZW1lbnQgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLkVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5IVE1MRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzU2hhZG93Um9vdCh2YWx1ZSkge1xuICAvLyBCcm93c2VycyB3aXRob3V0IGBTaGFkb3dSb290YCBzdXBwb3J0LlxuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLlNoYWRvd1Jvb3Q7XG59XG5mdW5jdGlvbiBpc092ZXJmbG93RWxlbWVudChlbGVtZW50KSB7XG4gIGNvbnN0IHtcbiAgICBvdmVyZmxvdyxcbiAgICBvdmVyZmxvd1gsXG4gICAgb3ZlcmZsb3dZLFxuICAgIGRpc3BsYXlcbiAgfSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW58Y2xpcC8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkgJiYgIVsnaW5saW5lJywgJ2NvbnRlbnRzJ10uaW5jbHVkZXMoZGlzcGxheSk7XG59XG5mdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBbJ3RhYmxlJywgJ3RkJywgJ3RoJ10uaW5jbHVkZXMoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpO1xufVxuZnVuY3Rpb24gaXNDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICBjb25zdCB3ZWJraXQgPSBpc1dlYktpdCgpO1xuICBjb25zdCBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG4gIHJldHVybiBjc3MudHJhbnNmb3JtICE9PSAnbm9uZScgfHwgY3NzLnBlcnNwZWN0aXZlICE9PSAnbm9uZScgfHwgKGNzcy5jb250YWluZXJUeXBlID8gY3NzLmNvbnRhaW5lclR5cGUgIT09ICdub3JtYWwnIDogZmFsc2UpIHx8ICF3ZWJraXQgJiYgKGNzcy5iYWNrZHJvcEZpbHRlciA/IGNzcy5iYWNrZHJvcEZpbHRlciAhPT0gJ25vbmUnIDogZmFsc2UpIHx8ICF3ZWJraXQgJiYgKGNzcy5maWx0ZXIgPyBjc3MuZmlsdGVyICE9PSAnbm9uZScgOiBmYWxzZSkgfHwgWyd0cmFuc2Zvcm0nLCAncGVyc3BlY3RpdmUnLCAnZmlsdGVyJ10uc29tZSh2YWx1ZSA9PiAoY3NzLndpbGxDaGFuZ2UgfHwgJycpLmluY2x1ZGVzKHZhbHVlKSkgfHwgWydwYWludCcsICdsYXlvdXQnLCAnc3RyaWN0JywgJ2NvbnRlbnQnXS5zb21lKHZhbHVlID0+IChjc3MuY29udGFpbiB8fCAnJykuaW5jbHVkZXModmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gIGxldCBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIHdoaWxlIChpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJiAhaXNMYXN0VHJhdmVyc2FibGVOb2RlKGN1cnJlbnROb2RlKSkge1xuICAgIGlmIChpc0NvbnRhaW5pbmdCbG9jayhjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc1dlYktpdCgpIHtcbiAgaWYgKHR5cGVvZiBDU1MgPT09ICd1bmRlZmluZWQnIHx8ICFDU1Muc3VwcG9ydHMpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIENTUy5zdXBwb3J0cygnLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXInLCAnbm9uZScpO1xufVxuZnVuY3Rpb24gaXNMYXN0VHJhdmVyc2FibGVOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluY2x1ZGVzKGdldE5vZGVOYW1lKG5vZGUpKTtcbn1cbmZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59XG5mdW5jdGlvbiBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpIHtcbiAgaWYgKGlzRWxlbWVudChlbGVtZW50KSkge1xuICAgIHJldHVybiB7XG4gICAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQucGFnZVhPZmZzZXQsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnBhZ2VZT2Zmc2V0XG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKG5vZGUpIHtcbiAgaWYgKGdldE5vZGVOYW1lKG5vZGUpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjb25zdCByZXN1bHQgPVxuICAvLyBTdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZS5cbiAgbm9kZS5hc3NpZ25lZFNsb3QgfHxcbiAgLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWQuXG4gIG5vZGUucGFyZW50Tm9kZSB8fFxuICAvLyBTaGFkb3dSb290IGRldGVjdGVkLlxuICBpc1NoYWRvd1Jvb3Qobm9kZSkgJiYgbm9kZS5ob3N0IHx8XG4gIC8vIEZhbGxiYWNrLlxuICBnZXREb2N1bWVudEVsZW1lbnQobm9kZSk7XG4gIHJldHVybiBpc1NoYWRvd1Jvb3QocmVzdWx0KSA/IHJlc3VsdC5ob3N0IDogcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3Iobm9kZSkge1xuICBjb25zdCBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShub2RlKTtcbiAgaWYgKGlzTGFzdFRyYXZlcnNhYmxlTm9kZShwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQgPyBub2RlLm93bmVyRG9jdW1lbnQuYm9keSA6IG5vZGUuYm9keTtcbiAgfVxuICBpZiAoaXNIVE1MRWxlbWVudChwYXJlbnROb2RlKSAmJiBpc092ZXJmbG93RWxlbWVudChwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBwYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3RvcihwYXJlbnROb2RlKTtcbn1cbmZ1bmN0aW9uIGdldE92ZXJmbG93QW5jZXN0b3JzKG5vZGUsIGxpc3QsIHRyYXZlcnNlSWZyYW1lcykge1xuICB2YXIgX25vZGUkb3duZXJEb2N1bWVudDI7XG4gIGlmIChsaXN0ID09PSB2b2lkIDApIHtcbiAgICBsaXN0ID0gW107XG4gIH1cbiAgaWYgKHRyYXZlcnNlSWZyYW1lcyA9PT0gdm9pZCAwKSB7XG4gICAgdHJhdmVyc2VJZnJhbWVzID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBzY3JvbGxhYmxlQW5jZXN0b3IgPSBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3Rvcihub2RlKTtcbiAgY29uc3QgaXNCb2R5ID0gc2Nyb2xsYWJsZUFuY2VzdG9yID09PSAoKF9ub2RlJG93bmVyRG9jdW1lbnQyID0gbm9kZS5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkb3duZXJEb2N1bWVudDIuYm9keSk7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhzY3JvbGxhYmxlQW5jZXN0b3IpO1xuICBpZiAoaXNCb2R5KSB7XG4gICAgcmV0dXJuIGxpc3QuY29uY2F0KHdpbiwgd2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc092ZXJmbG93RWxlbWVudChzY3JvbGxhYmxlQW5jZXN0b3IpID8gc2Nyb2xsYWJsZUFuY2VzdG9yIDogW10sIHdpbi5mcmFtZUVsZW1lbnQgJiYgdHJhdmVyc2VJZnJhbWVzID8gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMod2luLmZyYW1lRWxlbWVudCkgOiBbXSk7XG4gIH1cbiAgcmV0dXJuIGxpc3QuY29uY2F0KHNjcm9sbGFibGVBbmNlc3RvciwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoc2Nyb2xsYWJsZUFuY2VzdG9yLCBbXSwgdHJhdmVyc2VJZnJhbWVzKSk7XG59XG5cbmV4cG9ydCB7IGdldENvbXB1dGVkU3R5bGUsIGdldENvbnRhaW5pbmdCbG9jaywgZ2V0RG9jdW1lbnRFbGVtZW50LCBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3RvciwgZ2V0Tm9kZU5hbWUsIGdldE5vZGVTY3JvbGwsIGdldE92ZXJmbG93QW5jZXN0b3JzLCBnZXRQYXJlbnROb2RlLCBnZXRXaW5kb3csIGlzQ29udGFpbmluZ0Jsb2NrLCBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzTGFzdFRyYXZlcnNhYmxlTm9kZSwgaXNOb2RlLCBpc092ZXJmbG93RWxlbWVudCwgaXNTaGFkb3dSb290LCBpc1RhYmxlRWxlbWVudCwgaXNXZWJLaXQgfTtcbiJdLCJuYW1lcyI6WyJnZXROb2RlTmFtZSIsIm5vZGUiLCJpc05vZGUiLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwiZ2V0V2luZG93IiwiX25vZGUkb3duZXJEb2N1bWVudCIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsIndpbmRvdyIsImdldERvY3VtZW50RWxlbWVudCIsIl9yZWYiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsInZhbHVlIiwiTm9kZSIsImlzRWxlbWVudCIsIkVsZW1lbnQiLCJpc0hUTUxFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJpc1NoYWRvd1Jvb3QiLCJTaGFkb3dSb290IiwiaXNPdmVyZmxvd0VsZW1lbnQiLCJlbGVtZW50Iiwib3ZlcmZsb3ciLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJkaXNwbGF5IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInRlc3QiLCJpbmNsdWRlcyIsImlzVGFibGVFbGVtZW50IiwiaXNDb250YWluaW5nQmxvY2siLCJ3ZWJraXQiLCJpc1dlYktpdCIsImNzcyIsInRyYW5zZm9ybSIsInBlcnNwZWN0aXZlIiwiY29udGFpbmVyVHlwZSIsImJhY2tkcm9wRmlsdGVyIiwiZmlsdGVyIiwic29tZSIsIndpbGxDaGFuZ2UiLCJjb250YWluIiwiZ2V0Q29udGFpbmluZ0Jsb2NrIiwiY3VycmVudE5vZGUiLCJnZXRQYXJlbnROb2RlIiwiaXNMYXN0VHJhdmVyc2FibGVOb2RlIiwiQ1NTIiwic3VwcG9ydHMiLCJnZXROb2RlU2Nyb2xsIiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsInBhZ2VYT2Zmc2V0IiwicGFnZVlPZmZzZXQiLCJyZXN1bHQiLCJhc3NpZ25lZFNsb3QiLCJwYXJlbnROb2RlIiwiaG9zdCIsImdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yIiwiYm9keSIsImdldE92ZXJmbG93QW5jZXN0b3JzIiwibGlzdCIsInRyYXZlcnNlSWZyYW1lcyIsIl9ub2RlJG93bmVyRG9jdW1lbnQyIiwic2Nyb2xsYWJsZUFuY2VzdG9yIiwiaXNCb2R5Iiwid2luIiwiY29uY2F0IiwidmlzdWFsVmlld3BvcnQiLCJmcmFtZUVsZW1lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   alignments: () => (/* binding */ alignments),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   createCoords: () => (/* binding */ createCoords),\n/* harmony export */   evaluate: () => (/* binding */ evaluate),\n/* harmony export */   expandPaddingObject: () => (/* binding */ expandPaddingObject),\n/* harmony export */   floor: () => (/* binding */ floor),\n/* harmony export */   getAlignment: () => (/* binding */ getAlignment),\n/* harmony export */   getAlignmentAxis: () => (/* binding */ getAlignmentAxis),\n/* harmony export */   getAlignmentSides: () => (/* binding */ getAlignmentSides),\n/* harmony export */   getAxisLength: () => (/* binding */ getAxisLength),\n/* harmony export */   getExpandedPlacements: () => (/* binding */ getExpandedPlacements),\n/* harmony export */   getOppositeAlignmentPlacement: () => (/* binding */ getOppositeAlignmentPlacement),\n/* harmony export */   getOppositeAxis: () => (/* binding */ getOppositeAxis),\n/* harmony export */   getOppositeAxisPlacements: () => (/* binding */ getOppositeAxisPlacements),\n/* harmony export */   getOppositePlacement: () => (/* binding */ getOppositePlacement),\n/* harmony export */   getPaddingObject: () => (/* binding */ getPaddingObject),\n/* harmony export */   getSide: () => (/* binding */ getSide),\n/* harmony export */   getSideAxis: () => (/* binding */ getSideAxis),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   placements: () => (/* binding */ placements),\n/* harmony export */   rectToClientRect: () => (/* binding */ rectToClientRect),\n/* harmony export */   round: () => (/* binding */ round),\n/* harmony export */   sides: () => (/* binding */ sides)\n/* harmony export */ });\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return _objectSpread({\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  }, padding);\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  return _objectSpread(_objectSpread({}, rect), {}, {\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTUEsS0FBSyxHQUFHLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxDQUFDO0FBQ2hELE1BQU1DLFVBQVUsR0FBRyxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUM7QUFDbkMsTUFBTUMsVUFBVSxHQUFHLGFBQWFGLEtBQUssQ0FBQ0csTUFBTSxDQUFDLENBQUNDLEdBQUcsRUFBRUMsSUFBSSxLQUFLRCxHQUFHLENBQUNFLE1BQU0sQ0FBQ0QsSUFBSSxFQUFFQSxJQUFJLEdBQUcsR0FBRyxHQUFHSixVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUVJLElBQUksR0FBRyxHQUFHLEdBQUdKLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztBQUN6SSxNQUFNTSxHQUFHLEdBQUdDLElBQUksQ0FBQ0QsR0FBRztBQUNwQixNQUFNRSxHQUFHLEdBQUdELElBQUksQ0FBQ0MsR0FBRztBQUNwQixNQUFNQyxLQUFLLEdBQUdGLElBQUksQ0FBQ0UsS0FBSztBQUN4QixNQUFNQyxLQUFLLEdBQUdILElBQUksQ0FBQ0csS0FBSztBQUN4QixNQUFNQyxZQUFZLEdBQUdDLENBQUMsS0FBSztFQUN6QkMsQ0FBQyxFQUFFRCxDQUFDO0VBQ0pFLENBQUMsRUFBRUY7QUFDTCxDQUFDLENBQUM7QUFDRixNQUFNRyxlQUFlLEdBQUc7RUFDdEJDLElBQUksRUFBRSxPQUFPO0VBQ2JDLEtBQUssRUFBRSxNQUFNO0VBQ2JDLE1BQU0sRUFBRSxLQUFLO0VBQ2JDLEdBQUcsRUFBRTtBQUNQLENBQUM7QUFDRCxNQUFNQyxvQkFBb0IsR0FBRztFQUMzQkMsS0FBSyxFQUFFLEtBQUs7RUFDWkMsR0FBRyxFQUFF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QUFPVyxJQUFJO0FBQ2I7QUFDQSxTQUFTZCxvQkFBb0JBLENBQUNsQixTQUFTLEVBQUU7RUFDdkMsT0FBT0EsU0FBUyxDQUFDc0IsT0FBTyxDQUFDLHdCQUF3QixFQUFFOUMsSUFBSSxJQUFJVyxlQUFlLENBQUNYLElBQUksQ0FBQyxDQUFDO0FBQ25GO0FBQ0EsU0FBUzBELG1CQUFtQkEsQ0FBQ0MsT0FBTyxFQUFFO0VBQ3BDLE9BQUFDLGFBQUE7SUFDRTdDLEdBQUcsRUFBRSxDQUFDO0lBQ05GLEtBQUssRUFBRSxDQUFDO0lBQ1JDLE1BQU0sRUFBRSxDQUFDO0lBQ1RGLElBQUksRUFBRTtFQUFDLEdBQ0orQyxPQUFPO0FBRWQ7QUFDQSxTQUFTRSxnQkFBZ0JBLENBQUNGLE9BQU8sRUFBRTtFQUNqQyxPQUFPLE9BQU9BLE9BQU8sS0FBSyxRQUFRLEdBQUdELG1CQUFtQixDQUFDQyxPQUFPLENBQUMsR0FBRztJQUNsRTVDLEdBQUcsRUFBRTRDLE9BQU87SUFDWjlDLEtBQUssRUFBRThDLE9BQU87SUFDZDdDLE1BQU0sRUFBRTZDLE9BQU87SUFDZi9DLElBQUksRUFBRStDO0VBQ1IsQ0FBQztBQUNIO0FBQ0EsU0FBU0csZ0JBQWdCQSxDQUFDQyxJQUFJLEVBQUU7RUFDOUIsT0FBQUgsYUFBQSxDQUFBQSxhQUFBLEtBQ0tHLElBQUk7SUFDUGhELEdBQUcsRUFBRWdELElBQUksQ0FBQ3JELENBQUM7SUFDWEUsSUFBSSxFQUFFbUQsSUFBSSxDQUFDdEQsQ0FBQztJQUNaSSxLQUFLLEVBQUVrRCxJQUFJLENBQUN0RCxDQUFDLEdBQUdzRCxJQUFJLENBQUNDLEtBQUs7SUFDMUJsRCxNQUFNLEVBQUVpRCxJQUFJLENBQUNyRCxDQUFDLEdBQUdxRCxJQUFJLENBQUNFO0VBQU07QUFFaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xLWdlbmllLy4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS91dGlscy9kaXN0L2Zsb2F0aW5nLXVpLnV0aWxzLm1qcz81YWVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ3VzdG9tIHBvc2l0aW9uaW5nIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3ZpcnR1YWwtZWxlbWVudHNcbiAqL1xuXG5jb25zdCBzaWRlcyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J107XG5jb25zdCBhbGlnbm1lbnRzID0gWydzdGFydCcsICdlbmQnXTtcbmNvbnN0IHBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovc2lkZXMucmVkdWNlKChhY2MsIHNpZGUpID0+IGFjYy5jb25jYXQoc2lkZSwgc2lkZSArIFwiLVwiICsgYWxpZ25tZW50c1swXSwgc2lkZSArIFwiLVwiICsgYWxpZ25tZW50c1sxXSksIFtdKTtcbmNvbnN0IG1pbiA9IE1hdGgubWluO1xuY29uc3QgbWF4ID0gTWF0aC5tYXg7XG5jb25zdCByb3VuZCA9IE1hdGgucm91bmQ7XG5jb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG5jb25zdCBjcmVhdGVDb29yZHMgPSB2ID0+ICh7XG4gIHg6IHYsXG4gIHk6IHZcbn0pO1xuY29uc3Qgb3Bwb3NpdGVTaWRlTWFwID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuY29uc3Qgb3Bwb3NpdGVBbGlnbm1lbnRNYXAgPSB7XG4gIHN0YXJ0OiAnZW5kJyxcbiAgZW5kOiAnc3RhcnQnXG59O1xuZnVuY3Rpb24gY2xhbXAoc3RhcnQsIHZhbHVlLCBlbmQpIHtcbiAgcmV0dXJuIG1heChzdGFydCwgbWluKHZhbHVlLCBlbmQpKTtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlKHZhbHVlLCBwYXJhbSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUocGFyYW0pIDogdmFsdWU7XG59XG5mdW5jdGlvbiBnZXRTaWRlKHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbn1cbmZ1bmN0aW9uIGdldE9wcG9zaXRlQXhpcyhheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneCcgPyAneScgOiAneCc7XG59XG5mdW5jdGlvbiBnZXRBeGlzTGVuZ3RoKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbn1cbmZ1bmN0aW9uIGdldFNpZGVBeGlzKHBsYWNlbWVudCkge1xuICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJ10uaW5jbHVkZXMoZ2V0U2lkZShwbGFjZW1lbnQpKSA/ICd5JyA6ICd4Jztcbn1cbmZ1bmN0aW9uIGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KSB7XG4gIHJldHVybiBnZXRPcHBvc2l0ZUF4aXMoZ2V0U2lkZUF4aXMocGxhY2VtZW50KSk7XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnRTaWRlcyhwbGFjZW1lbnQsIHJlY3RzLCBydGwpIHtcbiAgaWYgKHJ0bCA9PT0gdm9pZCAwKSB7XG4gICAgcnRsID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGNvbnN0IGFsaWdubWVudEF4aXMgPSBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCk7XG4gIGNvbnN0IGxlbmd0aCA9IGdldEF4aXNMZW5ndGgoYWxpZ25tZW50QXhpcyk7XG4gIGxldCBtYWluQWxpZ25tZW50U2lkZSA9IGFsaWdubWVudEF4aXMgPT09ICd4JyA/IGFsaWdubWVudCA9PT0gKHJ0bCA/ICdlbmQnIDogJ3N0YXJ0JykgPyAncmlnaHQnIDogJ2xlZnQnIDogYWxpZ25tZW50ID09PSAnc3RhcnQnID8gJ2JvdHRvbScgOiAndG9wJztcbiAgaWYgKHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdID4gcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXSkge1xuICAgIG1haW5BbGlnbm1lbnRTaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpbkFsaWdubWVudFNpZGUpO1xuICB9XG4gIHJldHVybiBbbWFpbkFsaWdubWVudFNpZGUsIGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5BbGlnbm1lbnRTaWRlKV07XG59XG5mdW5jdGlvbiBnZXRFeHBhbmRlZFBsYWNlbWVudHMocGxhY2VtZW50KSB7XG4gIGNvbnN0IG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cbmZ1bmN0aW9uIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBhbGlnbm1lbnQgPT4gb3Bwb3NpdGVBbGlnbm1lbnRNYXBbYWxpZ25tZW50XSk7XG59XG5mdW5jdGlvbiBnZXRTaWRlTGlzdChzaWRlLCBpc1N0YXJ0LCBydGwpIHtcbiAgY29uc3QgbHIgPSBbJ2xlZnQnLCAncmlnaHQnXTtcbiAgY29uc3QgcmwgPSBbJ3JpZ2h0JywgJ2xlZnQnXTtcbiAgY29uc3QgdGIgPSBbJ3RvcCcsICdib3R0b20nXTtcbiAgY29uc3QgYnQgPSBbJ2JvdHRvbScsICd0b3AnXTtcbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgaWYgKHJ0bCkgcmV0dXJuIGlzU3RhcnQgPyBybCA6IGxyO1xuICAgICAgcmV0dXJuIGlzU3RhcnQgPyBsciA6IHJsO1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHJldHVybiBpc1N0YXJ0ID8gdGIgOiBidDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFtdO1xuICB9XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzKHBsYWNlbWVudCwgZmxpcEFsaWdubWVudCwgZGlyZWN0aW9uLCBydGwpIHtcbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGxldCBsaXN0ID0gZ2V0U2lkZUxpc3QoZ2V0U2lkZShwbGFjZW1lbnQpLCBkaXJlY3Rpb24gPT09ICdzdGFydCcsIHJ0bCk7XG4gIGlmIChhbGlnbm1lbnQpIHtcbiAgICBsaXN0ID0gbGlzdC5tYXAoc2lkZSA9PiBzaWRlICsgXCItXCIgKyBhbGlnbm1lbnQpO1xuICAgIGlmIChmbGlwQWxpZ25tZW50KSB7XG4gICAgICBsaXN0ID0gbGlzdC5jb25jYXQobGlzdC5tYXAoZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpc3Q7XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgc2lkZSA9PiBvcHBvc2l0ZVNpZGVNYXBbc2lkZV0pO1xufVxuZnVuY3Rpb24gZXhwYW5kUGFkZGluZ09iamVjdChwYWRkaW5nKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwLFxuICAgIC4uLnBhZGRpbmdcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhZGRpbmdPYmplY3QocGFkZGluZykge1xuICByZXR1cm4gdHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gZXhwYW5kUGFkZGluZ09iamVjdChwYWRkaW5nKSA6IHtcbiAgICB0b3A6IHBhZGRpbmcsXG4gICAgcmlnaHQ6IHBhZGRpbmcsXG4gICAgYm90dG9tOiBwYWRkaW5nLFxuICAgIGxlZnQ6IHBhZGRpbmdcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICByZXR1cm4ge1xuICAgIC4uLnJlY3QsXG4gICAgdG9wOiByZWN0LnksXG4gICAgbGVmdDogcmVjdC54LFxuICAgIHJpZ2h0OiByZWN0LnggKyByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogcmVjdC55ICsgcmVjdC5oZWlnaHRcbiAgfTtcbn1cblxuZXhwb3J0IHsgYWxpZ25tZW50cywgY2xhbXAsIGNyZWF0ZUNvb3JkcywgZXZhbHVhdGUsIGV4cGFuZFBhZGRpbmdPYmplY3QsIGZsb29yLCBnZXRBbGlnbm1lbnQsIGdldEFsaWdubWVudEF4aXMsIGdldEFsaWdubWVudFNpZGVzLCBnZXRBeGlzTGVuZ3RoLCBnZXRFeHBhbmRlZFBsYWNlbWVudHMsIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50LCBnZXRPcHBvc2l0ZUF4aXMsIGdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMsIGdldE9wcG9zaXRlUGxhY2VtZW50LCBnZXRQYWRkaW5nT2JqZWN0LCBnZXRTaWRlLCBnZXRTaWRlQXhpcywgbWF4LCBtaW4sIHBsYWNlbWVudHMsIHJlY3RUb0NsaWVudFJlY3QsIHJvdW5kLCBzaWRlcyB9O1xuIl0sIm5hbWVzIjpbInNpZGVzIiwiYWxpZ25tZW50cyIsInBsYWNlbWVudHMiLCJyZWR1Y2UiLCJhY2MiLCJzaWRlIiwiY29uY2F0IiwibWluIiwiTWF0aCIsIm1heCIsInJvdW5kIiwiZmxvb3IiLCJjcmVhdGVDb29yZHMiLCJ2IiwieCIsInkiLCJvcHBvc2l0ZVNpZGVNYXAiLCJsZWZ0IiwicmlnaHQiLCJib3R0b20iLCJ0b3AiLCJvcHBvc2l0ZUFsaWdubWVudE1hcCIsInN0YXJ0IiwiZW5kIiwiY2xhbXAiLCJ2YWx1ZSIsImV2YWx1YXRlIiwicGFyYW0iLCJnZXRTaWRlIiwicGxhY2VtZW50Iiwic3BsaXQiLCJnZXRBbGlnbm1lbnQiLCJnZXRPcHBvc2l0ZUF4aXMiLCJheGlzIiwiZ2V0QXhpc0xlbmd0aCIsImdldFNpZGVBeGlzIiwiaW5jbHVkZXMiLCJnZXRBbGlnbm1lbnRBeGlzIiwiZ2V0QWxpZ25tZW50U2lkZXMiLCJyZWN0cyIsInJ0bCIsImFsaWdubWVudCIsImFsaWdubWVudEF4aXMiLCJsZW5ndGgiLCJtYWluQWxpZ25tZW50U2lkZSIsInJlZmVyZW5jZSIsImZsb2F0aW5nIiwiZ2V0T3Bwb3NpdGVQbGFjZW1lbnQiLCJnZXRFeHBhbmRlZFBsYWNlbWVudHMiLCJvcHBvc2l0ZVBsYWNlbWVudCIsImdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50IiwicmVwbGFjZSIsImdldFNpZGVMaXN0IiwiaXNTdGFydCIsImxyIiwicmwiLCJ0YiIsImJ0IiwiZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyIsImZsaXBBbGlnbm1lbnQiLCJkaXJlY3Rpb24iLCJsaXN0IiwibWFwIiwiZXhwYW5kUGFkZGluZ09iamVjdCIsInBhZGRpbmciLCJfb2JqZWN0U3ByZWFkIiwiZ2V0UGFkZGluZ09iamVjdCIsInJlY3RUb0NsaWVudFJlY3QiLCJyZWN0Iiwid2lkdGgiLCJoZWlnaHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\n");

/***/ })

};
;